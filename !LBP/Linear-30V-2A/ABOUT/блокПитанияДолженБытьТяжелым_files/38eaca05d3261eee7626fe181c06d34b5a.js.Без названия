/**
 * JsHttpRequest: JavaScript "AJAX" data loader
 *
 * @license LGPL
 * @author Dmitry Koterov, http://en.dklab.ru/lib/JsHttpRequest/
 * @version 5.x $Id$
 */

// {{{
function JsHttpRequest() {
    // Standard properties.
    var t = this;
    t.onreadystatechange = null;
    t.readyState         = 0;
    t.responseText       = null;
    t.responseXML        = null;
    t.status             = 200;
    t.statusText         = "OK";
    // JavaScript response array/hash
    t.responseJS         = null;

    // Additional properties.
    t.caching            = false;        // need to use caching?
    t.loader             = null;         // loader to use ('form', 'script', 'xml'; null - autodetect)
    t.session_name       = "PHPSESSID";  // set to SID cookie or GET parameter name

    // Internals.
    t._ldObj              = null;  // used loader object
    t._reqHeaders        = [];    // collected request headers
    t._openArgs          = null;  // parameters from open()
    t._errors = {
        inv_form_el:        'Invalid FORM element detected: name=%, tag=%',
        must_be_single_el:  'If used, <form> must be a single HTML element in the list.',
        js_invalid:         'JavaScript code generated by backend is invalid!\n%',
        url_too_long:       'Cannot use so long query with GET request (URL is larger than % bytes)',
        unk_loader:         'Unknown loader: %',
        no_loaders:         'No loaders registered at all, please check JsHttpRequest.LOADERS array',
        no_loader_matched:  'Cannot find a loader which may process the request. Notices are:\n%'
    }
    
    /**
     * Aborts the request. Behaviour of this function for onreadystatechange() 
     * is identical to IE (most universal and common case). E.g., readyState -> 4
     * on abort() after send().
     */
    t.abort = function() { with (this) {
        if (_ldObj && _ldObj.abort) _ldObj.abort();
        _cleanup();
        if (readyState == 0) {
            // start->abort: no change of readyState (IE behaviour)
            return;
        }
        if (readyState == 1 && !_ldObj) {
            // open->abort: no onreadystatechange call, but change readyState to 0 (IE).
            // send->abort: change state to 4 (_ldObj is not null when send() is called)
            readyState = 0;
            return;
        }
        _changeReadyState(4, true); // 4 in IE & FF on abort() call; Opera does not change to 4.
    }}
    
    /**
     * Prepares the object for data loading.
     * You may also pass URLs like "GET url" or "script.GET url".
     */
    t.open = function(method, url, asyncFlag, username, password) { with (this) {
        // Extract methor and loader from the URL (if present).
        if (url.match(/^((\w+)\.)?(GET|POST)\s+(.*)/i)) {
            this.loader = RegExp.$2? RegExp.$2 : null;
            method = RegExp.$3;
            url = RegExp.$4; 
        }
        // Append SID to original URL. Use try...catch for security problems.
        try {
            if (
                document.location.search.match(new RegExp('[&?]' + session_name + '=([^&?]*)'))
                || document.cookie.match(new RegExp('(?:;|^)\\s*' + session_name + '=([^;]*)'))
            ) {
                url += (url.indexOf('?') >= 0? '&' : '?') + session_name + "=" + this.escape(RegExp.$1);
            }
        } catch (e) {}
        // Store open arguments to hash.
        _openArgs = {
            method:     (method || '').toUpperCase(),
            url:        url,
            asyncFlag:  asyncFlag,
            username:   username != null? username : '',
            password:   password != null? password : ''
        }
        _ldObj = null;
        _changeReadyState(1, true); // compatibility with XMLHttpRequest
        return true;
    }}
    
    /**
     * Sends a request to a server.
     */
    t.send = function(content) {
        if (!this.readyState) {
            // send without open or after abort: no action (IE behaviour).
            return;
        }
        this._changeReadyState(1, true); // compatibility with XMLHttpRequest
        this._ldObj = null;
        
        // Prepare to build QUERY_STRING from query hash.
        var queryText = [];
        var queryElem = [];
        if (!this._hash2query(content, null, queryText, queryElem)) return;
    
        // Solve the query hashcode & return on cache hit.
        var hash = null;
        if (this.caching && !queryElem.length) {
            hash = this._openArgs.username + ':' + this._openArgs.password + '@' + this._openArgs.url + '|' + queryText + "#" + this._openArgs.method;
            var cache = JsHttpRequest.CACHE[hash];
            if (cache) {
                this._dataReady(cache[0], cache[1]);
                return false;
            }
        }
    
        // Try all the loaders.
        var loader = (this.loader || '').toLowerCase();
        if (loader && !JsHttpRequest.LOADERS[loader]) return this._error('unk_loader', loader);
        var errors = [];
        var lds = JsHttpRequest.LOADERS;
        for (var tryLoader in lds) {
            var ldr = lds[tryLoader].loader;
            if (!ldr) continue; // exclude possibly derived prototype properties from "for .. in".
            if (loader && tryLoader != loader) continue;
            // Create sending context.
            var ldObj = new ldr(this);
            JsHttpRequest.extend(ldObj, this._openArgs);
            JsHttpRequest.extend(ldObj, {
                queryText:  queryText.join('&'),
                queryElem:  queryElem,
                id:         (new Date().getTime()) + "" + JsHttpRequest.COUNT++,
                hash:       hash,
                span:       null
            });
            var error = ldObj.load();
            if (!error) {
                // Save loading script.
                this._ldObj = ldObj;
                JsHttpRequest.PENDING[ldObj.id] = this;
                return true;
            }
            if (!loader) {
                errors[errors.length] = '- ' + tryLoader.toUpperCase() + ': ' + this._l(error);
            } else {
                return this._error(error);
            }
        }
    
        // If no loader matched, generate error message.
        return tryLoader? this._error('no_loader_matched', errors.join('\n')) : this._error('no_loaders');
    }
    
    /**
     * Returns all response headers (if supported).
     */
    t.getAllResponseHeaders = function() { with (this) {
        return _ldObj && _ldObj.getAllResponseHeaders? _ldObj.getAllResponseHeaders() : [];
    }}

    /**
     * Returns one response header (if supported).
     */
    t.getResponseHeader = function(label) { with (this) {
        return _ldObj && _ldObj.getResponseHeader? _ldObj.getResponseHeader(label) : null;
    }}

    /**
     * Adds a request header to a future query.
     */
    t.setRequestHeader = function(label, value) { with (this) {
        _reqHeaders[_reqHeaders.length] = [label, value];
    }}
    
    //
    // Internal functions.
    //
    
    /**
     * Do all the work when a data is ready.
     */
    t._dataReady = function(text, js) { with (this) {
        if (caching && _ldObj) JsHttpRequest.CACHE[_ldObj.hash] = [text, js];
        responseText = responseXML = text;
        responseJS = js;
        if (js !== null) {
            status = 200;
            statusText = "OK";
        } else {
            status = 500;
            statusText = "Internal Server Error";
        }
        _changeReadyState(2);
        _changeReadyState(3);
        _changeReadyState(4);
        _cleanup();
    }}
    
    /**
     * Analog of sprintf(), but translates the first parameter by _errors.
     */
    t._l = function(args) {
        var i = 0, p = 0, msg = this._errors[args[0]];
        // Cannot use replace() with a callback, because it is incompatible with IE5.
        while ((p = msg.indexOf('%', p)) >= 0) {
            var a = args[++i] + "";
            msg = msg.substring(0, p) + a + msg.substring(p + 1, msg.length);
            p += 1 + a.length;
        }
        return msg;
    }

    /** 
     * Called on error.
     */
    t._error = function(msg) {
        msg = this._l(typeof(msg) == 'string'? arguments : msg)
        msg = "JsHttpRequest: " + msg;
        if (!window.Error) {
            // Very old browser...
            throw msg;
        } else if ((new Error(1, 'test')).description == "test") {
            // We MUST (!!!) pass 2 parameters to the Error() constructor for IE5.
            throw new Error(1, msg);
        } else {
            // Mozilla does not support two-parameter call style.
            throw new Error(msg);
        }
    }
    
    /**
     * Convert hash to QUERY_STRING.
     * If next value is scalar or hash, push it to queryText.
     * If next value is form element, push [name, element] to queryElem.
     */
    t._hash2query = function(content, prefix, queryText, queryElem) {
        if (prefix == null) prefix = "";
        if((''+typeof(content)).toLowerCase() == 'object') {
            var formAdded = false;
            if (content && content.parentNode && content.parentNode.appendChild && content.tagName && content.tagName.toUpperCase() == 'FORM') {
                content = { form: content };
            }
            for (var k in content) {
                var v = content[k];
                if (v instanceof Function) continue;
                var curPrefix = prefix? prefix + '[' + this.escape(k) + ']' : this.escape(k);
                var isFormElement = v && v.parentNode && v.parentNode.appendChild && v.tagName;
                if (isFormElement) {
                    var tn = v.tagName.toUpperCase();
                    if (tn == 'FORM') {
                        // FORM itself is passed.
                        formAdded = true;
                    } else if (tn == 'INPUT' || tn == 'TEXTAREA' || tn == 'SELECT') {
                        // This is a single form elemenent.
                    } else {
                        return this._error('inv_form_el', (v.name||''), v.tagName);
                    }
                    queryElem[queryElem.length] = { name: curPrefix, e: v };
                } else if (v instanceof Object) {
                    this._hash2query(v, curPrefix, queryText, queryElem);
                } else {
                    // We MUST skip NULL values, because there is no method
                    // to pass NULL's via GET or POST request in PHP.
                    if (v === null) continue;
                    // Convert JS boolean true and false to corresponding PHP values.
                    if (v === true) v = 1; 
                    if (v === false) v = '';
                    queryText[queryText.length] = curPrefix + "=" + this.escape('' + v);
                }
                if (formAdded && queryElem.length > 1) {
                    return this._error('must_be_single_el');
                }
            }
        } else {
            queryText[queryText.length] = content;
        }
        return true;
    }
    
    /**
     * Remove last used script element (clean memory).
     */
    t._cleanup = function() {
        var ldObj = this._ldObj;
        if (!ldObj) return;
        // Mark this loading as aborted.
        JsHttpRequest.PENDING[ldObj.id] = false;
        var span = ldObj.span;
        if (!span) return;
        // Do NOT use iframe.contentWindow.back() - it is incompatible with Opera 9!
        ldObj.span = null;
        var closure = function() {
            span.parentNode.removeChild(span);
        }
        // IE5 crashes on setTimeout(function() {...}, ...) construction! Use tmp variable.
        JsHttpRequest.setTimeout(closure, 50);
    }
    
    /**
     * Change current readyState and call trigger method.
     */
    t._changeReadyState = function(s, reset) { with (this) {
        if (reset) {
            status = statusText = responseJS = null;
            responseText = '';
        }
        readyState = s;
        if (onreadystatechange) onreadystatechange();
    }}
    
    /**
     * JS escape() does not quote '+'.
     */
    t.escape = function(s) {
        return escape(s).replace(new RegExp('\\+','g'), '%2B');
    }
}


// Global library variables.
JsHttpRequest.COUNT = 0;              // unique ID; used while loading IDs generation
JsHttpRequest.MAX_URL_LEN = 2000;     // maximum URL length
JsHttpRequest.CACHE = {};             // cached data
JsHttpRequest.PENDING = {};           // pending loadings
JsHttpRequest.LOADERS = {};           // list of supported data loaders (filled at the bottom of the file)
JsHttpRequest._dummy = function() {}; // avoid memory leaks


/**
 * These functions are dirty hacks for IE 5.0 which does not increment a
 * reference counter for an object passed via setTimeout(). So, if this 
 * object (closure function) is out of scope at the moment of timeout 
 * applying, IE 5.0 crashes. 
 */

/**
 * Timeout wrappers storage. Used to avoid zeroing of referece counts in IE 5.0.
 * Please note that you MUST write "window.setTimeout", not "setTimeout", else
 * IE 5.0 crashes again. Strange, very strange...
 */
JsHttpRequest.TIMEOUTS = { s: window.setTimeout, c: window.clearTimeout };

/**
 * Wrapper for IE5 buggy setTimeout.
 * Use this function instead of a usual setTimeout().
 */
JsHttpRequest.setTimeout = function(func, dt) {
    // Always save inside the window object before a call (for FF)!
    window.JsHttpRequest_tmp = JsHttpRequest.TIMEOUTS.s; 
    if (typeof(func) == "string") {
        id = window.JsHttpRequest_tmp(func, dt);
    } else {
        var id = null;
        var mediator = function() {
            func();
            delete JsHttpRequest.TIMEOUTS[id]; // remove circular reference
        }
        id = window.JsHttpRequest_tmp(mediator, dt);
        // Store a reference to the mediator function to the global array
        // (reference count >= 1); use timeout ID as an array key;
        JsHttpRequest.TIMEOUTS[id] = mediator;
    }
    window.JsHttpRequest_tmp = null; // no delete() in IE5 for window
    return id;
}

/**
 * Complimental wrapper for clearTimeout. 
 * Use this function instead of usual clearTimeout().
 */
JsHttpRequest.clearTimeout = function(id) {
    window.JsHttpRequest_tmp = JsHttpRequest.TIMEOUTS.c;
    delete JsHttpRequest.TIMEOUTS[id]; // remove circular reference
    var r = window.JsHttpRequest_tmp(id);
    window.JsHttpRequest_tmp = null; // no delete() in IE5 for window
    return r;
}


/**
 * Global static function.
 * Simple interface for most popular use-cases.
 * You may also pass URLs like "GET url" or "script.GET url".
 */
JsHttpRequest.query = function(url, content, onready, nocache) {
    var req = new this();
    req.caching = !nocache;
    req.onreadystatechange = function() {
        if (req.readyState == 4) {
            onready(req.responseJS, req.responseText);
        }
    }
    req.open(null, url, true);
    req.send(content);
}


/**
 * Global static function.
 * Called by server backend script on data load.
 */
JsHttpRequest.dataReady = function(d) {
    var th = this.PENDING[d.id];
    delete this.PENDING[d.id];
    if (th) {
        th._dataReady(d.text, d.js);
    } else if (th !== false) {
        throw "dataReady(): unknown pending id: " + d.id;
    }
}


// Adds all the properties of src to dest.
JsHttpRequest.extend = function(dest, src) {
    for (var k in src) dest[k] = src[k];
}

/**
 * Each loader has the following properties which must be initialized:
 * - method
 * - url
 * - asyncFlag (ignored)
 * - username
 * - password
 * - queryText (string)
 * - queryElem (array)
 * - id
 * - hash
 * - span
 */ 
 
// }}}

// {{{ xml
// Loader: XMLHttpRequest or ActiveX.
// [+] GET and POST methods are supported.
// [+] Most native and memory-cheap method.
// [+] Backend data can be browser-cached.
// [-] Cannot work in IE without ActiveX. 
// [-] No support for loading from different domains.
// [-] No uploading support.
//
JsHttpRequest.LOADERS.xml = { loader: function(req) {
    JsHttpRequest.extend(req._errors, {
        xml_no:          'Cannot use XMLHttpRequest or ActiveX loader: not supported',
        xml_no_diffdom:  'Cannot use XMLHttpRequest to load data from different domain %',
        xml_no_headers:  'Cannot use XMLHttpRequest loader or ActiveX loader, POST method: headers setting is not supported, needed to work with encodings correctly',
        xml_no_form_upl: 'Cannot use XMLHttpRequest loader: direct form elements using and uploading are not implemented'
    });
    
    this.load = function() {
        if (this.queryElem.length) return ['xml_no_form_upl'];
        
        // XMLHttpRequest (and MS ActiveX'es) cannot work with different domains.
        if (this.url.match(new RegExp('^([a-z]+://[^\\/]+)(.*)', 'i'))) {
        	// We MUST also check if protocols matched: cannot send from HTTP 
        	// to HTTPS and vice versa.
            if (RegExp.$1.toLowerCase() != document.location.protocol + '//' + document.location.hostname.toLowerCase()) {
                return ['xml_no_diffdom', RegExp.$1];
            }
        }
        
        // Try to obtain a loader.
        var xr = null;
        if (window.XMLHttpRequest) {
            try { xr = new XMLHttpRequest() } catch(e) {}
        } else if (window.ActiveXObject) {
            try { xr = new ActiveXObject("Microsoft.XMLHTTP") } catch(e) {}
            if (!xr) try { xr = new ActiveXObject("Msxml2.XMLHTTP") } catch (e) {}
        }
        if (!xr) return ['xml_no'];
        
        // Loading method detection. We cannot POST if we cannot set "octet-stream" 
        // header, because we need to process the encoded data in the backend manually.
        var canSetHeaders = window.ActiveXObject || xr.setRequestHeader;
        if (!this.method) this.method = canSetHeaders && this.queryText.length? 'POST' : 'GET';
        
        // Build & validate the full URL.
        if (this.method == 'GET') {
            if (this.queryText) this.url += (this.url.indexOf('?') >= 0? '&' : '?') + this.queryText;
            this.queryText = '';
            if (this.url.length > JsHttpRequest.MAX_URL_LEN) return ['url_too_long', JsHttpRequest.MAX_URL_LEN];
        } else if (this.method == 'POST' && !canSetHeaders) {
            return ['xml_no_headers'];
        }
        
        // Add ID to the url if we need to disable the cache.
        this.url += (this.url.indexOf('?') >= 0? '&' : '?') + 'JsHttpRequest=' + (req.caching? '0' : this.id) + '-xml';        
        
        // Assign the result handler.
        var id = this.id;
        xr.onreadystatechange = function() { 
            if (xr.readyState != 4) return;
            // Avoid memory leak by removing the closure.
            xr.onreadystatechange = JsHttpRequest._dummy;
            req.status = null;
            try { 
                // In case of abort() call, xr.status is unavailable and generates exception.
                // But xr.readyState equals to 4 in this case. Stupid behaviour. :-(
                req.status = xr.status;
                req.responseText = xr.responseText;
            } catch (e) {}
            if (!req.status) return;
            try {
                // Prepare generator function & catch syntax errors on this stage.
                eval('JsHttpRequest._tmp = function(id) { var d = ' + req.responseText + '; d.id = id; JsHttpRequest.dataReady(d); }');
            } catch (e) {
                // Note that FF 2.0 does not throw any error from onreadystatechange handler.
                return req._error('js_invalid', req.responseText)
            }
            // Call associated dataReady() outside the try-catch block 
            // to pass exceptions in onreadystatechange in usual manner.
            JsHttpRequest._tmp(id);
            JsHttpRequest._tmp = null;
        };

        // Open & send the request.
        xr.open(this.method, this.url, true, this.username, this.password);
        if (canSetHeaders) {
            // Pass pending headers.
            for (var i = 0; i < req._reqHeaders.length; i++) {
                xr.setRequestHeader(req._reqHeaders[i][0], req._reqHeaders[i][1]);
            }
            // Set non-default Content-type. We cannot use 
            // "application/x-www-form-urlencoded" here, because 
            // in PHP variable HTTP_RAW_POST_DATA is accessible only when 
            // enctype is not default (e.g., "application/octet-stream" 
            // is a good start). We parse POST data manually in backend 
            // library code. Note that Safari sets by default "x-www-form-urlencoded"
            // header, but FF sets "text/xml" by default.
            xr.setRequestHeader('Content-Type', 'application/octet-stream');
        }
        xr.send(this.queryText);
        
        // No SPAN is used for this loader.
        this.span = null;
        this.xr = xr; // save for later usage on abort()
        
        // Success.
        return null;
    }
    
    // Override req.getAllResponseHeaders method.
    this.getAllResponseHeaders = function() {
        return this.xr.getAllResponseHeaders();
    }
    
    // Override req.getResponseHeader method.
    this.getResponseHeader = function(label) {
        return this.xr.getResponseHeader(label);
    }

    this.abort = function() {
        this.xr.abort();
        this.xr = null;
    }
}}
// }}}


// {{{ script
// Loader: SCRIPT tag.
// [+] Most cross-browser. 
// [+] Supports loading from different domains.
// [-] Only GET method is supported.
// [-] No uploading support.
// [-] Backend data cannot be browser-cached.
//
JsHttpRequest.LOADERS.script = { loader: function(req) {
    JsHttpRequest.extend(req._errors, {
        script_only_get:   'Cannot use SCRIPT loader: it supports only GET method',
        script_no_form:    'Cannot use SCRIPT loader: direct form elements using and uploading are not implemented'
    })
    
    this.load = function() {
        // Move GET parameters to the URL itself.
        if (this.queryText) this.url += (this.url.indexOf('?') >= 0? '&' : '?') + this.queryText;
        this.url += (this.url.indexOf('?') >= 0? '&' : '?') + 'JsHttpRequest=' + this.id + '-' + 'script';        
        this.queryText = '';
        
        if (!this.method) this.method = 'GET';
        if (this.method !== 'GET') return ['script_only_get'];
        if (this.queryElem.length) return ['script_no_form'];
        if (this.url.length > JsHttpRequest.MAX_URL_LEN) return ['url_too_long', JsHttpRequest.MAX_URL_LEN];

        var th = this, d = document, s = null, b = d.body;
        if (!window.opera) {
            // Safari, IE, FF, Opera 7.20.
            this.span = s = d.createElement('SCRIPT');
            var closure = function() {
                s.language = 'JavaScript';
                if (s.setAttribute) s.setAttribute('src', th.url); else s.src = th.url;
                b.insertBefore(s, b.lastChild);
            }
        } else {
            // Oh shit! Damned stupid Opera 7.23 does not allow to create SCRIPT 
            // element over createElement (in HEAD or BODY section or in nested SPAN - 
            // no matter): it is created deadly, and does not response the href assignment.
            // So - always create SPAN.
            this.span = s = d.createElement('SPAN');
            s.style.display = 'none';
            b.insertBefore(s, b.lastChild);
            s.innerHTML = 'Workaround for IE.<s'+'cript></' + 'script>';
            var closure = function() {
                s = s.getElementsByTagName('SCRIPT')[0]; // get with timeout!
                s.language = 'JavaScript';
                if (s.setAttribute) s.setAttribute('src', th.url); else s.src = th.url;
            }
        }
        JsHttpRequest.setTimeout(closure, 10);
        
        // Success.
        return null;
    }
}}
// }}}


// {{{ form
// Loader: FORM & IFRAME.
// [+] Supports file uploading.
// [+] GET and POST methods are supported.
// [+] Supports loading from different domains.
// [-] Uses a lot of system resources.
// [-] Backend data cannot be browser-cached.
// [-] Pollutes browser history on some old browsers.
//
JsHttpRequest.LOADERS.form = { loader: function(req) {
    JsHttpRequest.extend(req._errors, {
        form_el_not_belong:  'Element "%" does not belong to any form!',
        form_el_belong_diff: 'Element "%" belongs to a different form. All elements must belong to the same form!',
        form_el_inv_enctype: 'Attribute "enctype" of the form must be "%" (for IE), "%" given.'
    })
    
    this.load = function() {
        var th = this;
     
        if (!th.method) th.method = 'POST';
        th.url += (th.url.indexOf('?') >= 0? '&' : '?') + 'JsHttpRequest=' + th.id + '-' + 'form';
        
        // If GET, build full URL. Then copy QUERY_STRING to queryText.
        if (th.method == 'GET') {
            if (th.queryText) th.url += (th.url.indexOf('?') >= 0? '&' : '?') + th.queryText;
            if (th.url.length > JsHttpRequest.MAX_URL_LEN) return ['url_too_long', JsHttpRequest.MAX_URL_LEN];
            var p = th.url.split('?', 2);
            th.url = p[0];
            th.queryText = p[1] || '';
        }

        // Check if all form elements belong to same form.
        var form = null;
        var wholeFormSending = false;
        if (th.queryElem.length) {
            if (th.queryElem[0].e.tagName.toUpperCase() == 'FORM') {
                // Whole FORM sending.
                form = th.queryElem[0].e;
                wholeFormSending = true;
                th.queryElem = [];
            } else {
                // If we have at least one form element, we use its FORM as a POST container.
                form = th.queryElem[0].e.form;
                // Validate all the elements.
                for (var i = 0; i < th.queryElem.length; i++) {
                    var e = th.queryElem[i].e;
                    if (!e.form) {
                        return ['form_el_not_belong', e.name];
                    }
                    if (e.form != form) {
                        return ['form_el_belong_diff', e.name];
                    }
                }
            }
            
            // Check enctype of the form.
            if (th.method == 'POST') {
                var need = "multipart/form-data";
                var given = (form.attributes.encType && form.attributes.encType.nodeValue) || (form.attributes.enctype && form.attributes.enctype.value) || form.enctype;
                if (given != need) {
                    return ['form_el_inv_enctype', need, given];
                }
            }
        }

        // Create invisible IFRAME with temporary form (form is used on empty queryElem).
        // We ALWAYS create th IFRAME in the document of the form - for Opera 7.20.
        var d = form && (form.ownerDocument || form.document) || document;
        var ifname = 'jshr_i_' + th.id;
        var s = th.span = d.createElement('DIV');
        s.style.position = 'absolute';
        s.style.display = 'none';
        s.style.visibility = 'hidden';
        s.innerHTML = 
            (form? '' : '<form' + (th.method == 'POST'? ' enctype="multipart/form-data" method="post"' : '') + '></form>') + // stupid IE, MUST use innerHTML assignment :-(
            '<iframe name="' + ifname + '" id="' + ifname + '" style="width:0px; height:0px; overflow:hidden; border:none"></iframe>'
        if (!form) {
            form = th.span.firstChild;
        }

        // Insert generated form inside the document.
        // Be careful: don't forget to close FORM container in document body!
        d.body.insertBefore(s, d.body.lastChild);

        // Function to safely set the form attributes. Parameter attr is NOT a hash 
        // but an array, because "for ... in" may badly iterate over derived attributes.
        var setAttributes = function(e, attr) {
            var sv = [];
            var form = e;
            // This strange algorythm is needed, because form may  contain element 
            // with name like 'action'. In IE for such attribute will be returned
            // form element node, not form action. Workaround: copy all attributes
            // to new empty form and work with it, then copy them back. This is
            // THE ONLY working algorythm since a lot of bugs in IE5.0 (e.g. 
            // with e.attributes property: causes IE crash).
            if (e.mergeAttributes) {
                var form = d.createElement('form');
                form.mergeAttributes(e, false);
            }
            for (var i = 0; i < attr.length; i++) {
                var k = attr[i][0], v = attr[i][1];
                // TODO: http://forum.dklab.ru/viewtopic.php?p=129059#129059
                sv[sv.length] = [k, form.getAttribute(k)];
                form.setAttribute(k, v);
            }
            if (e.mergeAttributes) {
                e.mergeAttributes(form, false);
            }
            return sv;
        }

        // Run submit with delay - for old Opera: it needs some time to create IFRAME.
        var closure = function() {
            // Save JsHttpRequest object to new IFRAME.
            top.JsHttpRequestGlobal = JsHttpRequest;
            
            // Disable ALL the form elements.
            var savedNames = [];
            if (!wholeFormSending) {
                for (var i = 0, n = form.elements.length; i < n; i++) {
                    savedNames[i] = form.elements[i].name;
                    form.elements[i].name = '';
                }
            }

            // Insert hidden fields to the form.
            var qt = th.queryText.split('&');
            for (var i = qt.length - 1; i >= 0; i--) {
                var pair = qt[i].split('=', 2);
                var e = d.createElement('INPUT');
                e.type = 'hidden';
                e.name = unescape(pair[0]);
                e.value = pair[1] != null? unescape(pair[1]) : '';
                form.appendChild(e);
            }


            // Change names of along user-passed form elements.
            for (var i = 0; i < th.queryElem.length; i++) {
                th.queryElem[i].e.name = th.queryElem[i].name;
            }

            // Temporary modify form attributes, submit form, restore attributes back.
            var sv = setAttributes(
                form, 
                [
                    ['action',   th.url],
                    ['method',   th.method],
                    ['onsubmit', null],
                    ['target',   ifname]
                ]
            );
            form.submit();
            setAttributes(form, sv);

            // Remove generated temporary hidden elements from the top of the form.
            for (var i = 0; i < qt.length; i++) {
                // Use "form.firstChild.parentNode", not "form", or IE5 crashes!
                form.lastChild.parentNode.removeChild(form.lastChild);
            }
            // Enable all disabled elements back.
            if (!wholeFormSending) {
                for (var i = 0, n = form.elements.length; i < n; i++) {
                    form.elements[i].name = savedNames[i];
                }
            }
        }
        JsHttpRequest.setTimeout(closure, 100);

        // Success.
        return null;
    }    
}}
// }}}

;
/*
---

name: Core

description: The heart of MooTools.

license: MIT-style license.

copyright: Copyright (c) 2006-2015 [Valerio Proietti](http://mad4milk.net/).

authors: The MooTools production team (http://mootools.net/developers/)

inspiration:
  - Class implementation inspired by [Base.js](http://dean.edwards.name/weblog/2006/03/base/) Copyright (c) 2006 Dean Edwards, [GNU Lesser General Public License](http://opensource.org/licenses/lgpl-license.php)
  - Some functionality inspired by [Prototype.js](http://prototypejs.org) Copyright (c) 2005-2007 Sam Stephenson, [MIT License](http://opensource.org/licenses/mit-license.php)

provides: [Core, MooTools, Type, typeOf, instanceOf, Native]

...
*/
/*! MooTools: the javascript framework. license: MIT-style license. copyright: Copyright (c) 2006-2015 [Valerio Proietti](http://mad4milk.net/).*/
(function(){

this.MooTools = {
	version: '1.5.2',
	build: 'ed01297a1a19de0675404640e7377cf97694e131'
};

// typeOf, instanceOf

var typeOf = this.typeOf = function(item){
	if (item == null) return 'null';
	if (item.$family != null) return item.$family();

	if (item.nodeName){
		if (item.nodeType == 1) return 'element';
		if (item.nodeType == 3) return (/\S/).test(item.nodeValue) ? 'textnode' : 'whitespace';
	} else if (typeof item.length == 'number'){
		if ('callee' in item) return 'arguments';
		if ('item' in item) return 'collection';
	}

	return typeof item;
};

var instanceOf = this.instanceOf = function(item, object){
	if (item == null) return false;
	var constructor = item.$constructor || item.constructor;
	while (constructor){
		if (constructor === object) return true;
		constructor = constructor.parent;
	}
	/*<ltIE8>*/
	if (!item.hasOwnProperty) return false;
	/*</ltIE8>*/
	return item instanceof object;
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

/*<ltIE8>*/
var enumerables = true;
for (var i in {toString: 1}) enumerables = null;
if (enumerables) enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'constructor'];
function forEachObjectEnumberableKey(object, fn, bind) {
	if (enumerables) for (var i = enumerables.length; i--;){
		var k = enumerables[i];
		// signature has key-value, so overloadSetter can directly pass the
		// method function, without swapping arguments.
		if (hasOwnProperty.call(object, k)) fn.call(bind, k, object[k]);
	}
}
/*</ltIE8>*/

// Function overloading

var Function = this.Function;

Function.prototype.overloadSetter = function(usePlural){
	var self = this;
	return function(a, b){
		if (a == null) return this;
		if (usePlural || typeof a != 'string'){
			for (var k in a) self.call(this, k, a[k]);
			/*<ltIE8>*/
			forEachObjectEnumberableKey(a, self, this);
			/*</ltIE8>*/
		} else {
			self.call(this, a, b);
		}
		return this;
	};
};

Function.prototype.overloadGetter = function(usePlural){
	var self = this;
	return function(a){
		var args, result;
		if (typeof a != 'string') args = a;
		else if (arguments.length > 1) args = arguments;
		else if (usePlural) args = [a];
		if (args){
			result = {};
			for (var i = 0; i < args.length; i++) result[args[i]] = self.call(this, args[i]);
		} else {
			result = self.call(this, a);
		}
		return result;
	};
};

Function.prototype.extend = function(key, value){
	this[key] = value;
}.overloadSetter();

Function.prototype.implement = function(key, value){
	this.prototype[key] = value;
}.overloadSetter();

// From

var slice = Array.prototype.slice;

Function.from = function(item){
	return (typeOf(item) == 'function') ? item : function(){
		return item;
	};
};

Array.from = function(item){
	if (item == null) return [];
	return (Type.isEnumerable(item) && typeof item != 'string') ? (typeOf(item) == 'array') ? item : slice.call(item) : [item];
};

Number.from = function(item){
	var number = parseFloat(item);
	return isFinite(number) ? number : null;
};

String.from = function(item){
	return item + '';
};

// hide, protect

Function.implement({

	hide: function(){
		this.$hidden = true;
		return this;
	},

	protect: function(){
		this.$protected = true;
		return this;
	}

});

// Type

var Type = this.Type = function(name, object){
	if (name){
		var lower = name.toLowerCase();
		var typeCheck = function(item){
			return (typeOf(item) == lower);
		};

		Type['is' + name] = typeCheck;
		if (object != null){
			object.prototype.$family = (function(){
				return lower;
			}).hide();
			//<1.2compat>
			object.type = typeCheck;
			//</1.2compat>
		}
	}

	if (object == null) return null;

	object.extend(this);
	object.$constructor = Type;
	object.prototype.$constructor = object;

	return object;
};

var toString = Object.prototype.toString;

Type.isEnumerable = function(item){
	return (item != null && typeof item.length == 'number' && toString.call(item) != '[object Function]' );
};

var hooks = {};

var hooksOf = function(object){
	var type = typeOf(object.prototype);
	return hooks[type] || (hooks[type] = []);
};

var implement = function(name, method){
	if (method && method.$hidden) return;

	var hooks = hooksOf(this);

	for (var i = 0; i < hooks.length; i++){
		var hook = hooks[i];
		if (typeOf(hook) == 'type') implement.call(hook, name, method);
		else hook.call(this, name, method);
	}

	var previous = this.prototype[name];
	if (previous == null || !previous.$protected) this.prototype[name] = method;

	if (this[name] == null && typeOf(method) == 'function') extend.call(this, name, function(item){
		return method.apply(item, slice.call(arguments, 1));
	});
};

var extend = function(name, method){
	if (method && method.$hidden) return;
	var previous = this[name];
	if (previous == null || !previous.$protected) this[name] = method;
};

Type.implement({

	implement: implement.overloadSetter(),

	extend: extend.overloadSetter(),

	alias: function(name, existing){
		implement.call(this, name, this.prototype[existing]);
	}.overloadSetter(),

	mirror: function(hook){
		hooksOf(this).push(hook);
		return this;
	}

});

new Type('Type', Type);

// Default Types

var force = function(name, object, methods){
	var isType = (object != Object),
		prototype = object.prototype;

	if (isType) object = new Type(name, object);

	for (var i = 0, l = methods.length; i < l; i++){
		var key = methods[i],
			generic = object[key],
			proto = prototype[key];

		if (generic) generic.protect();
		if (isType && proto) object.implement(key, proto.protect());
	}

	if (isType){
		var methodsEnumerable = prototype.propertyIsEnumerable(methods[0]);
		object.forEachMethod = function(fn){
			if (!methodsEnumerable) for (var i = 0, l = methods.length; i < l; i++){
				fn.call(prototype, prototype[methods[i]], methods[i]);
			}
			for (var key in prototype) fn.call(prototype, prototype[key], key);
		};
	}

	return force;
};

force('String', String, [
	'charAt', 'charCodeAt', 'concat', 'contains', 'indexOf', 'lastIndexOf', 'match', 'quote', 'replace', 'search',
	'slice', 'split', 'substr', 'substring', 'trim', 'toLowerCase', 'toUpperCase'
])('Array', Array, [
	'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift', 'concat', 'join', 'slice',
	'indexOf', 'lastIndexOf', 'filter', 'forEach', 'every', 'map', 'some', 'reduce', 'reduceRight', 'contains'
])('Number', Number, [
	'toExponential', 'toFixed', 'toLocaleString', 'toPrecision'
])('Function', Function, [
	'apply', 'call', 'bind'
])('RegExp', RegExp, [
	'exec', 'test'
])('Object', Object, [
	'create', 'defineProperty', 'defineProperties', 'keys',
	'getPrototypeOf', 'getOwnPropertyDescriptor', 'getOwnPropertyNames',
	'preventExtensions', 'isExtensible', 'seal', 'isSealed', 'freeze', 'isFrozen'
])('Date', Date, ['now']);

Object.extend = extend.overloadSetter();

Date.extend('now', function(){
	return +(new Date);
});

new Type('Boolean', Boolean);

// fixes NaN returning as Number

Number.prototype.$family = function(){
	return isFinite(this) ? 'number' : 'null';
}.hide();

// Number.random

Number.extend('random', function(min, max){
	return Math.floor(Math.random() * (max - min + 1) + min);
});

// forEach, each, keys

Array.implement({

	/*<!ES5>*/
	forEach: function(fn, bind){
		for (var i = 0, l = this.length; i < l; i++){
			if (i in this) fn.call(bind, this[i], i, this);
		}
	},
	/*</!ES5>*/

	each: function(fn, bind){
		Array.forEach(this, fn, bind);
		return this;
	}

});

Object.extend({

	keys: function(object){
		var keys = [];
		for (var k in object){
			if (hasOwnProperty.call(object, k)) keys.push(k);
		}
		/*<ltIE8>*/
		forEachObjectEnumberableKey(object, function(k){
			keys.push(k);
		});
		/*</ltIE8>*/
		return keys;
	},

	forEach: function(object, fn, bind){
		Object.keys(object).forEach(function(key){
			fn.call(bind, object[key], key, object);
		});
	}

});

Object.each = Object.forEach;


// Array & Object cloning, Object merging and appending

var cloneOf = function(item){
	switch (typeOf(item)){
		case 'array': return item.clone();
		case 'object': return Object.clone(item);
		default: return item;
	}
};

Array.implement('clone', function(){
	var i = this.length, clone = new Array(i);
	while (i--) clone[i] = cloneOf(this[i]);
	return clone;
});

var mergeOne = function(source, key, current){
	switch (typeOf(current)){
		case 'object':
			if (typeOf(source[key]) == 'object') Object.merge(source[key], current);
			else source[key] = Object.clone(current);
		break;
		case 'array': source[key] = current.clone(); break;
		default: source[key] = current;
	}
	return source;
};

Object.extend({

	merge: function(source, k, v){
		if (typeOf(k) == 'string') return mergeOne(source, k, v);
		for (var i = 1, l = arguments.length; i < l; i++){
			var object = arguments[i];
			for (var key in object) mergeOne(source, key, object[key]);
		}
		return source;
	},

	clone: function(object){
		var clone = {};
		for (var key in object) clone[key] = cloneOf(object[key]);
		return clone;
	},

	append: function(original){
		for (var i = 1, l = arguments.length; i < l; i++){
			var extended = arguments[i] || {};
			for (var key in extended) original[key] = extended[key];
		}
		return original;
	}

});

// Object-less types

['Object', 'WhiteSpace', 'TextNode', 'Collection', 'Arguments'].each(function(name){
	new Type(name);
});

// Unique ID

var UID = Date.now();

String.extend('uniqueID', function(){
	return (UID++).toString(36);
});

//<1.2compat>

var Hash = this.Hash = new Type('Hash', function(object){
	if (typeOf(object) == 'hash') object = Object.clone(object.getClean());
	for (var key in object) this[key] = object[key];
	return this;
});

Hash.implement({

	forEach: function(fn, bind){
		Object.forEach(this, fn, bind);
	},

	getClean: function(){
		var clean = {};
		for (var key in this){
			if (this.hasOwnProperty(key)) clean[key] = this[key];
		}
		return clean;
	},

	getLength: function(){
		var length = 0;
		for (var key in this){
			if (this.hasOwnProperty(key)) length++;
		}
		return length;
	}

});

Hash.alias('each', 'forEach');

Object.type = Type.isObject;

var Native = this.Native = function(properties){
	return new Type(properties.name, properties.initialize);
};

Native.type = Type.type;

Native.implement = function(objects, methods){
	for (var i = 0; i < objects.length; i++) objects[i].implement(methods);
	return Native;
};

var arrayType = Array.type;
Array.type = function(item){
	return instanceOf(item, Array) || arrayType(item);
};

this.$A = function(item){
	return Array.from(item).slice();
};

this.$arguments = function(i){
	return function(){
		return arguments[i];
	};
};

this.$chk = function(obj){
	return !!(obj || obj === 0);
};

this.$clear = function(timer){
	clearTimeout(timer);
	clearInterval(timer);
	return null;
};

this.$defined = function(obj){
	return (obj != null);
};

this.$each = function(iterable, fn, bind){
	var type = typeOf(iterable);
	((type == 'arguments' || type == 'collection' || type == 'array' || type == 'elements') ? Array : Object).each(iterable, fn, bind);
};

this.$empty = function(){};

this.$extend = function(original, extended){
	return Object.append(original, extended);
};

this.$H = function(object){
	return new Hash(object);
};

this.$merge = function(){
	var args = Array.slice(arguments);
	args.unshift({});
	return Object.merge.apply(null, args);
};

this.$lambda = Function.from;
this.$mixin = Object.merge;
this.$random = Number.random;
this.$splat = Array.from;
this.$time = Date.now;

this.$type = function(object){
	var type = typeOf(object);
	if (type == 'elements') return 'array';
	return (type == 'null') ? false : type;
};

this.$unlink = function(object){
	switch (typeOf(object)){
		case 'object': return Object.clone(object);
		case 'array': return Array.clone(object);
		case 'hash': return new Hash(object);
		default: return object;
	}
};

//</1.2compat>

})();

/*
---

name: Array

description: Contains Array Prototypes like each, contains, and erase.

license: MIT-style license.

requires: [Type]

provides: Array

...
*/

Array.implement({

	/*<!ES5>*/
	every: function(fn, bind){
		for (var i = 0, l = this.length >>> 0; i < l; i++){
			if ((i in this) && !fn.call(bind, this[i], i, this)) return false;
		}
		return true;
	},

	filter: function(fn, bind){
		var results = [];
		for (var value, i = 0, l = this.length >>> 0; i < l; i++) if (i in this){
			value = this[i];
			if (fn.call(bind, value, i, this)) results.push(value);
		}
		return results;
	},

	indexOf: function(item, from){
		var length = this.length >>> 0;
		for (var i = (from < 0) ? Math.max(0, length + from) : from || 0; i < length; i++){
			if (this[i] === item) return i;
		}
		return -1;
	},

	map: function(fn, bind){
		var length = this.length >>> 0, results = Array(length);
		for (var i = 0; i < length; i++){
			if (i in this) results[i] = fn.call(bind, this[i], i, this);
		}
		return results;
	},

	some: function(fn, bind){
		for (var i = 0, l = this.length >>> 0; i < l; i++){
			if ((i in this) && fn.call(bind, this[i], i, this)) return true;
		}
		return false;
	},
	/*</!ES5>*/

	clean: function(){
		return this.filter(function(item){
			return item != null;
		});
	},

	invoke: function(methodName){
		var args = Array.slice(arguments, 1);
		return this.map(function(item){
			return item[methodName].apply(item, args);
		});
	},

	associate: function(keys){
		var obj = {}, length = Math.min(this.length, keys.length);
		for (var i = 0; i < length; i++) obj[keys[i]] = this[i];
		return obj;
	},

	link: function(object){
		var result = {};
		for (var i = 0, l = this.length; i < l; i++){
			for (var key in object){
				if (object[key](this[i])){
					result[key] = this[i];
					delete object[key];
					break;
				}
			}
		}
		return result;
	},

	contains: function(item, from){
		return this.indexOf(item, from) != -1;
	},

	append: function(array){
		this.push.apply(this, array);
		return this;
	},

	getLast: function(){
		return (this.length) ? this[this.length - 1] : null;
	},

	getRandom: function(){
		return (this.length) ? this[Number.random(0, this.length - 1)] : null;
	},

	include: function(item){
		if (!this.contains(item)) this.push(item);
		return this;
	},

	combine: function(array){
		for (var i = 0, l = array.length; i < l; i++) this.include(array[i]);
		return this;
	},

	erase: function(item){
		for (var i = this.length; i--;){
			if (this[i] === item) this.splice(i, 1);
		}
		return this;
	},

	empty: function(){
		this.length = 0;
		return this;
	},

	flatten: function(){
		var array = [];
		for (var i = 0, l = this.length; i < l; i++){
			var type = typeOf(this[i]);
			if (type == 'null') continue;
			array = array.concat((type == 'array' || type == 'collection' || type == 'arguments' || instanceOf(this[i], Array)) ? Array.flatten(this[i]) : this[i]);
		}
		return array;
	},

	pick: function(){
		for (var i = 0, l = this.length; i < l; i++){
			if (this[i] != null) return this[i];
		}
		return null;
	},

	hexToRgb: function(array){
		if (this.length != 3) return null;
		var rgb = this.map(function(value){
			if (value.length == 1) value += value;
			return parseInt(value, 16);
		});
		return (array) ? rgb : 'rgb(' + rgb + ')';
	},

	rgbToHex: function(array){
		if (this.length < 3) return null;
		if (this.length == 4 && this[3] == 0 && !array) return 'transparent';
		var hex = [];
		for (var i = 0; i < 3; i++){
			var bit = (this[i] - 0).toString(16);
			hex.push((bit.length == 1) ? '0' + bit : bit);
		}
		return (array) ? hex : '#' + hex.join('');
	}

});

//<1.2compat>

Array.alias('extend', 'append');

var $pick = function(){
	return Array.from(arguments).pick();
};

//</1.2compat>

/*
---

name: Function

description: Contains Function Prototypes like create, bind, pass, and delay.

license: MIT-style license.

requires: Type

provides: Function

...
*/

Function.extend({

	attempt: function(){
		for (var i = 0, l = arguments.length; i < l; i++){
			try {
				return arguments[i]();
			} catch (e){}
		}
		return null;
	}

});

Function.implement({

	attempt: function(args, bind){
		try {
			return this.apply(bind, Array.from(args));
		} catch (e){}

		return null;
	},

	/*<!ES5-bind>*/
	bind: function(that){
		var self = this,
			args = arguments.length > 1 ? Array.slice(arguments, 1) : null,
			F = function(){};

		var bound = function(){
			var context = that, length = arguments.length;
			if (this instanceof bound){
				F.prototype = self.prototype;
				context = new F;
			}
			var result = (!args && !length)
				? self.call(context)
				: self.apply(context, args && length ? args.concat(Array.slice(arguments)) : args || arguments);
			return context == that ? result : context;
		};
		return bound;
	},
	/*</!ES5-bind>*/

	pass: function(args, bind){
		var self = this;
		if (args != null) args = Array.from(args);
		return function(){
			return self.apply(bind, args || arguments);
		};
	},

	delay: function(delay, bind, args){
		return setTimeout(this.pass((args == null ? [] : args), bind), delay);
	},

	periodical: function(periodical, bind, args){
		return setInterval(this.pass((args == null ? [] : args), bind), periodical);
	}

});

//<1.2compat>
/* https://github.com/google/recaptcha/issues/374 */
Function.prototype._nativebind = Function.prototype.bind;
delete Function.prototype.bind;

Function.implement({

	create: function(options){
		var self = this;
		options = options || {};
		return function(event){
			var args = options.arguments;
			args = (args != null) ? Array.from(args) : Array.slice(arguments, (options.event) ? 1 : 0);
			if (options.event) args = [event || window.event].extend(args);
			var returns = function(){
				return self.apply(options.bind || null, args);
			};
			if (options.delay) return setTimeout(returns, options.delay);
			if (options.periodical) return setInterval(returns, options.periodical);
			if (options.attempt) return Function.attempt(returns);
			return returns();
		};
	},

	bind: function(bind, args){

		/* https://github.com/google/recaptcha/issues/374 */
        if ( new Error().stack.match(/recaptcha/) )
        	return this._nativebind(bind, args);

		var self = this;
		if (args != null) args = Array.from(args);
		return function(){
			return self.apply(bind, args || arguments);
		};
	},

	bindWithEvent: function(bind, args){
		var self = this;
		if (args != null) args = Array.from(args);
		return function(event){
			return self.apply(bind, (args == null) ? arguments : [event].concat(args));
		};
	},

	run: function(args, bind){
		return this.apply(bind, Array.from(args));
	}

});

if (Object.create == Function.prototype.create) Object.create = null;

var $try = Function.attempt;

//</1.2compat>

/*
---

name: Number

description: Contains Number Prototypes like limit, round, times, and ceil.

license: MIT-style license.

requires: Type

provides: Number

...
*/

Number.implement({

	limit: function(min, max){
		return Math.min(max, Math.max(min, this));
	},

	round: function(precision){
		precision = Math.pow(10, precision || 0).toFixed(precision < 0 ? -precision : 0);
		return Math.round(this * precision) / precision;
	},

	times: function(fn, bind){
		for (var i = 0; i < this; i++) fn.call(bind, i, this);
	},

	toFloat: function(){
		return parseFloat(this);
	},

	toInt: function(base){
		return parseInt(this, base || 10);
	}

});

Number.alias('each', 'times');

(function(math){
	var methods = {};
	math.each(function(name){
		if (!Number[name]) methods[name] = function(){
			return Math[name].apply(null, [this].concat(Array.from(arguments)));
		};
	});
	Number.implement(methods);
})(['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor', 'log', 'max', 'min', 'pow', 'sin', 'sqrt', 'tan']);

/*
---

name: String

description: Contains String Prototypes like camelCase, capitalize, test, and toInt.

license: MIT-style license.

requires: [Type, Array]

provides: String

...
*/

String.implement({

	//<!ES6>
	contains: function(string, index){
		return (index ? String(this).slice(index) : String(this)).indexOf(string) > -1;
	},
	//</!ES6>

	test: function(regex, params){
		return ((typeOf(regex) == 'regexp') ? regex : new RegExp('' + regex, params)).test(this);
	},

	trim: function(){
		return String(this).replace(/^\s+|\s+$/g, '');
	},

	clean: function(){
		return String(this).replace(/\s+/g, ' ').trim();
	},

	camelCase: function(){
		return String(this).replace(/-\D/g, function(match){
			return match.charAt(1).toUpperCase();
		});
	},

	hyphenate: function(){
		return String(this).replace(/[A-Z]/g, function(match){
			return ('-' + match.charAt(0).toLowerCase());
		});
	},

	capitalize: function(){
		return String(this).replace(/\b[a-z]/g, function(match){
			return match.toUpperCase();
		});
	},

	escapeRegExp: function(){
		return String(this).replace(/([-.*+?^${}()|[\]\/\\])/g, '\\$1');
	},

	toInt: function(base){
		return parseInt(this, base || 10);
	},

	toFloat: function(){
		return parseFloat(this);
	},

	hexToRgb: function(array){
		var hex = String(this).match(/^#?(\w{1,2})(\w{1,2})(\w{1,2})$/);
		return (hex) ? hex.slice(1).hexToRgb(array) : null;
	},

	rgbToHex: function(array){
		var rgb = String(this).match(/\d{1,3}/g);
		return (rgb) ? rgb.rgbToHex(array) : null;
	},

	substitute: function(object, regexp){
		return String(this).replace(regexp || (/\\?\{([^{}]+)\}/g), function(match, name){
			if (match.charAt(0) == '\\') return match.slice(1);
			return (object[name] != null) ? object[name] : '';
		});
	}

});

//<1.4compat>
String.prototype.contains = function(string, separator){
	return (separator) ? (separator + this + separator).indexOf(separator + string + separator) > -1 : String(this).indexOf(string) > -1;
};
//</1.4compat>

/*
---

name: Browser

description: The Browser Object. Contains Browser initialization, Window and Document, and the Browser Hash.

license: MIT-style license.

requires: [Array, Function, Number, String]

provides: [Browser, Window, Document]

...
*/

(function(){

var document = this.document;
var window = document.window = this;

var parse = function(ua, platform){
	ua = ua.toLowerCase();
	platform = (platform ? platform.toLowerCase() : '');

	// chrome is included in the edge UA, so need to check for edge first,
	// before checking if it's chrome.
	var UA = ua.match(/(edge)[\s\/:]([\w\d\.]+)/);
	if (!UA){
		UA = ua.match(/(opera|ie|firefox|chrome|trident|crios|version)[\s\/:]([\w\d\.]+)?.*?(safari|(?:rv[\s\/:]|version[\s\/:])([\w\d\.]+)|$)/) || [null, 'unknown', 0];
	}

	if (UA[1] == 'trident'){
		UA[1] = 'ie';
		if (UA[4]) UA[2] = UA[4];
	} else if (UA[1] == 'crios'){
		UA[1] = 'chrome';
	}

	platform = ua.match(/ip(?:ad|od|hone)/) ? 'ios' : (ua.match(/(?:webos|android)/) || ua.match(/mac|win|linux/) || ['other'])[0];
	if (platform == 'win') platform = 'windows';

	return {
		extend: Function.prototype.extend,
		name: (UA[1] == 'version') ? UA[3] : UA[1],
		version: parseFloat((UA[1] == 'opera' && UA[4]) ? UA[4] : UA[2]),
		platform: platform
	};
};

var Browser = this.Browser = parse(navigator.userAgent, navigator.platform);

if (Browser.name == 'ie' && document.documentMode){
	Browser.version = document.documentMode;
}

Browser.extend({
	Features: {
		xpath: !!(document.evaluate),
		air: !!(window.runtime),
		query: !!(document.querySelector),
		json: !!(window.JSON)
	},
	parseUA: parse
});

//<1.4compat>
Browser[Browser.name] = true;
Browser[Browser.name + parseInt(Browser.version, 10)] = true;

if (Browser.name == 'ie' && Browser.version >= '11'){
	delete Browser.ie;
}

var platform = Browser.platform;
if (platform == 'windows'){
	platform = 'win';
}
Browser.Platform = {
	name: platform
};
Browser.Platform[platform] = true;
//</1.4compat>

// Request

Browser.Request = (function(){

	var XMLHTTP = function(){
		return new XMLHttpRequest();
	};

	var MSXML2 = function(){
		return new ActiveXObject('MSXML2.XMLHTTP');
	};

	var MSXML = function(){
		return new ActiveXObject('Microsoft.XMLHTTP');
	};

	return Function.attempt(function(){
		XMLHTTP();
		return XMLHTTP;
	}, function(){
		MSXML2();
		return MSXML2;
	}, function(){
		MSXML();
		return MSXML;
	});

})();

Browser.Features.xhr = !!(Browser.Request);

//<1.4compat>

// Flash detection

var version = (Function.attempt(function(){
	return navigator.plugins['Shockwave Flash'].description;
}, function(){
	return new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version');
}) || '0 r0').match(/\d+/g);

Browser.Plugins = {
	Flash: {
		version: Number(version[0] || '0.' + version[1]) || 0,
		build: Number(version[2]) || 0
	}
};

//</1.4compat>

// String scripts

Browser.exec = function(text){
	if (!text) return text;
	if (window.execScript){
		window.execScript(text);
	} else {
		var script = document.createElement('script');
		script.setAttribute('type', 'text/javascript');
		script.text = text;
		document.head.appendChild(script);
		document.head.removeChild(script);
	}
	return text;
};

String.implement('stripScripts', function(exec){
	var scripts = '';
	var text = this.replace(/<script[^>]*>([\s\S]*?)<\/script>/gi, function(all, code){
		scripts += code + '\n';
		return '';
	});
	if (exec === true) Browser.exec(scripts);
	else if (typeOf(exec) == 'function') exec(scripts, text);
	return text;
});

// Window, Document

Browser.extend({
	Document: this.Document,
	Window: this.Window,
	Element: this.Element,
	Event: this.Event
});

this.Window = this.$constructor = new Type('Window', function(){});

this.$family = Function.from('window').hide();

Window.mirror(function(name, method){
	window[name] = method;
});

this.Document = document.$constructor = new Type('Document', function(){});

document.$family = Function.from('document').hide();

Document.mirror(function(name, method){
	document[name] = method;
});

document.html = document.documentElement;
if (!document.head) document.head = document.getElementsByTagName('head')[0];

if (document.execCommand) try {
	document.execCommand("BackgroundImageCache", false, true);
} catch (e){}

/*<ltIE9>*/
if (this.attachEvent && !this.addEventListener){
	var unloadEvent = function(){
		this.detachEvent('onunload', unloadEvent);
		document.head = document.html = document.window = null;
		window = this.Window = document = null;
	};
	this.attachEvent('onunload', unloadEvent);
}

// IE fails on collections and <select>.options (refers to <select>)
var arrayFrom = Array.from;
try {
	arrayFrom(document.html.childNodes);
} catch(e){
	Array.from = function(item){
		if (typeof item != 'string' && Type.isEnumerable(item) && typeOf(item) != 'array'){
			var i = item.length, array = new Array(i);
			while (i--) array[i] = item[i];
			return array;
		}
		return arrayFrom(item);
	};

	var prototype = Array.prototype,
		slice = prototype.slice;
	['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift', 'concat', 'join', 'slice'].each(function(name){
		var method = prototype[name];
		Array[name] = function(item){
			return method.apply(Array.from(item), slice.call(arguments, 1));
		};
	});
}
/*</ltIE9>*/

//<1.2compat>

if (Browser.Platform.ios) Browser.Platform.ipod = true;

Browser.Engine = {};

var setEngine = function(name, version){
	Browser.Engine.name = name;
	Browser.Engine[name + version] = true;
	Browser.Engine.version = version;
};

if (Browser.ie){
	Browser.Engine.trident = true;

	switch (Browser.version){
		case 6: setEngine('trident', 4); break;
		case 7: setEngine('trident', 5); break;
		case 8: setEngine('trident', 6);
	}
}

if (Browser.firefox){
	Browser.Engine.gecko = true;

	if (Browser.version >= 3) setEngine('gecko', 19);
	else setEngine('gecko', 18);
}

if (Browser.safari || Browser.chrome){
	Browser.Engine.webkit = true;

	switch (Browser.version){
		case 2: setEngine('webkit', 419); break;
		case 3: setEngine('webkit', 420); break;
		case 4: setEngine('webkit', 525);
	}
}

if (Browser.opera){
	Browser.Engine.presto = true;

	if (Browser.version >= 9.6) setEngine('presto', 960);
	else if (Browser.version >= 9.5) setEngine('presto', 950);
	else setEngine('presto', 925);
}

if (Browser.name == 'unknown'){
	switch ((navigator.userAgent.toLowerCase().match(/(?:webkit|khtml|gecko)/) || [])[0]){
		case 'webkit':
		case 'khtml':
			Browser.Engine.webkit = true;
		break;
		case 'gecko':
			Browser.Engine.gecko = true;
	}
}

this.$exec = Browser.exec;

//</1.2compat>

})();

/*
---

name: Class

description: Contains the Class Function for easily creating, extending, and implementing reusable Classes.

license: MIT-style license.

requires: [Array, String, Function, Number]

provides: Class

...
*/

(function(){

var Class = this.Class = new Type('Class', function(params){
	if (instanceOf(params, Function)) params = {initialize: params};

	var newClass = function(){
		reset(this);
		if (newClass.$prototyping) return this;
		this.$caller = null;
		this.$family = null;
		var value = (this.initialize) ? this.initialize.apply(this, arguments) : this;
		this.$caller = this.caller = null;
		return value;
	}.extend(this).implement(params);

	newClass.$constructor = Class;
	newClass.prototype.$constructor = newClass;
	newClass.prototype.parent = parent;

	return newClass;
});

var parent = function(){
	if (!this.$caller) throw new Error('The method "parent" cannot be called.');
	var name = this.$caller.$name,
		parent = this.$caller.$owner.parent,
		previous = (parent) ? parent.prototype[name] : null;
	if (!previous) throw new Error('The method "' + name + '" has no parent.');
	return previous.apply(this, arguments);
};

var reset = function(object){
	for (var key in object){
		var value = object[key];
		switch (typeOf(value)){
			case 'object':
				var F = function(){};
				F.prototype = value;
				object[key] = reset(new F);
			break;
			case 'array': object[key] = value.clone(); break;
		}
	}
	return object;
};

var wrap = function(self, key, method){
	if (method.$origin) method = method.$origin;
	var wrapper = function(){
		if (method.$protected && this.$caller == null) throw new Error('The method "' + key + '" cannot be called.');
		var caller = this.caller, current = this.$caller;
		this.caller = current; this.$caller = wrapper;
		var result = method.apply(this, arguments);
		this.$caller = current; this.caller = caller;
		return result;
	}.extend({$owner: self, $origin: method, $name: key});
	return wrapper;
};

var implement = function(key, value, retain){
	if (Class.Mutators.hasOwnProperty(key)){
		value = Class.Mutators[key].call(this, value);
		if (value == null) return this;
	}

	if (typeOf(value) == 'function'){
		if (value.$hidden) return this;
		this.prototype[key] = (retain) ? value : wrap(this, key, value);
	} else {
		Object.merge(this.prototype, key, value);
	}

	return this;
};

var getInstance = function(klass){
	klass.$prototyping = true;
	var proto = new klass;
	delete klass.$prototyping;
	return proto;
};

Class.implement('implement', implement.overloadSetter());

Class.Mutators = {

	Extends: function(parent){
		this.parent = parent;
		this.prototype = getInstance(parent);
	},

	Implements: function(items){
		Array.from(items).each(function(item){
			var instance = new item;
			for (var key in instance) implement.call(this, key, instance[key], true);
		}, this);
	}
};

})();

/*
---

name: Class.Extras

description: Contains Utility Classes that can be implemented into your own Classes to ease the execution of many common tasks.

license: MIT-style license.

requires: Class

provides: [Class.Extras, Chain, Events, Options]

...
*/

(function(){

this.Chain = new Class({

	$chain: [],

	chain: function(){
		this.$chain.append(Array.flatten(arguments));
		return this;
	},

	callChain: function(){
		return (this.$chain.length) ? this.$chain.shift().apply(this, arguments) : false;
	},

	clearChain: function(){
		this.$chain.empty();
		return this;
	}

});

var removeOn = function(string){
	return string.replace(/^on([A-Z])/, function(full, first){
		return first.toLowerCase();
	});
};

this.Events = new Class({

	$events: {},

	addEvent: function(type, fn, internal){
		type = removeOn(type);

		/*<1.2compat>*/
		if (fn == $empty) return this;
		/*</1.2compat>*/

		this.$events[type] = (this.$events[type] || []).include(fn);
		if (internal) fn.internal = true;
		return this;
	},

	addEvents: function(events){
		for (var type in events) this.addEvent(type, events[type]);
		return this;
	},

	fireEvent: function(type, args, delay){
		type = removeOn(type);
		var events = this.$events[type];
		if (!events) return this;
		args = Array.from(args);
		events.each(function(fn){
			if (delay) fn.delay(delay, this, args);
			else fn.apply(this, args);
		}, this);
		return this;
	},

	removeEvent: function(type, fn){
		type = removeOn(type);
		var events = this.$events[type];
		if (events && !fn.internal){
			var index = events.indexOf(fn);
			if (index != -1) delete events[index];
		}
		return this;
	},

	removeEvents: function(events){
		var type;
		if (typeOf(events) == 'object'){
			for (type in events) this.removeEvent(type, events[type]);
			return this;
		}
		if (events) events = removeOn(events);
		for (type in this.$events){
			if (events && events != type) continue;
			var fns = this.$events[type];
			for (var i = fns.length; i--;) if (i in fns){
				this.removeEvent(type, fns[i]);
			}
		}
		return this;
	}

});

this.Options = new Class({

	setOptions: function(){
		var options = this.options = Object.merge.apply(null, [{}, this.options].append(arguments));
		if (this.addEvent) for (var option in options){
			if (typeOf(options[option]) != 'function' || !(/^on[A-Z]/).test(option)) continue;
			this.addEvent(option, options[option]);
			delete options[option];
		}
		return this;
	}

});

})();

/*
---

name: Object

description: Object generic methods

license: MIT-style license.

requires: Type

provides: [Object, Hash]

...
*/

(function(){

var hasOwnProperty = Object.prototype.hasOwnProperty;

Object.extend({

	subset: function(object, keys){
		var results = {};
		for (var i = 0, l = keys.length; i < l; i++){
			var k = keys[i];
			if (k in object) results[k] = object[k];
		}
		return results;
	},

	map: function(object, fn, bind){
		var results = {};
		var keys = Object.keys(object);
		for (var i = 0; i < keys.length; i++){
			var key = keys[i];
			results[key] = fn.call(bind, object[key], key, object);
		}
		return results;
	},

	filter: function(object, fn, bind){
		var results = {};
		var keys = Object.keys(object);
		for (var i = 0; i < keys.length; i++){
			var key = keys[i], value = object[key];
			if (fn.call(bind, value, key, object)) results[key] = value;
		}
		return results;
	},

	every: function(object, fn, bind){
		var keys = Object.keys(object);
		for (var i = 0; i < keys.length; i++){
			var key = keys[i];
			if (!fn.call(bind, object[key], key)) return false;
		}
		return true;
	},

	some: function(object, fn, bind){
		var keys = Object.keys(object);
		for (var i = 0; i < keys.length; i++){
			var key = keys[i];
			if (fn.call(bind, object[key], key)) return true;
		}
		return false;
	},

	values: function(object){
		var values = [];
		var keys = Object.keys(object);
		for (var i = 0; i < keys.length; i++){
			var k = keys[i];
			values.push(object[k]);
		}
		return values;
	},

	getLength: function(object){
		return Object.keys(object).length;
	},

	keyOf: function(object, value){
		var keys = Object.keys(object);
		for (var i = 0; i < keys.length; i++){
			var key = keys[i];
			if (object[key] === value) return key;
		}
		return null;
	},

	contains: function(object, value){
		return Object.keyOf(object, value) != null;
	},

	toQueryString: function(object, base){
		var queryString = [];

		Object.each(object, function(value, key){
			if (base) key = base + '[' + key + ']';
			var result;
			switch (typeOf(value)){
				case 'object': result = Object.toQueryString(value, key); break;
				case 'array':
					var qs = {};
					value.each(function(val, i){
						qs[i] = val;
					});
					result = Object.toQueryString(qs, key);
				break;
				default: result = key + '=' + encodeURIComponent(value);
			}
			if (value != null) queryString.push(result);
		});

		return queryString.join('&');
	}

});

})();

//<1.2compat>

Hash.implement({

	has: Object.prototype.hasOwnProperty,

	keyOf: function(value){
		return Object.keyOf(this, value);
	},

	hasValue: function(value){
		return Object.contains(this, value);
	},

	extend: function(properties){
		Hash.each(properties || {}, function(value, key){
			Hash.set(this, key, value);
		}, this);
		return this;
	},

	combine: function(properties){
		Hash.each(properties || {}, function(value, key){
			Hash.include(this, key, value);
		}, this);
		return this;
	},

	erase: function(key){
		if (this.hasOwnProperty(key)) delete this[key];
		return this;
	},

	get: function(key){
		return (this.hasOwnProperty(key)) ? this[key] : null;
	},

	set: function(key, value){
		if (!this[key] || this.hasOwnProperty(key)) this[key] = value;
		return this;
	},

	empty: function(){
		Hash.each(this, function(value, key){
			delete this[key];
		}, this);
		return this;
	},

	include: function(key, value){
		if (this[key] == null) this[key] = value;
		return this;
	},

	map: function(fn, bind){
		return new Hash(Object.map(this, fn, bind));
	},

	filter: function(fn, bind){
		return new Hash(Object.filter(this, fn, bind));
	},

	every: function(fn, bind){
		return Object.every(this, fn, bind);
	},

	some: function(fn, bind){
		return Object.some(this, fn, bind);
	},

	getKeys: function(){
		return Object.keys(this);
	},

	getValues: function(){
		return Object.values(this);
	},

	toQueryString: function(base){
		return Object.toQueryString(this, base);
	}

});

Hash.extend = Object.append;

Hash.alias({indexOf: 'keyOf', contains: 'hasValue'});

//</1.2compat>

/*
---
name: Slick.Parser
description: Standalone CSS3 Selector parser
provides: Slick.Parser
...
*/

;(function(){

var parsed,
	separatorIndex,
	combinatorIndex,
	reversed,
	cache = {},
	reverseCache = {},
	reUnescape = /\\/g;

var parse = function(expression, isReversed){
	if (expression == null) return null;
	if (expression.Slick === true) return expression;
	expression = ('' + expression).replace(/^\s+|\s+$/g, '');
	reversed = !!isReversed;
	var currentCache = (reversed) ? reverseCache : cache;
	if (currentCache[expression]) return currentCache[expression];
	parsed = {
		Slick: true,
		expressions: [],
		raw: expression,
		reverse: function(){
			return parse(this.raw, true);
		}
	};
	separatorIndex = -1;
	while (expression != (expression = expression.replace(regexp, parser)));
	parsed.length = parsed.expressions.length;
	return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;
};

var reverseCombinator = function(combinator){
	if (combinator === '!') return ' ';
	else if (combinator === ' ') return '!';
	else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');
	else return '!' + combinator;
};

var reverse = function(expression){
	var expressions = expression.expressions;
	for (var i = 0; i < expressions.length; i++){
		var exp = expressions[i];
		var last = {parts: [], tag: '*', combinator: reverseCombinator(exp[0].combinator)};

		for (var j = 0; j < exp.length; j++){
			var cexp = exp[j];
			if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';
			cexp.combinator = cexp.reverseCombinator;
			delete cexp.reverseCombinator;
		}

		exp.reverse().push(last);
	}
	return expression;
};

var escapeRegExp = function(string){// Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License
	return string.replace(/[-[\]{}()*+?.\\^$|,#\s]/g, function(match){
		return '\\' + match;
	});
};

var regexp = new RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
	"(?x)^(?:\
	  \\s* ( , ) \\s*               # Separator          \n\
	| \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
	|      ( \\s+ )                 # CombinatorChildren \n\
	|      ( <unicode>+ | \\* )     # Tag                \n\
	| \\#  ( <unicode>+       )     # ID                 \n\
	| \\.  ( <unicode>+       )     # ClassName          \n\
	|                               # Attribute          \n\
	\\[  \
		\\s* (<unicode1>+)  (?:  \
			\\s* ([*^$!~|]?=)  (?:  \
				\\s* (?:\
					([\"']?)(.*?)\\9 \
				)\
			)  \
		)?  \\s*  \
	\\](?!\\]) \n\
	|   :+ ( <unicode>+ )(?:\
	\\( (?:\
		(?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
	) \\)\
	)?\
	)"
*/
	"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
	.replace(/<combinator>/, '[' + escapeRegExp(">+~`!@$%^&={}\\;</") + ']')
	.replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
	.replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
);

function parser(
	rawMatch,

	separator,
	combinator,
	combinatorChildren,

	tagName,
	id,
	className,

	attributeKey,
	attributeOperator,
	attributeQuote,
	attributeValue,

	pseudoMarker,
	pseudoClass,
	pseudoQuote,
	pseudoClassQuotedValue,
	pseudoClassValue
){
	if (separator || separatorIndex === -1){
		parsed.expressions[++separatorIndex] = [];
		combinatorIndex = -1;
		if (separator) return '';
	}

	if (combinator || combinatorChildren || combinatorIndex === -1){
		combinator = combinator || ' ';
		var currentSeparator = parsed.expressions[separatorIndex];
		if (reversed && currentSeparator[combinatorIndex])
			currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);
		currentSeparator[++combinatorIndex] = {combinator: combinator, tag: '*'};
	}

	var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];

	if (tagName){
		currentParsed.tag = tagName.replace(reUnescape, '');

	} else if (id){
		currentParsed.id = id.replace(reUnescape, '');

	} else if (className){
		className = className.replace(reUnescape, '');

		if (!currentParsed.classList) currentParsed.classList = [];
		if (!currentParsed.classes) currentParsed.classes = [];
		currentParsed.classList.push(className);
		currentParsed.classes.push({
			value: className,
			regexp: new RegExp('(^|\\s)' + escapeRegExp(className) + '(\\s|$)')
		});

	} else if (pseudoClass){
		pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;
		pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;

		if (!currentParsed.pseudos) currentParsed.pseudos = [];
		currentParsed.pseudos.push({
			key: pseudoClass.replace(reUnescape, ''),
			value: pseudoClassValue,
			type: pseudoMarker.length == 1 ? 'class' : 'element'
		});

	} else if (attributeKey){
		attributeKey = attributeKey.replace(reUnescape, '');
		attributeValue = (attributeValue || '').replace(reUnescape, '');

		var test, regexp;

		switch (attributeOperator){
			case '^=' : regexp = new RegExp(       '^'+ escapeRegExp(attributeValue)            ); break;
			case '$=' : regexp = new RegExp(            escapeRegExp(attributeValue) +'$'       ); break;
			case '~=' : regexp = new RegExp( '(^|\\s)'+ escapeRegExp(attributeValue) +'(\\s|$)' ); break;
			case '|=' : regexp = new RegExp(       '^'+ escapeRegExp(attributeValue) +'(-|$)'   ); break;
			case  '=' : test = function(value){
				return attributeValue == value;
			}; break;
			case '*=' : test = function(value){
				return value && value.indexOf(attributeValue) > -1;
			}; break;
			case '!=' : test = function(value){
				return attributeValue != value;
			}; break;
			default   : test = function(value){
				return !!value;
			};
		}

		if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function(){
			return false;
		};

		if (!test) test = function(value){
			return value && regexp.test(value);
		};

		if (!currentParsed.attributes) currentParsed.attributes = [];
		currentParsed.attributes.push({
			key: attributeKey,
			operator: attributeOperator,
			value: attributeValue,
			test: test
		});

	}

	return '';
};

// Slick NS

var Slick = (this.Slick || {});

Slick.parse = function(expression){
	return parse(expression);
};

Slick.escapeRegExp = escapeRegExp;

if (!this.Slick) this.Slick = Slick;

}).apply(/*<CommonJS>*/(typeof exports != 'undefined') ? exports : /*</CommonJS>*/this);

/*
---
name: Slick.Finder
description: The new, superfast css selector engine.
provides: Slick.Finder
requires: Slick.Parser
...
*/

;(function(){

var local = {},
	featuresCache = {},
	toString = Object.prototype.toString;

// Feature / Bug detection

local.isNativeCode = function(fn){
	return (/\{\s*\[native code\]\s*\}/).test('' + fn);
};

local.isXML = function(document){
	return (!!document.xmlVersion) || (!!document.xml) || (toString.call(document) == '[object XMLDocument]') ||
	(document.nodeType == 9 && document.documentElement.nodeName != 'HTML');
};

local.setDocument = function(document){

	// convert elements / window arguments to document. if document cannot be extrapolated, the function returns.
	var nodeType = document.nodeType;
	if (nodeType == 9); // document
	else if (nodeType) document = document.ownerDocument; // node
	else if (document.navigator) document = document.document; // window
	else return;

	// check if it's the old document

	if (this.document === document) return;
	this.document = document;

	// check if we have done feature detection on this document before

	var root = document.documentElement,
		rootUid = this.getUIDXML(root),
		features = featuresCache[rootUid],
		feature;

	if (features){
		for (feature in features){
			this[feature] = features[feature];
		}
		return;
	}

	features = featuresCache[rootUid] = {};

	features.root = root;
	features.isXMLDocument = this.isXML(document);

	features.brokenStarGEBTN
	= features.starSelectsClosedQSA
	= features.idGetsName
	= features.brokenMixedCaseQSA
	= features.brokenGEBCN
	= features.brokenCheckedQSA
	= features.brokenEmptyAttributeQSA
	= features.isHTMLDocument
	= features.nativeMatchesSelector
	= false;

	var starSelectsClosed, starSelectsComments,
		brokenSecondClassNameGEBCN, cachedGetElementsByClassName,
		brokenFormAttributeGetter;

	var selected, id = 'slick_uniqueid';
	var testNode = document.createElement('div');

	var testRoot = document.body || document.getElementsByTagName('body')[0] || root;
	testRoot.appendChild(testNode);

	// on non-HTML documents innerHTML and getElementsById doesnt work properly
	try {
		testNode.innerHTML = '<a id="'+id+'"></a>';
		features.isHTMLDocument = !!document.getElementById(id);
	} catch(e){}

	if (features.isHTMLDocument){

		testNode.style.display = 'none';

		// IE returns comment nodes for getElementsByTagName('*') for some documents
		testNode.appendChild(document.createComment(''));
		starSelectsComments = (testNode.getElementsByTagName('*').length > 1);

		// IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
		try {
			testNode.innerHTML = 'foo</foo>';
			selected = testNode.getElementsByTagName('*');
			starSelectsClosed = (selected && !!selected.length && selected[0].nodeName.charAt(0) == '/');
		} catch(e){};

		features.brokenStarGEBTN = starSelectsComments || starSelectsClosed;

		// IE returns elements with the name instead of just id for getElementsById for some documents
		try {
			testNode.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>';
			features.idGetsName = document.getElementById(id) === testNode.firstChild;
		} catch(e){}

		if (testNode.getElementsByClassName){

			// Safari 3.2 getElementsByClassName caches results
			try {
				testNode.innerHTML = '<a class="f"></a><a class="b"></a>';
				testNode.getElementsByClassName('b').length;
				testNode.firstChild.className = 'b';
				cachedGetElementsByClassName = (testNode.getElementsByClassName('b').length != 2);
			} catch(e){};

			// Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
			try {
				testNode.innerHTML = '<a class="a"></a><a class="f b a"></a>';
				brokenSecondClassNameGEBCN = (testNode.getElementsByClassName('a').length != 2);
			} catch(e){}

			features.brokenGEBCN = cachedGetElementsByClassName || brokenSecondClassNameGEBCN;
		}

		if (testNode.querySelectorAll){
			// IE 8 returns closed nodes (EG:"</foo>") for querySelectorAll('*') for some documents
			try {
				testNode.innerHTML = 'foo</foo>';
				selected = testNode.querySelectorAll('*');
				features.starSelectsClosedQSA = (selected && !!selected.length && selected[0].nodeName.charAt(0) == '/');
			} catch(e){}

			// Safari 3.2 querySelectorAll doesnt work with mixedcase on quirksmode
			try {
				testNode.innerHTML = '<a class="MiX"></a>';
				features.brokenMixedCaseQSA = !testNode.querySelectorAll('.MiX').length;
			} catch(e){}

			// Webkit and Opera dont return selected options on querySelectorAll
			try {
				testNode.innerHTML = '<select><option selected="selected">a</option></select>';
				features.brokenCheckedQSA = (testNode.querySelectorAll(':checked').length == 0);
			} catch(e){};

			// IE returns incorrect results for attr[*^$]="" selectors on querySelectorAll
			try {
				testNode.innerHTML = '<a class=""></a>';
				features.brokenEmptyAttributeQSA = (testNode.querySelectorAll('[class*=""]').length != 0);
			} catch(e){}

		}

		// IE6-7, if a form has an input of id x, form.getAttribute(x) returns a reference to the input
		try {
			testNode.innerHTML = '<form action="s"><input id="action"/></form>';
			brokenFormAttributeGetter = (testNode.firstChild.getAttribute('action') != 's');
		} catch(e){}

		// native matchesSelector function

		features.nativeMatchesSelector = root.matches || /*root.msMatchesSelector ||*/ root.mozMatchesSelector || root.webkitMatchesSelector;
		if (features.nativeMatchesSelector) try {
			// if matchesSelector trows errors on incorrect sintaxes we can use it
			features.nativeMatchesSelector.call(root, ':slick');
			features.nativeMatchesSelector = null;
		} catch(e){}

	}

	try {
		root.slick_expando = 1;
		delete root.slick_expando;
		features.getUID = this.getUIDHTML;
	} catch(e){
		features.getUID = this.getUIDXML;
	}

	testRoot.removeChild(testNode);
	testNode = selected = testRoot = null;

	// getAttribute

	features.getAttribute = (features.isHTMLDocument && brokenFormAttributeGetter) ? function(node, name){
		var method = this.attributeGetters[name];
		if (method) return method.call(node);
		var attributeNode = node.getAttributeNode(name);
		return (attributeNode) ? attributeNode.nodeValue : null;
	} : function(node, name){
		var method = this.attributeGetters[name];
		return (method) ? method.call(node) : node.getAttribute(name);
	};

	// hasAttribute

	features.hasAttribute = (root && this.isNativeCode(root.hasAttribute)) ? function(node, attribute){
		return node.hasAttribute(attribute);
	} : function(node, attribute){
		node = node.getAttributeNode(attribute);
		return !!(node && (node.specified || node.nodeValue));
	};

	// contains
	// FIXME: Add specs: local.contains should be different for xml and html documents?
	var nativeRootContains = root && this.isNativeCode(root.contains),
		nativeDocumentContains = document && this.isNativeCode(document.contains);

	features.contains = (nativeRootContains && nativeDocumentContains) ? function(context, node){
		return context.contains(node);
	} : (nativeRootContains && !nativeDocumentContains) ? function(context, node){
		// IE8 does not have .contains on document.
		return context === node || ((context === document) ? document.documentElement : context).contains(node);
	} : (root && root.compareDocumentPosition) ? function(context, node){
		return context === node || !!(context.compareDocumentPosition(node) & 16);
	} : function(context, node){
		if (node) do {
			if (node === context) return true;
		} while ((node = node.parentNode));
		return false;
	};

	// document order sorting
	// credits to Sizzle (http://sizzlejs.com/)

	features.documentSorter = (root.compareDocumentPosition) ? function(a, b){
		if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0;
		return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1;
	} : ('sourceIndex' in root) ? function(a, b){
		if (!a.sourceIndex || !b.sourceIndex) return 0;
		return a.sourceIndex - b.sourceIndex;
	} : (document.createRange) ? function(a, b){
		if (!a.ownerDocument || !b.ownerDocument) return 0;
		var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange();
		aRange.setStart(a, 0);
		aRange.setEnd(a, 0);
		bRange.setStart(b, 0);
		bRange.setEnd(b, 0);
		return aRange.compareBoundaryPoints(Range.START_TO_END, bRange);
	} : null ;

	root = null;

	for (feature in features){
		this[feature] = features[feature];
	}
};

// Main Method

var reSimpleSelector = /^([#.]?)((?:[\w-]+|\*))$/,
	reEmptyAttribute = /\[.+[*$^]=(?:""|'')?\]/,
	qsaFailExpCache = {};

local.search = function(context, expression, append, first){

	var found = this.found = (first) ? null : (append || []);

	if (!context) return found;
	else if (context.navigator) context = context.document; // Convert the node from a window to a document
	else if (!context.nodeType) return found;

	// setup

	var parsed, i,
		uniques = this.uniques = {},
		hasOthers = !!(append && append.length),
		contextIsDocument = (context.nodeType == 9);

	if (this.document !== (contextIsDocument ? context : context.ownerDocument)) this.setDocument(context);

	// avoid duplicating items already in the append array
	if (hasOthers) for (i = found.length; i--;) uniques[this.getUID(found[i])] = true;

	// expression checks

	if (typeof expression == 'string'){ // expression is a string

		/*<simple-selectors-override>*/
		var simpleSelector = expression.match(reSimpleSelector);
		simpleSelectors: if (simpleSelector){

			var symbol = simpleSelector[1],
				name = simpleSelector[2],
				node, nodes;

			if (!symbol){

				if (name == '*' && this.brokenStarGEBTN) break simpleSelectors;
				nodes = context.getElementsByTagName(name);
				if (first) return nodes[0] || null;
				for (i = 0; node = nodes[i++];){
					if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);
				}

			} else if (symbol == '#'){

				if (!this.isHTMLDocument || !contextIsDocument) break simpleSelectors;
				node = context.getElementById(name);
				if (!node) return found;
				if (this.idGetsName && node.getAttributeNode('id').nodeValue != name) break simpleSelectors;
				if (first) return node || null;
				if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);

			} else if (symbol == '.'){

				if (!this.isHTMLDocument || ((!context.getElementsByClassName || this.brokenGEBCN) && context.querySelectorAll)) break simpleSelectors;
				if (context.getElementsByClassName && !this.brokenGEBCN){
					nodes = context.getElementsByClassName(name);
					if (first) return nodes[0] || null;
					for (i = 0; node = nodes[i++];){
						if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);
					}
				} else {
					var matchClass = new RegExp('(^|\\s)'+ Slick.escapeRegExp(name) +'(\\s|$)');
					nodes = context.getElementsByTagName('*');
					for (i = 0; node = nodes[i++];){
						className = node.className;
						if (!(className && matchClass.test(className))) continue;
						if (first) return node;
						if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);
					}
				}

			}

			if (hasOthers) this.sort(found);
			return (first) ? null : found;

		}
		/*</simple-selectors-override>*/

		/*<query-selector-override>*/
		querySelector: if (context.querySelectorAll){

			if (!this.isHTMLDocument
				|| qsaFailExpCache[expression]
				//TODO: only skip when expression is actually mixed case
				|| this.brokenMixedCaseQSA
				|| (this.brokenCheckedQSA && expression.indexOf(':checked') > -1)
				|| (this.brokenEmptyAttributeQSA && reEmptyAttribute.test(expression))
				|| (!contextIsDocument //Abort when !contextIsDocument and...
					//  there are multiple expressions in the selector
					//  since we currently only fix non-document rooted QSA for single expression selectors
					&& expression.indexOf(',') > -1
				)
				|| Slick.disableQSA
			) break querySelector;

			var _expression = expression, _context = context;
			if (!contextIsDocument){
				// non-document rooted QSA
				// credits to Andrew Dupont
				var currentId = _context.getAttribute('id'), slickid = 'slickid__';
				_context.setAttribute('id', slickid);
				_expression = '#' + slickid + ' ' + _expression;
				context = _context.parentNode;
			}

			try {
				if (first) return context.querySelector(_expression) || null;
				else nodes = context.querySelectorAll(_expression);
			} catch(e){
				qsaFailExpCache[expression] = 1;
				break querySelector;
			} finally {
				if (!contextIsDocument){
					if (currentId) _context.setAttribute('id', currentId);
					else _context.removeAttribute('id');
					context = _context;
				}
			}

			if (this.starSelectsClosedQSA) for (i = 0; node = nodes[i++];){
				if (node.nodeName > '@' && !(hasOthers && uniques[this.getUID(node)])) found.push(node);
			} else for (i = 0; node = nodes[i++];){
				if (!(hasOthers && uniques[this.getUID(node)])) found.push(node);
			}

			if (hasOthers) this.sort(found);
			return found;

		}
		/*</query-selector-override>*/

		parsed = this.Slick.parse(expression);
		if (!parsed.length) return found;
	} else if (expression == null){ // there is no expression
		return found;
	} else if (expression.Slick){ // expression is a parsed Slick object
		parsed = expression;
	} else if (this.contains(context.documentElement || context, expression)){ // expression is a node
		(found) ? found.push(expression) : found = expression;
		return found;
	} else { // other junk
		return found;
	}

	/*<pseudo-selectors>*//*<nth-pseudo-selectors>*/

	// cache elements for the nth selectors

	this.posNTH = {};
	this.posNTHLast = {};
	this.posNTHType = {};
	this.posNTHTypeLast = {};

	/*</nth-pseudo-selectors>*//*</pseudo-selectors>*/

	// if append is null and there is only a single selector with one expression use pushArray, else use pushUID
	this.push = (!hasOthers && (first || (parsed.length == 1 && parsed.expressions[0].length == 1))) ? this.pushArray : this.pushUID;

	if (found == null) found = [];

	// default engine

	var j, m, n;
	var combinator, tag, id, classList, classes, attributes, pseudos;
	var currentItems, currentExpression, currentBit, lastBit, expressions = parsed.expressions;

	search: for (i = 0; (currentExpression = expressions[i]); i++) for (j = 0; (currentBit = currentExpression[j]); j++){

		combinator = 'combinator:' + currentBit.combinator;
		if (!this[combinator]) continue search;

		tag        = (this.isXMLDocument) ? currentBit.tag : currentBit.tag.toUpperCase();
		id         = currentBit.id;
		classList  = currentBit.classList;
		classes    = currentBit.classes;
		attributes = currentBit.attributes;
		pseudos    = currentBit.pseudos;
		lastBit    = (j === (currentExpression.length - 1));

		this.bitUniques = {};

		if (lastBit){
			this.uniques = uniques;
			this.found = found;
		} else {
			this.uniques = {};
			this.found = [];
		}

		if (j === 0){
			this[combinator](context, tag, id, classes, attributes, pseudos, classList);
			if (first && lastBit && found.length) break search;
		} else {
			if (first && lastBit) for (m = 0, n = currentItems.length; m < n; m++){
				this[combinator](currentItems[m], tag, id, classes, attributes, pseudos, classList);
				if (found.length) break search;
			} else for (m = 0, n = currentItems.length; m < n; m++) this[combinator](currentItems[m], tag, id, classes, attributes, pseudos, classList);
		}

		currentItems = this.found;
	}

	// should sort if there are nodes in append and if you pass multiple expressions.
	if (hasOthers || (parsed.expressions.length > 1)) this.sort(found);

	return (first) ? (found[0] || null) : found;
};

// Utils

local.uidx = 1;
local.uidk = 'slick-uniqueid';

local.getUIDXML = function(node){
	var uid = node.getAttribute(this.uidk);
	if (!uid){
		uid = this.uidx++;
		node.setAttribute(this.uidk, uid);
	}
	return uid;
};

local.getUIDHTML = function(node){
	return node.uniqueNumber || (node.uniqueNumber = this.uidx++);
};

// sort based on the setDocument documentSorter method.

local.sort = function(results){
	if (!this.documentSorter) return results;
	results.sort(this.documentSorter);
	return results;
};

/*<pseudo-selectors>*//*<nth-pseudo-selectors>*/

local.cacheNTH = {};

local.matchNTH = /^([+-]?\d*)?([a-z]+)?([+-]\d+)?$/;

local.parseNTHArgument = function(argument){
	var parsed = argument.match(this.matchNTH);
	if (!parsed) return false;
	var special = parsed[2] || false;
	var a = parsed[1] || 1;
	if (a == '-') a = -1;
	var b = +parsed[3] || 0;
	parsed =
		(special == 'n')	? {a: a, b: b} :
		(special == 'odd')	? {a: 2, b: 1} :
		(special == 'even')	? {a: 2, b: 0} : {a: 0, b: a};

	return (this.cacheNTH[argument] = parsed);
};

local.createNTHPseudo = function(child, sibling, positions, ofType){
	return function(node, argument){
		var uid = this.getUID(node);
		if (!this[positions][uid]){
			var parent = node.parentNode;
			if (!parent) return false;
			var el = parent[child], count = 1;
			if (ofType){
				var nodeName = node.nodeName;
				do {
					if (el.nodeName != nodeName) continue;
					this[positions][this.getUID(el)] = count++;
				} while ((el = el[sibling]));
			} else {
				do {
					if (el.nodeType != 1) continue;
					this[positions][this.getUID(el)] = count++;
				} while ((el = el[sibling]));
			}
		}
		argument = argument || 'n';
		var parsed = this.cacheNTH[argument] || this.parseNTHArgument(argument);
		if (!parsed) return false;
		var a = parsed.a, b = parsed.b, pos = this[positions][uid];
		if (a == 0) return b == pos;
		if (a > 0){
			if (pos < b) return false;
		} else {
			if (b < pos) return false;
		}
		return ((pos - b) % a) == 0;
	};
};

/*</nth-pseudo-selectors>*//*</pseudo-selectors>*/

local.pushArray = function(node, tag, id, classes, attributes, pseudos){
	if (this.matchSelector(node, tag, id, classes, attributes, pseudos)) this.found.push(node);
};

local.pushUID = function(node, tag, id, classes, attributes, pseudos){
	var uid = this.getUID(node);
	if (!this.uniques[uid] && this.matchSelector(node, tag, id, classes, attributes, pseudos)){
		this.uniques[uid] = true;
		this.found.push(node);
	}
};

local.matchNode = function(node, selector){
	if (this.isHTMLDocument && this.nativeMatchesSelector){
		try {
			return this.nativeMatchesSelector.call(node, selector.replace(/\[([^=]+)=\s*([^'"\]]+?)\s*\]/g, '[$1="$2"]'));
		} catch(matchError){}
	}

	var parsed = this.Slick.parse(selector);
	if (!parsed) return true;

	// simple (single) selectors
	var expressions = parsed.expressions, simpleExpCounter = 0, i, currentExpression;
	for (i = 0; (currentExpression = expressions[i]); i++){
		if (currentExpression.length == 1){
			var exp = currentExpression[0];
			if (this.matchSelector(node, (this.isXMLDocument) ? exp.tag : exp.tag.toUpperCase(), exp.id, exp.classes, exp.attributes, exp.pseudos)) return true;
			simpleExpCounter++;
		}
	}

	if (simpleExpCounter == parsed.length) return false;

	var nodes = this.search(this.document, parsed), item;
	for (i = 0; item = nodes[i++];){
		if (item === node) return true;
	}
	return false;
};

local.matchPseudo = function(node, name, argument){
	var pseudoName = 'pseudo:' + name;
	if (this[pseudoName]) return this[pseudoName](node, argument);
	var attribute = this.getAttribute(node, name);
	return (argument) ? argument == attribute : !!attribute;
};

local.matchSelector = function(node, tag, id, classes, attributes, pseudos){
	if (tag){
		var nodeName = (this.isXMLDocument) ? node.nodeName : node.nodeName.toUpperCase();
		if (tag == '*'){
			if (nodeName < '@') return false; // Fix for comment nodes and closed nodes
		} else {
			if (nodeName != tag) return false;
		}
	}

	if (id && node.getAttribute('id') != id) return false;

	var i, part, cls;
	if (classes) for (i = classes.length; i--;){
		cls = this.getAttribute(node, 'class');
		if (!(cls && classes[i].regexp.test(cls))) return false;
	}
	if (attributes) for (i = attributes.length; i--;){
		part = attributes[i];
		if (part.operator ? !part.test(this.getAttribute(node, part.key)) : !this.hasAttribute(node, part.key)) return false;
	}
	if (pseudos) for (i = pseudos.length; i--;){
		part = pseudos[i];
		if (!this.matchPseudo(node, part.key, part.value)) return false;
	}
	return true;
};

var combinators = {

	' ': function(node, tag, id, classes, attributes, pseudos, classList){ // all child nodes, any level

		var i, item, children;

		if (this.isHTMLDocument){
			getById: if (id){
				item = this.document.getElementById(id);
				if ((!item && node.all) || (this.idGetsName && item && item.getAttributeNode('id').nodeValue != id)){
					// all[id] returns all the elements with that name or id inside node
					// if theres just one it will return the element, else it will be a collection
					children = node.all[id];
					if (!children) return;
					if (!children[0]) children = [children];
					for (i = 0; item = children[i++];){
						var idNode = item.getAttributeNode('id');
						if (idNode && idNode.nodeValue == id){
							this.push(item, tag, null, classes, attributes, pseudos);
							break;
						}
					}
					return;
				}
				if (!item){
					// if the context is in the dom we return, else we will try GEBTN, breaking the getById label
					if (this.contains(this.root, node)) return;
					else break getById;
				} else if (this.document !== node && !this.contains(node, item)) return;
				this.push(item, tag, null, classes, attributes, pseudos);
				return;
			}
			getByClass: if (classes && node.getElementsByClassName && !this.brokenGEBCN){
				children = node.getElementsByClassName(classList.join(' '));
				if (!(children && children.length)) break getByClass;
				for (i = 0; item = children[i++];) this.push(item, tag, id, null, attributes, pseudos);
				return;
			}
		}
		getByTag: {
			children = node.getElementsByTagName(tag);
			if (!(children && children.length)) break getByTag;
			if (!this.brokenStarGEBTN) tag = null;
			for (i = 0; item = children[i++];) this.push(item, tag, id, classes, attributes, pseudos);
		}
	},

	'>': function(node, tag, id, classes, attributes, pseudos){ // direct children
		if ((node = node.firstChild)) do {
			if (node.nodeType == 1) this.push(node, tag, id, classes, attributes, pseudos);
		} while ((node = node.nextSibling));
	},

	'+': function(node, tag, id, classes, attributes, pseudos){ // next sibling
		while ((node = node.nextSibling)) if (node.nodeType == 1){
			this.push(node, tag, id, classes, attributes, pseudos);
			break;
		}
	},

	'^': function(node, tag, id, classes, attributes, pseudos){ // first child
		node = node.firstChild;
		if (node){
			if (node.nodeType == 1) this.push(node, tag, id, classes, attributes, pseudos);
			else this['combinator:+'](node, tag, id, classes, attributes, pseudos);
		}
	},

	'~': function(node, tag, id, classes, attributes, pseudos){ // next siblings
		while ((node = node.nextSibling)){
			if (node.nodeType != 1) continue;
			var uid = this.getUID(node);
			if (this.bitUniques[uid]) break;
			this.bitUniques[uid] = true;
			this.push(node, tag, id, classes, attributes, pseudos);
		}
	},

	'++': function(node, tag, id, classes, attributes, pseudos){ // next sibling and previous sibling
		this['combinator:+'](node, tag, id, classes, attributes, pseudos);
		this['combinator:!+'](node, tag, id, classes, attributes, pseudos);
	},

	'~~': function(node, tag, id, classes, attributes, pseudos){ // next siblings and previous siblings
		this['combinator:~'](node, tag, id, classes, attributes, pseudos);
		this['combinator:!~'](node, tag, id, classes, attributes, pseudos);
	},

	'!': function(node, tag, id, classes, attributes, pseudos){ // all parent nodes up to document
		while ((node = node.parentNode)) if (node !== this.document) this.push(node, tag, id, classes, attributes, pseudos);
	},

	'!>': function(node, tag, id, classes, attributes, pseudos){ // direct parent (one level)
		node = node.parentNode;
		if (node !== this.document) this.push(node, tag, id, classes, attributes, pseudos);
	},

	'!+': function(node, tag, id, classes, attributes, pseudos){ // previous sibling
		while ((node = node.previousSibling)) if (node.nodeType == 1){
			this.push(node, tag, id, classes, attributes, pseudos);
			break;
		}
	},

	'!^': function(node, tag, id, classes, attributes, pseudos){ // last child
		node = node.lastChild;
		if (node){
			if (node.nodeType == 1) this.push(node, tag, id, classes, attributes, pseudos);
			else this['combinator:!+'](node, tag, id, classes, attributes, pseudos);
		}
	},

	'!~': function(node, tag, id, classes, attributes, pseudos){ // previous siblings
		while ((node = node.previousSibling)){
			if (node.nodeType != 1) continue;
			var uid = this.getUID(node);
			if (this.bitUniques[uid]) break;
			this.bitUniques[uid] = true;
			this.push(node, tag, id, classes, attributes, pseudos);
		}
	}

};

for (var c in combinators) local['combinator:' + c] = combinators[c];

var pseudos = {

	/*<pseudo-selectors>*/

	'empty': function(node){
		var child = node.firstChild;
		return !(child && child.nodeType == 1) && !(node.innerText || node.textContent || '').length;
	},

	'not': function(node, expression){
		return !this.matchNode(node, expression);
	},

	'contains': function(node, text){
		return (node.innerText || node.textContent || '').indexOf(text) > -1;
	},

	'first-child': function(node){
		while ((node = node.previousSibling)) if (node.nodeType == 1) return false;
		return true;
	},

	'last-child': function(node){
		while ((node = node.nextSibling)) if (node.nodeType == 1) return false;
		return true;
	},

	'only-child': function(node){
		var prev = node;
		while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false;
		var next = node;
		while ((next = next.nextSibling)) if (next.nodeType == 1) return false;
		return true;
	},

	/*<nth-pseudo-selectors>*/

	'nth-child': local.createNTHPseudo('firstChild', 'nextSibling', 'posNTH'),

	'nth-last-child': local.createNTHPseudo('lastChild', 'previousSibling', 'posNTHLast'),

	'nth-of-type': local.createNTHPseudo('firstChild', 'nextSibling', 'posNTHType', true),

	'nth-last-of-type': local.createNTHPseudo('lastChild', 'previousSibling', 'posNTHTypeLast', true),

	'index': function(node, index){
		return this['pseudo:nth-child'](node, '' + (index + 1));
	},

	'even': function(node){
		return this['pseudo:nth-child'](node, '2n');
	},

	'odd': function(node){
		return this['pseudo:nth-child'](node, '2n+1');
	},

	/*</nth-pseudo-selectors>*/

	/*<of-type-pseudo-selectors>*/

	'first-of-type': function(node){
		var nodeName = node.nodeName;
		while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false;
		return true;
	},

	'last-of-type': function(node){
		var nodeName = node.nodeName;
		while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false;
		return true;
	},

	'only-of-type': function(node){
		var prev = node, nodeName = node.nodeName;
		while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false;
		var next = node;
		while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false;
		return true;
	},

	/*</of-type-pseudo-selectors>*/

	// custom pseudos

	'enabled': function(node){
		return !node.disabled;
	},

	'disabled': function(node){
		return node.disabled;
	},

	'checked': function(node){
		return node.checked || node.selected;
	},

	'focus': function(node){
		return this.isHTMLDocument && this.document.activeElement === node && (node.href || node.type || this.hasAttribute(node, 'tabindex'));
	},

	'root': function(node){
		return (node === this.root);
	},

	'selected': function(node){
		return node.selected;
	}

	/*</pseudo-selectors>*/
};

for (var p in pseudos) local['pseudo:' + p] = pseudos[p];

// attributes methods

var attributeGetters = local.attributeGetters = {

	'for': function(){
		return ('htmlFor' in this) ? this.htmlFor : this.getAttribute('for');
	},

	'href': function(){
		return ('href' in this) ? this.getAttribute('href', 2) : this.getAttribute('href');
	},

	'style': function(){
		return (this.style) ? this.style.cssText : this.getAttribute('style');
	},

	'tabindex': function(){
		var attributeNode = this.getAttributeNode('tabindex');
		return (attributeNode && attributeNode.specified) ? attributeNode.nodeValue : null;
	},

	'type': function(){
		return this.getAttribute('type');
	},

	'maxlength': function(){
		var attributeNode = this.getAttributeNode('maxLength');
		return (attributeNode && attributeNode.specified) ? attributeNode.nodeValue : null;
	}

};

attributeGetters.MAXLENGTH = attributeGetters.maxLength = attributeGetters.maxlength;

// Slick

var Slick = local.Slick = (this.Slick || {});

Slick.version = '1.1.7';

// Slick finder

Slick.search = function(context, expression, append){
	return local.search(context, expression, append);
};

Slick.find = function(context, expression){
	return local.search(context, expression, null, true);
};

// Slick containment checker

Slick.contains = function(container, node){
	local.setDocument(container);
	return local.contains(container, node);
};

// Slick attribute getter

Slick.getAttribute = function(node, name){
	local.setDocument(node);
	return local.getAttribute(node, name);
};

Slick.hasAttribute = function(node, name){
	local.setDocument(node);
	return local.hasAttribute(node, name);
};

// Slick matcher

Slick.match = function(node, selector){
	if (!(node && selector)) return false;
	if (!selector || selector === node) return true;
	local.setDocument(node);
	return local.matchNode(node, selector);
};

// Slick attribute accessor

Slick.defineAttributeGetter = function(name, fn){
	local.attributeGetters[name] = fn;
	return this;
};

Slick.lookupAttributeGetter = function(name){
	return local.attributeGetters[name];
};

// Slick pseudo accessor

Slick.definePseudo = function(name, fn){
	local['pseudo:' + name] = function(node, argument){
		return fn.call(node, argument);
	};
	return this;
};

Slick.lookupPseudo = function(name){
	var pseudo = local['pseudo:' + name];
	if (pseudo) return function(argument){
		return pseudo.call(this, argument);
	};
	return null;
};

// Slick overrides accessor

Slick.override = function(regexp, fn){
	local.override(regexp, fn);
	return this;
};

Slick.isXML = local.isXML;

Slick.uidOf = function(node){
	return local.getUIDHTML(node);
};

if (!this.Slick) this.Slick = Slick;

}).apply(/*<CommonJS>*/(typeof exports != 'undefined') ? exports : /*</CommonJS>*/this);

/*
---

name: Element

description: One of the most important items in MooTools. Contains the dollar function, the dollars function, and an handful of cross-browser, time-saver methods to let you easily work with HTML Elements.

license: MIT-style license.

requires: [Window, Document, Array, String, Function, Object, Number, Slick.Parser, Slick.Finder]

provides: [Element, Elements, $, $$, IFrame, Selectors]

...
*/

var Element = this.Element = function(tag, props){
	var konstructor = Element.Constructors[tag];
	if (konstructor) return konstructor(props);
	if (typeof tag != 'string') return document.id(tag).set(props);

	if (!props) props = {};

	if (!(/^[\w-]+$/).test(tag)){
		var parsed = Slick.parse(tag).expressions[0][0];
		tag = (parsed.tag == '*') ? 'div' : parsed.tag;
		if (parsed.id && props.id == null) props.id = parsed.id;

		var attributes = parsed.attributes;
		if (attributes) for (var attr, i = 0, l = attributes.length; i < l; i++){
			attr = attributes[i];
			if (props[attr.key] != null) continue;

			if (attr.value != null && attr.operator == '=') props[attr.key] = attr.value;
			else if (!attr.value && !attr.operator) props[attr.key] = true;
		}

		if (parsed.classList && props['class'] == null) props['class'] = parsed.classList.join(' ');
	}

	return document.newElement(tag, props);
};


if (Browser.Element){
	Element.prototype = Browser.Element.prototype;
	// IE8 and IE9 require the wrapping.
	Element.prototype._fireEvent = (function(fireEvent){
		return function(type, event){
			return fireEvent.call(this, type, event);
		};
	})(Element.prototype.fireEvent);
}

new Type('Element', Element).mirror(function(name){
	if (Array.prototype[name]) return;

	var obj = {};
	obj[name] = function(){
		var results = [], args = arguments, elements = true;
		for (var i = 0, l = this.length; i < l; i++){
			var element = this[i], result = results[i] = element[name].apply(element, args);
			elements = (elements && typeOf(result) == 'element');
		}
		return (elements) ? new Elements(results) : results;
	};

	Elements.implement(obj);
});

if (!Browser.Element){
	Element.parent = Object;

	Element.Prototype = {
		'$constructor': Element,
		'$family': Function.from('element').hide()
	};

	Element.mirror(function(name, method){
		Element.Prototype[name] = method;
	});
}

Element.Constructors = {};

//<1.2compat>

Element.Constructors = new Hash;

//</1.2compat>

var IFrame = new Type('IFrame', function(){
	var params = Array.link(arguments, {
		properties: Type.isObject,
		iframe: function(obj){
			return (obj != null);
		}
	});

	var props = params.properties || {}, iframe;
	if (params.iframe) iframe = document.id(params.iframe);
	var onload = props.onload || function(){};
	delete props.onload;
	props.id = props.name = [props.id, props.name, iframe ? (iframe.id || iframe.name) : 'IFrame_' + String.uniqueID()].pick();
	iframe = new Element(iframe || 'iframe', props);

	var onLoad = function(){
		onload.call(iframe.contentWindow);
	};

	if (window.frames[props.id]) onLoad();
	else iframe.addListener('load', onLoad);
	return iframe;
});

var Elements = this.Elements = function(nodes){
	if (nodes && nodes.length){
		var uniques = {}, node;
		for (var i = 0; node = nodes[i++];){
			var uid = Slick.uidOf(node);
			if (!uniques[uid]){
				uniques[uid] = true;
				this.push(node);
			}
		}
	}
};

Elements.prototype = {length: 0};
Elements.parent = Array;

new Type('Elements', Elements).implement({

	filter: function(filter, bind){
		if (!filter) return this;
		return new Elements(Array.filter(this, (typeOf(filter) == 'string') ? function(item){
			return item.match(filter);
		} : filter, bind));
	}.protect(),

	push: function(){
		var length = this.length;
		for (var i = 0, l = arguments.length; i < l; i++){
			var item = document.id(arguments[i]);
			if (item) this[length++] = item;
		}
		return (this.length = length);
	}.protect(),

	unshift: function(){
		var items = [];
		for (var i = 0, l = arguments.length; i < l; i++){
			var item = document.id(arguments[i]);
			if (item) items.push(item);
		}
		return Array.prototype.unshift.apply(this, items);
	}.protect(),

	concat: function(){
		var newElements = new Elements(this);
		for (var i = 0, l = arguments.length; i < l; i++){
			var item = arguments[i];
			if (Type.isEnumerable(item)) newElements.append(item);
			else newElements.push(item);
		}
		return newElements;
	}.protect(),

	append: function(collection){
		for (var i = 0, l = collection.length; i < l; i++) this.push(collection[i]);
		return this;
	}.protect(),

	empty: function(){
		while (this.length) delete this[--this.length];
		return this;
	}.protect()

});

//<1.2compat>

Elements.alias('extend', 'append');

//</1.2compat>

(function(){

// FF, IE
var splice = Array.prototype.splice, object = {'0': 0, '1': 1, length: 2};

splice.call(object, 1, 1);
if (object[1] == 1) Elements.implement('splice', function(){
	var length = this.length;
	var result = splice.apply(this, arguments);
	while (length >= this.length) delete this[length--];
	return result;
}.protect());

Array.forEachMethod(function(method, name){
	Elements.implement(name, method);
});

Array.mirror(Elements);

/*<ltIE8>*/
var createElementAcceptsHTML;
try {
	createElementAcceptsHTML = (document.createElement('<input name=x>').name == 'x');
} catch (e){}

var escapeQuotes = function(html){
	return ('' + html).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
};
/*</ltIE8>*/

/*<ltIE9>*/
// #2479 - IE8 Cannot set HTML of style element
var canChangeStyleHTML = (function(){
    var div = document.createElement('style'),
        flag = false;
    try {
        div.innerHTML = '#justTesing{margin: 0px;}';
        flag = !!div.innerHTML;
    } catch(e){}
    return flag;
})();
/*</ltIE9>*/

Document.implement({

	newElement: function(tag, props){
		if (props){
			if (props.checked != null) props.defaultChecked = props.checked;
			if ((props.type == 'checkbox' || props.type == 'radio') && props.value == null) props.value = 'on'; 
			/*<ltIE9>*/ // IE needs the type to be set before changing content of style element
			if (!canChangeStyleHTML && tag == 'style'){
				var styleElement = document.createElement('style');
				styleElement.setAttribute('type', 'text/css');
				if (props.type) delete props.type;
				return this.id(styleElement).set(props);
			}
			/*</ltIE9>*/
			/*<ltIE8>*/// Fix for readonly name and type properties in IE < 8
			if (createElementAcceptsHTML){
				tag = '<' + tag;
				if (props.name) tag += ' name="' + escapeQuotes(props.name) + '"';
				if (props.type) tag += ' type="' + escapeQuotes(props.type) + '"';
				tag += '>';
				delete props.name;
				delete props.type;
			}
			/*</ltIE8>*/
		}
		return this.id(this.createElement(tag)).set(props);
	}

});

})();

(function(){

Slick.uidOf(window);
Slick.uidOf(document);

Document.implement({

	newTextNode: function(text){
		return this.createTextNode(text);
	},

	getDocument: function(){
		return this;
	},

	getWindow: function(){
		return this.window;
	},

	id: (function(){

		var types = {

			string: function(id, nocash, doc){
				id = Slick.find(doc, '#' + id.replace(/(\W)/g, '\\$1'));
				return (id) ? types.element(id, nocash) : null;
			},

			element: function(el, nocash){
				Slick.uidOf(el);
				if (!nocash && !el.$family && !(/^(?:object|embed)$/i).test(el.tagName)){
					var fireEvent = el.fireEvent;
					// wrapping needed in IE7, or else crash
					el._fireEvent = function(type, event){
						return fireEvent(type, event);
					};
					Object.append(el, Element.Prototype);
				}
				return el;
			},

			object: function(obj, nocash, doc){
				if (obj.toElement) return types.element(obj.toElement(doc), nocash);
				return null;
			}

		};

		types.textnode = types.whitespace = types.window = types.document = function(zero){
			return zero;
		};

		return function(el, nocash, doc){
			if (el && el.$family && el.uniqueNumber) return el;
			var type = typeOf(el);
			return (types[type]) ? types[type](el, nocash, doc || document) : null;
		};

	})()

});

if (window.$ == null) Window.implement('$', function(el, nc){
	return document.id(el, nc, this.document);
});

Window.implement({

	getDocument: function(){
		return this.document;
	},

	getWindow: function(){
		return this;
	}

});

[Document, Element].invoke('implement', {

	getElements: function(expression){
		return Slick.search(this, expression, new Elements);
	},

	getElement: function(expression){
		return document.id(Slick.find(this, expression));
	}

});

var contains = {contains: function(element){
	return Slick.contains(this, element);
}};

if (!document.contains) Document.implement(contains);
if (!document.createElement('div').contains) Element.implement(contains);

//<1.2compat>

Element.implement('hasChild', function(element){
	return this !== element && this.contains(element);
});

(function(search, find, match){

	this.Selectors = {};
	var pseudos = this.Selectors.Pseudo = new Hash();

	var addSlickPseudos = function(){
		for (var name in pseudos) if (pseudos.hasOwnProperty(name)){
			Slick.definePseudo(name, pseudos[name]);
			delete pseudos[name];
		}
	};

	Slick.search = function(context, expression, append){
		addSlickPseudos();
		return search.call(this, context, expression, append);
	};

	Slick.find = function(context, expression){
		addSlickPseudos();
		return find.call(this, context, expression);
	};

	Slick.match = function(node, selector){
		addSlickPseudos();
		return match.call(this, node, selector);
	};

})(Slick.search, Slick.find, Slick.match);

//</1.2compat>

// tree walking

var injectCombinator = function(expression, combinator){
	if (!expression) return combinator;

	expression = Object.clone(Slick.parse(expression));

	var expressions = expression.expressions;
	for (var i = expressions.length; i--;)
		expressions[i][0].combinator = combinator;

	return expression;
};

Object.forEach({
	getNext: '~',
	getPrevious: '!~',
	getParent: '!'
}, function(combinator, method){
	Element.implement(method, function(expression){
		return this.getElement(injectCombinator(expression, combinator));
	});
});

Object.forEach({
	getAllNext: '~',
	getAllPrevious: '!~',
	getSiblings: '~~',
	getChildren: '>',
	getParents: '!'
}, function(combinator, method){
	Element.implement(method, function(expression){
		return this.getElements(injectCombinator(expression, combinator));
	});
});

Element.implement({

	getFirst: function(expression){
		return document.id(Slick.search(this, injectCombinator(expression, '>'))[0]);
	},

	getLast: function(expression){
		return document.id(Slick.search(this, injectCombinator(expression, '>')).getLast());
	},

	getWindow: function(){
		return this.ownerDocument.window;
	},

	getDocument: function(){
		return this.ownerDocument;
	},

	getElementById: function(id){
		return document.id(Slick.find(this, '#' + ('' + id).replace(/(\W)/g, '\\$1')));
	},

	match: function(expression){
		return !expression || Slick.match(this, expression);
	}

});

//<1.2compat>

if (window.$$ == null) Window.implement('$$', function(selector){
	var elements = new Elements;
	if (arguments.length == 1 && typeof selector == 'string') return Slick.search(this.document, selector, elements);
	var args = Array.flatten(arguments);
	for (var i = 0, l = args.length; i < l; i++){
		var item = args[i];
		switch (typeOf(item)){
			case 'element': elements.push(item); break;
			case 'string': Slick.search(this.document, item, elements);
		}
	}
	return elements;
});

//</1.2compat>

if (window.$$ == null) Window.implement('$$', function(selector){
	if (arguments.length == 1){
		if (typeof selector == 'string') return Slick.search(this.document, selector, new Elements);
		else if (Type.isEnumerable(selector)) return new Elements(selector);
	}
	return new Elements(arguments);
});

// Inserters

var inserters = {

	before: function(context, element){
		var parent = element.parentNode;
		if (parent) parent.insertBefore(context, element);
	},

	after: function(context, element){
		var parent = element.parentNode;
		if (parent) parent.insertBefore(context, element.nextSibling);
	},

	bottom: function(context, element){
		element.appendChild(context);
	},

	top: function(context, element){
		element.insertBefore(context, element.firstChild);
	}

};

inserters.inside = inserters.bottom;

//<1.2compat>

Object.each(inserters, function(inserter, where){

	where = where.capitalize();

	var methods = {};

	methods['inject' + where] = function(el){
		inserter(this, document.id(el, true));
		return this;
	};

	methods['grab' + where] = function(el){
		inserter(document.id(el, true), this);
		return this;
	};

	Element.implement(methods);

});

//</1.2compat>

// getProperty / setProperty

var propertyGetters = {}, propertySetters = {};

// properties

var properties = {};
Array.forEach([
	'type', 'value', 'defaultValue', 'accessKey', 'cellPadding', 'cellSpacing', 'colSpan',
	'frameBorder', 'rowSpan', 'tabIndex', 'useMap'
], function(property){
	properties[property.toLowerCase()] = property;
});

properties.html = 'innerHTML';
properties.text = (document.createElement('div').textContent == null) ? 'innerText': 'textContent';

Object.forEach(properties, function(real, key){
	propertySetters[key] = function(node, value){
		node[real] = value;
	};
	propertyGetters[key] = function(node){
		return node[real];
	};
});

/*<ltIE9>*/
propertySetters.text = (function(setter){
	return function(node, value){
		if (node.get('tag') == 'style') node.set('html', value);
		else node[properties.text] = value;
	};
})(propertySetters.text);

propertyGetters.text = (function(getter){
	return function(node){
		return (node.get('tag') == 'style') ? node.innerHTML : getter(node);
	};
})(propertyGetters.text);
/*</ltIE9>*/

// Booleans

var bools = [
	'compact', 'nowrap', 'ismap', 'declare', 'noshade', 'checked',
	'disabled', 'readOnly', 'multiple', 'selected', 'noresize',
	'defer', 'defaultChecked', 'autofocus', 'controls', 'autoplay',
	'loop'
];

var booleans = {};
Array.forEach(bools, function(bool){
	var lower = bool.toLowerCase();
	booleans[lower] = bool;
	propertySetters[lower] = function(node, value){
		node[bool] = !!value;
	};
	propertyGetters[lower] = function(node){
		return !!node[bool];
	};
});

// Special cases

Object.append(propertySetters, {

	'class': function(node, value){
		('className' in node) ? node.className = (value || '') : node.setAttribute('class', value);
	},

	'for': function(node, value){
		('htmlFor' in node) ? node.htmlFor = value : node.setAttribute('for', value);
	},

	'style': function(node, value){
		(node.style) ? node.style.cssText = value : node.setAttribute('style', value);
	},

	'value': function(node, value){
		node.value = (value != null) ? value : '';
	}

});

propertyGetters['class'] = function(node){
	return ('className' in node) ? node.className || null : node.getAttribute('class');
};

/* <webkit> */
var el = document.createElement('button');
// IE sets type as readonly and throws
try { el.type = 'button'; } catch(e){}
if (el.type != 'button') propertySetters.type = function(node, value){
	node.setAttribute('type', value);
};
el = null;
/* </webkit> */

/*<IE>*/

/*<ltIE9>*/
// #2479 - IE8 Cannot set HTML of style element
var canChangeStyleHTML = (function(){
    var div = document.createElement('style'),
        flag = false;
    try {
        div.innerHTML = '#justTesing{margin: 0px;}';
        flag = !!div.innerHTML;
    } catch(e){}
    return flag;
})();
/*</ltIE9>*/

var input = document.createElement('input'), volatileInputValue, html5InputSupport;

// #2178
input.value = 't';
input.type = 'submit';
volatileInputValue = input.value != 't';

// #2443 - IE throws "Invalid Argument" when trying to use html5 input types
try {
	input.value = '';
	input.type = 'email';
	html5InputSupport = input.type == 'email';
} catch(e){}

input = null;

if (volatileInputValue || !html5InputSupport) propertySetters.type = function(node, type){
	try {
		var value = node.value;
		node.type = type;
		node.value = value;
	} catch (e){}
};
/*</IE>*/

/* getProperty, setProperty */

/* <ltIE9> */
var pollutesGetAttribute = (function(div){
	div.random = 'attribute';
	return (div.getAttribute('random') == 'attribute');
})(document.createElement('div'));

var hasCloneBug = (function(test){
	test.innerHTML = '<object><param name="should_fix" value="the unknown" /></object>';
	return test.cloneNode(true).firstChild.childNodes.length != 1;
})(document.createElement('div'));
/* </ltIE9> */

var hasClassList = !!document.createElement('div').classList;

var classes = function(className){
	var classNames = (className || '').clean().split(" "), uniques = {};
	return classNames.filter(function(className){
		if (className !== "" && !uniques[className]) return uniques[className] = className;
	});
};

var addToClassList = function(name){
	this.classList.add(name);
};

var removeFromClassList = function(name){
	this.classList.remove(name);
};

Element.implement({

	setProperty: function(name, value){
		var setter = propertySetters[name.toLowerCase()];
		if (setter){
			setter(this, value);
		} else {
			/* <ltIE9> */
			var attributeWhiteList;
			if (pollutesGetAttribute) attributeWhiteList = this.retrieve('$attributeWhiteList', {});
			/* </ltIE9> */

			if (value == null){
				this.removeAttribute(name);
				/* <ltIE9> */
				if (pollutesGetAttribute) delete attributeWhiteList[name];
				/* </ltIE9> */
			} else {
				this.setAttribute(name, '' + value);
				/* <ltIE9> */
				if (pollutesGetAttribute) attributeWhiteList[name] = true;
				/* </ltIE9> */
			}
		}
		return this;
	},

	setProperties: function(attributes){
		for (var attribute in attributes) this.setProperty(attribute, attributes[attribute]);
		return this;
	},

	getProperty: function(name){
		var getter = propertyGetters[name.toLowerCase()];
		if (getter) return getter(this);
		/* <ltIE9> */
		if (pollutesGetAttribute){
			var attr = this.getAttributeNode(name), attributeWhiteList = this.retrieve('$attributeWhiteList', {});
			if (!attr) return null;
			if (attr.expando && !attributeWhiteList[name]){
				var outer = this.outerHTML;
				// segment by the opening tag and find mention of attribute name
				if (outer.substr(0, outer.search(/\/?['"]?>(?![^<]*<['"])/)).indexOf(name) < 0) return null;
				attributeWhiteList[name] = true;
			}
		}
		/* </ltIE9> */
		var result = Slick.getAttribute(this, name);
		return (!result && !Slick.hasAttribute(this, name)) ? null : result;
	},

	getProperties: function(){
		var args = Array.from(arguments);
		return args.map(this.getProperty, this).associate(args);
	},

	removeProperty: function(name){
		return this.setProperty(name, null);
	},

	removeProperties: function(){
		Array.each(arguments, this.removeProperty, this);
		return this;
	},

	set: function(prop, value){
		var property = Element.Properties[prop];
		(property && property.set) ? property.set.call(this, value) : this.setProperty(prop, value);
	}.overloadSetter(),

	get: function(prop){
		var property = Element.Properties[prop];
		return (property && property.get) ? property.get.apply(this) : this.getProperty(prop);
	}.overloadGetter(),

	erase: function(prop){
		var property = Element.Properties[prop];
		(property && property.erase) ? property.erase.apply(this) : this.removeProperty(prop);
		return this;
	},

	hasClass: hasClassList ? function(className){
		return this.classList.contains(className);
	} : function(className){
		return classes(this.className).contains(className);
	},

	addClass: hasClassList ? function(className){
		classes(className).forEach(addToClassList, this);
		return this;
	} : function(className){
		this.className = classes(className + ' ' + this.className).join(' ');
		return this;
	},

	removeClass: hasClassList ? function(className){
		classes(className).forEach(removeFromClassList, this);
		return this;
	} : function(className){
		var classNames = classes(this.className);
		classes(className).forEach(classNames.erase, classNames);
		this.className = classNames.join(' ');
		return this;
	},

	toggleClass: function(className, force){
		if (force == null) force = !this.hasClass(className);
		return (force) ? this.addClass(className) : this.removeClass(className);
	},

	adopt: function(){
		var parent = this, fragment, elements = Array.flatten(arguments), length = elements.length;
		if (length > 1) parent = fragment = document.createDocumentFragment();

		for (var i = 0; i < length; i++){
			var element = document.id(elements[i], true);
			if (element) parent.appendChild(element);
		}

		if (fragment) this.appendChild(fragment);

		return this;
	},

	appendText: function(text, where){
		return this.grab(this.getDocument().newTextNode(text), where);
	},

	grab: function(el, where){
		inserters[where || 'bottom'](document.id(el, true), this);
		return this;
	},

	inject: function(el, where){
		inserters[where || 'bottom'](this, document.id(el, true));
		return this;
	},

	replaces: function(el){
		el = document.id(el, true);
		el.parentNode.replaceChild(this, el);
		return this;
	},

	wraps: function(el, where){
		el = document.id(el, true);
		return this.replaces(el).grab(el, where);
	},

	getSelected: function(){
		this.selectedIndex; // Safari 3.2.1
		return new Elements(Array.from(this.options).filter(function(option){
			return option.selected;
		}));
	},

	toQueryString: function(){
		var queryString = [];
		this.getElements('input, select, textarea').each(function(el){
			var type = el.type;
			if (!el.name || el.disabled || type == 'submit' || type == 'reset' || type == 'file' || type == 'image') return;

			var value = (el.get('tag') == 'select') ? el.getSelected().map(function(opt){
				// IE
				return document.id(opt).get('value');
			}) : ((type == 'radio' || type == 'checkbox') && !el.checked) ? null : el.get('value');

			Array.from(value).each(function(val){
				if (typeof val != 'undefined') queryString.push(encodeURIComponent(el.name) + '=' + encodeURIComponent(val));
			});
		});
		return queryString.join('&');
	}

});


// appendHTML

var appendInserters = {
	before: 'beforeBegin',
	after: 'afterEnd',
	bottom: 'beforeEnd',
	top: 'afterBegin',
	inside: 'beforeEnd'
};

Element.implement('appendHTML', ('insertAdjacentHTML' in document.createElement('div')) ? function(html, where){
	this.insertAdjacentHTML(appendInserters[where || 'bottom'], html);
	return this;
} : function(html, where){
	var temp = new Element('div', {html: html}),
		children = temp.childNodes,
		fragment = temp.firstChild;

	if (!fragment) return this;
	if (children.length > 1){
		fragment = document.createDocumentFragment();
		for (var i = 0, l = children.length; i < l; i++){
			fragment.appendChild(children[i]);
		}
	}

	inserters[where || 'bottom'](fragment, this);
	return this;
});

var collected = {}, storage = {};

var get = function(uid){
	return (storage[uid] || (storage[uid] = {}));
};

var clean = function(item){
	var uid = item.uniqueNumber;
	if (item.removeEvents) item.removeEvents();
	if (item.clearAttributes) item.clearAttributes();
	if (uid != null){
		delete collected[uid];
		delete storage[uid];
	}
	return item;
};

var formProps = {input: 'checked', option: 'selected', textarea: 'value'};

Element.implement({

	destroy: function(){
		var children = clean(this).getElementsByTagName('*');
		Array.each(children, clean);
		Element.dispose(this);
		return null;
	},

	empty: function(){
		Array.from(this.childNodes).each(Element.dispose);
		return this;
	},

	dispose: function(){
		return (this.parentNode) ? this.parentNode.removeChild(this) : this;
	},

	clone: function(contents, keepid){
		contents = contents !== false;
		var clone = this.cloneNode(contents), ce = [clone], te = [this], i;

		if (contents){
			ce.append(Array.from(clone.getElementsByTagName('*')));
			te.append(Array.from(this.getElementsByTagName('*')));
		}

		for (i = ce.length; i--;){
			var node = ce[i], element = te[i];
			if (!keepid) node.removeAttribute('id');
			/*<ltIE9>*/
			if (node.clearAttributes){
				node.clearAttributes();
				node.mergeAttributes(element);
				node.removeAttribute('uniqueNumber');
				if (node.options){
					var no = node.options, eo = element.options;
					for (var j = no.length; j--;) no[j].selected = eo[j].selected;
				}
			}
			/*</ltIE9>*/
			var prop = formProps[element.tagName.toLowerCase()];
			if (prop && element[prop]) node[prop] = element[prop];
		}

		/*<ltIE9>*/
		if (hasCloneBug){
			var co = clone.getElementsByTagName('object'), to = this.getElementsByTagName('object');
			for (i = co.length; i--;) co[i].outerHTML = to[i].outerHTML;
		}
		/*</ltIE9>*/
		return document.id(clone);
	}

});

[Element, Window, Document].invoke('implement', {

	addListener: function(type, fn){
		if (window.attachEvent && !window.addEventListener){
			collected[Slick.uidOf(this)] = this;
		}
		if (this.addEventListener) this.addEventListener(type, fn, !!arguments[2]);
		else this.attachEvent('on' + type, fn);
		return this;
	},

	removeListener: function(type, fn){
		if (this.removeEventListener) this.removeEventListener(type, fn, !!arguments[2]);
		else this.detachEvent('on' + type, fn);
		return this;
	},

	retrieve: function(property, dflt){
		var storage = get(Slick.uidOf(this)), prop = storage[property];
		if (dflt != null && prop == null) prop = storage[property] = dflt;
		return prop != null ? prop : null;
	},

	store: function(property, value){
		var storage = get(Slick.uidOf(this));
		storage[property] = value;
		return this;
	},

	eliminate: function(property){
		var storage = get(Slick.uidOf(this));
		delete storage[property];
		return this;
	}

});

/*<ltIE9>*/
if (window.attachEvent && !window.addEventListener){
	var gc = function(){
		Object.each(collected, clean);
		if (window.CollectGarbage) CollectGarbage();
		window.removeListener('unload', gc);
	};
	window.addListener('unload', gc);
}
/*</ltIE9>*/

Element.Properties = {};

//<1.2compat>

Element.Properties = new Hash;

//</1.2compat>

Element.Properties.style = {

	set: function(style){
		this.style.cssText = style;
	},

	get: function(){
		return this.style.cssText;
	},

	erase: function(){
		this.style.cssText = '';
	}

};

Element.Properties.tag = {

	get: function(){
		return this.tagName.toLowerCase();
	}

};

Element.Properties.html = {

	set: function(html){
		if (html == null) html = '';
		else if (typeOf(html) == 'array') html = html.join('');

		/*<ltIE9>*/
		if (this.styleSheet && !canChangeStyleHTML) this.styleSheet.cssText = html;
		else /*</ltIE9>*/this.innerHTML = html;
	},
	erase: function(){
		this.set('html', '');
	}

};

var supportsHTML5Elements = true, supportsTableInnerHTML = true, supportsTRInnerHTML = true;

/*<ltIE9>*/
// technique by jdbarlett - http://jdbartlett.com/innershiv/
var div = document.createElement('div');
div.innerHTML = '<nav></nav>';
supportsHTML5Elements = (div.childNodes.length == 1);
if (!supportsHTML5Elements){
	var tags = 'abbr article aside audio canvas datalist details figcaption figure footer header hgroup mark meter nav output progress section summary time video'.split(' '),
		fragment = document.createDocumentFragment(), l = tags.length;
	while (l--) fragment.createElement(tags[l]);
}
div = null;
/*</ltIE9>*/

/*<IE>*/
supportsTableInnerHTML = Function.attempt(function(){
	var table = document.createElement('table');
	table.innerHTML = '<tr><td></td></tr>';
	return true;
});

/*<ltFF4>*/
var tr = document.createElement('tr'), html = '<td></td>';
tr.innerHTML = html;
supportsTRInnerHTML = (tr.innerHTML == html);
tr = null;
/*</ltFF4>*/

if (!supportsTableInnerHTML || !supportsTRInnerHTML || !supportsHTML5Elements){

	Element.Properties.html.set = (function(set){

		var translations = {
			table: [1, '<table>', '</table>'],
			select: [1, '<select>', '</select>'],
			tbody: [2, '<table><tbody>', '</tbody></table>'],
			tr: [3, '<table><tbody><tr>', '</tr></tbody></table>']
		};

		translations.thead = translations.tfoot = translations.tbody;

		return function(html){

			/*<ltIE9>*/
			if (this.styleSheet) return set.call(this, html);
			/*</ltIE9>*/
			var wrap = translations[this.get('tag')];
			if (!wrap && !supportsHTML5Elements) wrap = [0, '', ''];
			if (!wrap) return set.call(this, html);

			var level = wrap[0], wrapper = document.createElement('div'), target = wrapper;
			if (!supportsHTML5Elements) fragment.appendChild(wrapper);
			wrapper.innerHTML = [wrap[1], html, wrap[2]].flatten().join('');
			while (level--) target = target.firstChild;
			this.empty().adopt(target.childNodes);
			if (!supportsHTML5Elements) fragment.removeChild(wrapper);
			wrapper = null;
		};

	})(Element.Properties.html.set);
}
/*</IE>*/

/*<ltIE9>*/
var testForm = document.createElement('form');
testForm.innerHTML = '<select><option>s</option></select>';

if (testForm.firstChild.value != 's') Element.Properties.value = {

	set: function(value){
		var tag = this.get('tag');
		if (tag != 'select') return this.setProperty('value', value);
		var options = this.getElements('option');
		value = String(value);
		for (var i = 0; i < options.length; i++){
			var option = options[i],
				attr = option.getAttributeNode('value'),
				optionValue = (attr && attr.specified) ? option.value : option.get('text');
			if (optionValue === value) return option.selected = true;
		}
	},

	get: function(){
		var option = this, tag = option.get('tag');

		if (tag != 'select' && tag != 'option') return this.getProperty('value');

		if (tag == 'select' && !(option = option.getSelected()[0])) return '';

		var attr = option.getAttributeNode('value');
		return (attr && attr.specified) ? option.value : option.get('text');
	}

};
testForm = null;
/*</ltIE9>*/

/*<IE>*/
if (document.createElement('div').getAttributeNode('id')) Element.Properties.id = {
	set: function(id){
		this.id = this.getAttributeNode('id').value = id;
	},
	get: function(){
		return this.id || null;
	},
	erase: function(){
		this.id = this.getAttributeNode('id').value = '';
	}
};
/*</IE>*/

})();

/*
---

name: Event

description: Contains the Event Type, to make the event object cross-browser.

license: MIT-style license.

requires: [Window, Document, Array, Function, String, Object]

provides: Event

...
*/

(function(){

var _keys = {};
var normalizeWheelSpeed = function(event){
    var normalized;
    if (event.wheelDelta){
        normalized = event.wheelDelta % 120 == 0 ? event.wheelDelta / 120 : event.wheelDelta / 12;
    } else {
        var rawAmount = event.deltaY || event.detail || 0;
        normalized = -(rawAmount % 3 == 0 ? rawAmount / 3 : rawAmount * 10);
    }
    return normalized;
}

var DOMEvent = this.DOMEvent = new Type('DOMEvent', function(event, win){
	if (!win) win = window;
	event = event || win.event;
	if (event.$extended) return event;
	this.event = event;
	this.$extended = true;
	this.shift = event.shiftKey;
	this.control = event.ctrlKey;
	this.alt = event.altKey;
	this.meta = event.metaKey;
	var type = this.type = event.type;
	var target = event.target || event.srcElement;
	while (target && target.nodeType == 3) target = target.parentNode;
	this.target = document.id(target);

	if (type.indexOf('key') == 0){
		var code = this.code = (event.which || event.keyCode);
		if (!this.shift || type != 'keypress') this.key = _keys[code]/*<1.3compat>*/ || Object.keyOf(Event.Keys, code)/*</1.3compat>*/;
		if (type == 'keydown' || type == 'keyup'){
			if (code > 111 && code < 124) this.key = 'f' + (code - 111);
			else if (code > 95 && code < 106) this.key = code - 96;
		}
		if (this.key == null) this.key = String.fromCharCode(code).toLowerCase();
	} else if (type == 'click' || type == 'dblclick' || type == 'contextmenu' || type == 'wheel' || type == 'DOMMouseScroll' || type.indexOf('mouse') == 0){
		var doc = win.document;
		doc = (!doc.compatMode || doc.compatMode == 'CSS1Compat') ? doc.html : doc.body;
		this.page = {
			x: (event.pageX != null) ? event.pageX : event.clientX + doc.scrollLeft,
			y: (event.pageY != null) ? event.pageY : event.clientY + doc.scrollTop
		};
		this.client = {
			x: (event.pageX != null) ? event.pageX - win.pageXOffset : event.clientX,
			y: (event.pageY != null) ? event.pageY - win.pageYOffset : event.clientY
		};
		if (type == 'DOMMouseScroll' || type == 'wheel' || type == 'mousewheel') this.wheel = normalizeWheelSpeed(event);
		this.rightClick = (event.which == 3 || event.button == 2);
		if (type == 'mouseover' || type == 'mouseout' || type == 'mouseenter' || type == 'mouseleave'){
			var overTarget = type == 'mouseover' || type == 'mouseenter';
			var related = event.relatedTarget || event[(overTarget ? 'from' : 'to') + 'Element'];
			while (related && related.nodeType == 3) related = related.parentNode;
			this.relatedTarget = document.id(related);
		}
	} else if (type.indexOf('touch') == 0 || type.indexOf('gesture') == 0){
		this.rotation = event.rotation;
		this.scale = event.scale;
		this.targetTouches = event.targetTouches;
		this.changedTouches = event.changedTouches;
		var touches = this.touches = event.touches;
		if (touches && touches[0]){
			var touch = touches[0];
			this.page = {x: touch.pageX, y: touch.pageY};
			this.client = {x: touch.clientX, y: touch.clientY};
		}
	}

	if (!this.client) this.client = {};
	if (!this.page) this.page = {};
});

DOMEvent.implement({

	stop: function(){
		return this.preventDefault().stopPropagation();
	},

	stopPropagation: function(){
		if (this.event.stopPropagation) this.event.stopPropagation();
		else this.event.cancelBubble = true;
		return this;
	},

	preventDefault: function(){
		if (this.event.preventDefault) this.event.preventDefault();
		else this.event.returnValue = false;
		return this;
	}

});

DOMEvent.defineKey = function(code, key){
	_keys[code] = key;
	return this;
};

DOMEvent.defineKeys = DOMEvent.defineKey.overloadSetter(true);

DOMEvent.defineKeys({
	'38': 'up', '40': 'down', '37': 'left', '39': 'right',
	'27': 'esc', '32': 'space', '8': 'backspace', '9': 'tab',
	'46': 'delete', '13': 'enter'
});

})();

/*<1.3compat>*/
var Event = DOMEvent;
Event.Keys = {};
/*</1.3compat>*/

/*<1.2compat>*/

Event.Keys = new Hash(Event.Keys);

/*</1.2compat>*/

/*
---

name: Element.Event

description: Contains Element methods for dealing with events. This file also includes mouseenter and mouseleave custom Element Events, if necessary.

license: MIT-style license.

requires: [Element, Event]

provides: Element.Event

...
*/

(function(){

Element.Properties.events = {set: function(events){
	this.addEvents(events);
}};

[Element, Window, Document].invoke('implement', {

	addEvent: function(type, fn){
		var events = this.retrieve('events', {});
		if (!events[type]) events[type] = {keys: [], values: []};
		if (events[type].keys.contains(fn)) return this;
		events[type].keys.push(fn);
		var realType = type,
			custom = Element.Events[type],
			condition = fn,
			self = this;
		if (custom){
			if (custom.onAdd) custom.onAdd.call(this, fn, type);
			if (custom.condition){
				condition = function(event){
					if (custom.condition.call(this, event, type)) return fn.call(this, event);
					return true;
				};
			}
			if (custom.base) realType = Function.from(custom.base).call(this, type);
		}
		var defn = function(){
			return fn.call(self);
		};
		var nativeEvent = Element.NativeEvents[realType];
		if (nativeEvent){
			if (nativeEvent == 2){
				defn = function(event){
					event = new DOMEvent(event, self.getWindow());
					if (condition.call(self, event) === false) event.stop();
				};
			}
			this.addListener(realType, defn, arguments[2]);
		}
		events[type].values.push(defn);
		return this;
	},

	removeEvent: function(type, fn){
		var events = this.retrieve('events');
		if (!events || !events[type]) return this;
		var list = events[type];
		var index = list.keys.indexOf(fn);
		if (index == -1) return this;
		var value = list.values[index];
		delete list.keys[index];
		delete list.values[index];
		var custom = Element.Events[type];
		if (custom){
			if (custom.onRemove) custom.onRemove.call(this, fn, type);
			if (custom.base) type = Function.from(custom.base).call(this, type);
		}
		return (Element.NativeEvents[type]) ? this.removeListener(type, value, arguments[2]) : this;
	},

	addEvents: function(events){
		for (var event in events) this.addEvent(event, events[event]);
		return this;
	},

	removeEvents: function(events){
		var type;
		if (typeOf(events) == 'object'){
			for (type in events) this.removeEvent(type, events[type]);
			return this;
		}
		var attached = this.retrieve('events');
		if (!attached) return this;
		if (!events){
			for (type in attached) this.removeEvents(type);
			this.eliminate('events');
		} else if (attached[events]){
			attached[events].keys.each(function(fn){
				this.removeEvent(events, fn);
			}, this);
			delete attached[events];
		}
		return this;
	},

	fireEvent: function(type, args, delay){
		var events = this.retrieve('events');
		if (!events || !events[type]) return this;
		args = Array.from(args);

		events[type].keys.each(function(fn){
			if (delay) fn.delay(delay, this, args);
			else fn.apply(this, args);
		}, this);
		return this;
	},

	cloneEvents: function(from, type){
		from = document.id(from);
		var events = from.retrieve('events');
		if (!events) return this;
		if (!type){
			for (var eventType in events) this.cloneEvents(from, eventType);
		} else if (events[type]){
			events[type].keys.each(function(fn){
				this.addEvent(type, fn);
			}, this);
		}
		return this;
	}

});

Element.NativeEvents = {
	click: 2, dblclick: 2, mouseup: 2, mousedown: 2, contextmenu: 2, //mouse buttons
	wheel: 2, mousewheel: 2, DOMMouseScroll: 2, //mouse wheel
	mouseover: 2, mouseout: 2, mousemove: 2, selectstart: 2, selectend: 2, //mouse movement
	keydown: 2, keypress: 2, keyup: 2, //keyboard
	orientationchange: 2, // mobile
	touchstart: 2, touchmove: 2, touchend: 2, touchcancel: 2, // touch
	gesturestart: 2, gesturechange: 2, gestureend: 2, // gesture
	focus: 2, blur: 2, change: 2, reset: 2, select: 2, submit: 2, paste: 2, input: 2, //form elements
	load: 2, unload: 1, beforeunload: 2, resize: 1, move: 1, DOMContentLoaded: 1, readystatechange: 1, //window
	hashchange: 1, popstate: 2, pageshow: 2, pagehide: 2, // history
	error: 1, abort: 1, scroll: 1, message: 2 //misc
};

Element.Events = {
	mousewheel: {
		base: 'onwheel' in document ? 'wheel' : 'onmousewheel' in document ? 'mousewheel' : 'DOMMouseScroll'
	}
};

var check = function(event){
	var related = event.relatedTarget;
	if (related == null) return true;
	if (!related) return false;
	return (related != this && related.prefix != 'xul' && typeOf(this) != 'document' && !this.contains(related));
};

if ('onmouseenter' in document.documentElement){
	Element.NativeEvents.mouseenter = Element.NativeEvents.mouseleave = 2;
	Element.MouseenterCheck = check;
} else {
	Element.Events.mouseenter = {
		base: 'mouseover',
		condition: check
	};

	Element.Events.mouseleave = {
		base: 'mouseout',
		condition: check
	};
}

/*<ltIE9>*/
if (!window.addEventListener){
	Element.NativeEvents.propertychange = 2;
	Element.Events.change = {
		base: function(){
			var type = this.type;
			return (this.get('tag') == 'input' && (type == 'radio' || type == 'checkbox')) ? 'propertychange' : 'change';
		},
		condition: function(event){
			return event.type != 'propertychange' || event.event.propertyName == 'checked';
		}
	};
}
/*</ltIE9>*/

//<1.2compat>

Element.Events = new Hash(Element.Events);

//</1.2compat>

})();

/*
---

name: Element.Delegation

description: Extends the Element native object to include the delegate method for more efficient event management.

license: MIT-style license.

requires: [Element.Event]

provides: [Element.Delegation]

...
*/

(function(){

var eventListenerSupport = !!window.addEventListener;

Element.NativeEvents.focusin = Element.NativeEvents.focusout = 2;

var bubbleUp = function(self, match, fn, event, target){
	while (target && target != self){
		if (match(target, event)) return fn.call(target, event, target);
		target = document.id(target.parentNode);
	}
};

var map = {
	mouseenter: {
		base: 'mouseover',
		condition: Element.MouseenterCheck
	},
	mouseleave: {
		base: 'mouseout',
		condition: Element.MouseenterCheck
	},
	focus: {
		base: 'focus' + (eventListenerSupport ? '' : 'in'),
		capture: true
	},
	blur: {
		base: eventListenerSupport ? 'blur' : 'focusout',
		capture: true
	}
};

/*<ltIE9>*/
var _key = '$delegation:';
var formObserver = function(type){

	return {

		base: 'focusin',

		remove: function(self, uid){
			var list = self.retrieve(_key + type + 'listeners', {})[uid];
			if (list && list.forms) for (var i = list.forms.length; i--;){
				// the form may have been destroyed, so it won't have the
				// removeEvent method anymore. In that case the event was
				// removed as well.
				if (list.forms[i].removeEvent) list.forms[i].removeEvent(type, list.fns[i]);
			}
		},

		listen: function(self, match, fn, event, target, uid){
			var form = (target.get('tag') == 'form') ? target : event.target.getParent('form');
			if (!form) return;

			var listeners = self.retrieve(_key + type + 'listeners', {}),
				listener = listeners[uid] || {forms: [], fns: []},
				forms = listener.forms, fns = listener.fns;

			if (forms.indexOf(form) != -1) return;
			forms.push(form);

			var _fn = function(event){
				bubbleUp(self, match, fn, event, target);
			};
			form.addEvent(type, _fn);
			fns.push(_fn);

			listeners[uid] = listener;
			self.store(_key + type + 'listeners', listeners);
		}
	};
};

var inputObserver = function(type){
	return {
		base: 'focusin',
		listen: function(self, match, fn, event, target){
			var events = {blur: function(){
				this.removeEvents(events);
			}};
			events[type] = function(event){
				bubbleUp(self, match, fn, event, target);
			};
			event.target.addEvents(events);
		}
	};
};

if (!eventListenerSupport) Object.append(map, {
	submit: formObserver('submit'),
	reset: formObserver('reset'),
	change: inputObserver('change'),
	select: inputObserver('select')
});
/*</ltIE9>*/

var proto = Element.prototype,
	addEvent = proto.addEvent,
	removeEvent = proto.removeEvent;

var relay = function(old, method){
	return function(type, fn, useCapture){
		if (type.indexOf(':relay') == -1) return old.call(this, type, fn, useCapture);
		var parsed = Slick.parse(type).expressions[0][0];
		if (parsed.pseudos[0].key != 'relay') return old.call(this, type, fn, useCapture);
		var newType = parsed.tag;
		parsed.pseudos.slice(1).each(function(pseudo){
			newType += ':' + pseudo.key + (pseudo.value ? '(' + pseudo.value + ')' : '');
		});
		old.call(this, type, fn);
		return method.call(this, newType, parsed.pseudos[0].value, fn);
	};
};

var delegation = {

	addEvent: function(type, match, fn){
		var storage = this.retrieve('$delegates', {}), stored = storage[type];
		if (stored) for (var _uid in stored){
			if (stored[_uid].fn == fn && stored[_uid].match == match) return this;
		}

		var _type = type, _match = match, _fn = fn, _map = map[type] || {};
		type = _map.base || _type;

		match = function(target){
			return Slick.match(target, _match);
		};

		var elementEvent = Element.Events[_type];
		if (_map.condition || elementEvent && elementEvent.condition){
			var __match = match, condition = _map.condition || elementEvent.condition;
			match = function(target, event){
				return __match(target, event) && condition.call(target, event, type);
			};
		}

		var self = this, uid = String.uniqueID();
		var delegator = _map.listen ? function(event, target){
			if (!target && event && event.target) target = event.target;
			if (target) _map.listen(self, match, fn, event, target, uid);
		} : function(event, target){
			if (!target && event && event.target) target = event.target;
			if (target) bubbleUp(self, match, fn, event, target);
		};

		if (!stored) stored = {};
		stored[uid] = {
			match: _match,
			fn: _fn,
			delegator: delegator
		};
		storage[_type] = stored;
		return addEvent.call(this, type, delegator, _map.capture);
	},

	removeEvent: function(type, match, fn, _uid){
		var storage = this.retrieve('$delegates', {}), stored = storage[type];
		if (!stored) return this;

		if (_uid){
			var _type = type, delegator = stored[_uid].delegator, _map = map[type] || {};
			type = _map.base || _type;
			if (_map.remove) _map.remove(this, _uid);
			delete stored[_uid];
			storage[_type] = stored;
			return removeEvent.call(this, type, delegator, _map.capture);
		}

		var __uid, s;
		if (fn) for (__uid in stored){
			s = stored[__uid];
			if (s.match == match && s.fn == fn) return delegation.removeEvent.call(this, type, match, fn, __uid);
		} else for (__uid in stored){
			s = stored[__uid];
			if (s.match == match) delegation.removeEvent.call(this, type, match, s.fn, __uid);
		}
		return this;
	}

};

[Element, Window, Document].invoke('implement', {
	addEvent: relay(addEvent, delegation.addEvent),
	removeEvent: relay(removeEvent, delegation.removeEvent)
});

})();

/*
---

name: Element.Style

description: Contains methods for interacting with the styles of Elements in a fashionable way.

license: MIT-style license.

requires: Element

provides: Element.Style

...
*/

(function(){

var html = document.html, el;

//<ltIE9>
// Check for oldIE, which does not remove styles when they're set to null
el = document.createElement('div');
el.style.color = 'red';
el.style.color = null;
var doesNotRemoveStyles = el.style.color == 'red';

// check for oldIE, which returns border* shorthand styles in the wrong order (color-width-style instead of width-style-color)
var border = '1px solid #123abc';
el.style.border = border;
var returnsBordersInWrongOrder = el.style.border != border;
el = null;
//</ltIE9>

var hasGetComputedStyle = !!window.getComputedStyle,
	supportBorderRadius = document.createElement('div').style.borderRadius != null;

Element.Properties.styles = {set: function(styles){
	this.setStyles(styles);
}};

var hasOpacity = (html.style.opacity != null),
	hasFilter = (html.style.filter != null),
	reAlpha = /alpha\(opacity=([\d.]+)\)/i;

var setVisibility = function(element, opacity){
	element.store('$opacity', opacity);
	element.style.visibility = opacity > 0 || opacity == null ? 'visible' : 'hidden';
};

//<ltIE9>
var setFilter = function(element, regexp, value){
	var style = element.style,
		filter = style.filter || element.getComputedStyle('filter') || '';
	style.filter = (regexp.test(filter) ? filter.replace(regexp, value) : filter + ' ' + value).trim();
	if (!style.filter) style.removeAttribute('filter');
};
//</ltIE9>

var setOpacity = (hasOpacity ? function(element, opacity){
	element.style.opacity = opacity;
} : (hasFilter ? function(element, opacity){
	if (!element.currentStyle || !element.currentStyle.hasLayout) element.style.zoom = 1;
	if (opacity == null || opacity == 1){
		setFilter(element, reAlpha, '');
		if (opacity == 1 && getOpacity(element) != 1) setFilter(element, reAlpha, 'alpha(opacity=100)');
	} else {
		setFilter(element, reAlpha, 'alpha(opacity=' + (opacity * 100).limit(0, 100).round() + ')');
	}
} : setVisibility));

var getOpacity = (hasOpacity ? function(element){
	var opacity = element.style.opacity || element.getComputedStyle('opacity');
	return (opacity == '') ? 1 : opacity.toFloat();
} : (hasFilter ? function(element){
	var filter = (element.style.filter || element.getComputedStyle('filter')),
		opacity;
	if (filter) opacity = filter.match(reAlpha);
	return (opacity == null || filter == null) ? 1 : (opacity[1] / 100);
} : function(element){
	var opacity = element.retrieve('$opacity');
	if (opacity == null) opacity = (element.style.visibility == 'hidden' ? 0 : 1);
	return opacity;
}));

var floatName = (html.style.cssFloat == null) ? 'styleFloat' : 'cssFloat',
	namedPositions = {left: '0%', top: '0%', center: '50%', right: '100%', bottom: '100%'},
	hasBackgroundPositionXY = (html.style.backgroundPositionX != null),
	prefixPattern = /^-(ms)-/;

var camelCase = function(property){
	return property.replace(prefixPattern, '$1-').camelCase();
}

//<ltIE9>
var removeStyle = function(style, property){
	if (property == 'backgroundPosition'){
		style.removeAttribute(property + 'X');
		property += 'Y';
	}
	style.removeAttribute(property);
};
//</ltIE9>

Element.implement({

	getComputedStyle: function(property){
		if (!hasGetComputedStyle && this.currentStyle) return this.currentStyle[camelCase(property)];
		var defaultView = Element.getDocument(this).defaultView,
			computed = defaultView ? defaultView.getComputedStyle(this, null) : null;
		return (computed) ? computed.getPropertyValue((property == floatName) ? 'float' : property.hyphenate()) : '';
	},

	setStyle: function(property, value){
		if (property == 'opacity'){
			if (value != null) value = parseFloat(value);
			setOpacity(this, value);
			return this;
		}
		property = camelCase(property == 'float' ? floatName : property);
		if (typeOf(value) != 'string'){
			var map = (Element.Styles[property] || '@').split(' ');
			value = Array.from(value).map(function(val, i){
				if (!map[i]) return '';
				return (typeOf(val) == 'number') ? map[i].replace('@', Math.round(val)) : val;
			}).join(' ');
		} else if (value == String(Number(value))){
			value = Math.round(value);
		}
		this.style[property] = value;
		//<ltIE9>
		if ((value == '' || value == null) && doesNotRemoveStyles && this.style.removeAttribute){
			removeStyle(this.style, property);
		}
		//</ltIE9>
		return this;
	},

	getStyle: function(property){
		if (property == 'opacity') return getOpacity(this);
		property = camelCase(property == 'float' ? floatName : property);
		if (supportBorderRadius && property.indexOf('borderRadius') != -1){
			return ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'].map(function(corner){
				return this.style[corner] || '0px';
			}, this).join(' ');
		}
		var result = this.style[property];
		if (!result || property == 'zIndex'){
			if (Element.ShortStyles.hasOwnProperty(property)){
				result = [];
				for (var s in Element.ShortStyles[property]) result.push(this.getStyle(s));
				return result.join(' ');
			}
			result = this.getComputedStyle(property);
		}
		if (hasBackgroundPositionXY && /^backgroundPosition[XY]?$/.test(property)){
			return result.replace(/(top|right|bottom|left)/g, function(position){
				return namedPositions[position];
			}) || '0px';
		}
		if (!result && property == 'backgroundPosition') return '0px 0px';
		if (result){
			result = String(result);
			var color = result.match(/rgba?\([\d\s,]+\)/);
			if (color) result = result.replace(color[0], color[0].rgbToHex());
		}
		if (!hasGetComputedStyle && !this.style[property]){
			if ((/^(height|width)$/).test(property) && !(/px$/.test(result))){
				var values = (property == 'width') ? ['left', 'right'] : ['top', 'bottom'], size = 0;
				values.each(function(value){
					size += this.getStyle('border-' + value + '-width').toInt() + this.getStyle('padding-' + value).toInt();
				}, this);
				return this['offset' + property.capitalize()] - size + 'px';
			}
			if ((/^border(.+)Width|margin|padding/).test(property) && isNaN(parseFloat(result))){
				return '0px';
			}
		}
		//<ltIE9>
		if (returnsBordersInWrongOrder && /^border(Top|Right|Bottom|Left)?$/.test(property) && /^#/.test(result)){
			return result.replace(/^(.+)\s(.+)\s(.+)$/, '$2 $3 $1');
		}
		//</ltIE9>

		return result;
	},

	setStyles: function(styles){
		for (var style in styles) this.setStyle(style, styles[style]);
		return this;
	},

	getStyles: function(){
		var result = {};
		Array.flatten(arguments).each(function(key){
			result[key] = this.getStyle(key);
		}, this);
		return result;
	}

});

Element.Styles = {
	left: '@px', top: '@px', bottom: '@px', right: '@px',
	width: '@px', height: '@px', maxWidth: '@px', maxHeight: '@px', minWidth: '@px', minHeight: '@px',
	backgroundColor: 'rgb(@, @, @)', backgroundSize: '@px', backgroundPosition: '@px @px', color: 'rgb(@, @, @)',
	fontSize: '@px', letterSpacing: '@px', lineHeight: '@px', clip: 'rect(@px @px @px @px)',
	margin: '@px @px @px @px', padding: '@px @px @px @px', border: '@px @ rgb(@, @, @) @px @ rgb(@, @, @) @px @ rgb(@, @, @)',
	borderWidth: '@px @px @px @px', borderStyle: '@ @ @ @', borderColor: 'rgb(@, @, @) rgb(@, @, @) rgb(@, @, @) rgb(@, @, @)',
	zIndex: '@', 'zoom': '@', fontWeight: '@', textIndent: '@px', opacity: '@', borderRadius: '@px @px @px @px'
};

//<1.3compat>

Element.implement({

	setOpacity: function(value){
		setOpacity(this, value);
		return this;
	},

	getOpacity: function(){
		return getOpacity(this);
	}

});

Element.Properties.opacity = {

	set: function(opacity){
		setOpacity(this, opacity);
		setVisibility(this, opacity);
	},

	get: function(){
		return getOpacity(this);
	}

};

//</1.3compat>

//<1.2compat>

Element.Styles = new Hash(Element.Styles);

//</1.2compat>

Element.ShortStyles = {margin: {}, padding: {}, border: {}, borderWidth: {}, borderStyle: {}, borderColor: {}};

['Top', 'Right', 'Bottom', 'Left'].each(function(direction){
	var Short = Element.ShortStyles;
	var All = Element.Styles;
	['margin', 'padding'].each(function(style){
		var sd = style + direction;
		Short[style][sd] = All[sd] = '@px';
	});
	var bd = 'border' + direction;
	Short.border[bd] = All[bd] = '@px @ rgb(@, @, @)';
	var bdw = bd + 'Width', bds = bd + 'Style', bdc = bd + 'Color';
	Short[bd] = {};
	Short.borderWidth[bdw] = Short[bd][bdw] = All[bdw] = '@px';
	Short.borderStyle[bds] = Short[bd][bds] = All[bds] = '@';
	Short.borderColor[bdc] = Short[bd][bdc] = All[bdc] = 'rgb(@, @, @)';
});

if (hasBackgroundPositionXY) Element.ShortStyles.backgroundPosition = {backgroundPositionX: '@', backgroundPositionY: '@'};
})();

/*
---

name: Element.Dimensions

description: Contains methods to work with size, scroll, or positioning of Elements and the window object.

license: MIT-style license.

credits:
  - Element positioning based on the [qooxdoo](http://qooxdoo.org/) code and smart browser fixes, [LGPL License](http://www.gnu.org/licenses/lgpl.html).
  - Viewport dimensions based on [YUI](http://developer.yahoo.com/yui/) code, [BSD License](http://developer.yahoo.com/yui/license.html).

requires: [Element, Element.Style]

provides: [Element.Dimensions]

...
*/

(function(){

var element = document.createElement('div'),
	child = document.createElement('div');
element.style.height = '0';
element.appendChild(child);
var brokenOffsetParent = (child.offsetParent === element);
element = child = null;

var heightComponents = ['height', 'paddingTop', 'paddingBottom', 'borderTopWidth', 'borderBottomWidth'],
	widthComponents = ['width', 'paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'];

var svgCalculateSize = function(el){

	var gCS = window.getComputedStyle(el),
		bounds = {x: 0, y: 0};

	heightComponents.each(function(css){
		bounds.y += parseFloat(gCS[css]);
	});
	widthComponents.each(function(css){
		bounds.x += parseFloat(gCS[css]);
	});
	return bounds;
};

var isOffset = function(el){
	return styleString(el, 'position') != 'static' || isBody(el);
};

var isOffsetStatic = function(el){
	return isOffset(el) || (/^(?:table|td|th)$/i).test(el.tagName);
};

Element.implement({

	scrollTo: function(x, y){
		if (isBody(this)){
			this.getWindow().scrollTo(x, y);
		} else {
			this.scrollLeft = x;
			this.scrollTop = y;
		}
		return this;
	},

	getSize: function(){
		if (isBody(this)) return this.getWindow().getSize();

		//<ltIE9>
		// This if clause is because IE8- cannot calculate getBoundingClientRect of elements with visibility hidden.
		if (!window.getComputedStyle) return {x: this.offsetWidth, y: this.offsetHeight};
		//</ltIE9>

		// This svg section under, calling `svgCalculateSize()`, can be removed when FF fixed the svg size bug.
		// Bug info: https://bugzilla.mozilla.org/show_bug.cgi?id=530985
		if (this.get('tag') == 'svg') return svgCalculateSize(this);
		
		try {
			var bounds = this.getBoundingClientRect();
			return {x: bounds.width, y: bounds.height};
		} catch(e) {
			return {x: 0, y: 0};
		}
	},

	getScrollSize: function(){
		if (isBody(this)) return this.getWindow().getScrollSize();
		return {x: this.scrollWidth, y: this.scrollHeight};
	},

	getScroll: function(){
		if (isBody(this)) return this.getWindow().getScroll();
		return {x: this.scrollLeft, y: this.scrollTop};
	},

	getScrolls: function(){
		var element = this.parentNode, position = {x: 0, y: 0};
		while (element && !isBody(element)){
			position.x += element.scrollLeft;
			position.y += element.scrollTop;
			element = element.parentNode;
		}
		return position;
	},

	getOffsetParent: brokenOffsetParent ? function(){
		var element = this;
		if (isBody(element) || styleString(element, 'position') == 'fixed') return null;

		var isOffsetCheck = (styleString(element, 'position') == 'static') ? isOffsetStatic : isOffset;
		while ((element = element.parentNode)){
			if (isOffsetCheck(element)) return element;
		}
		return null;
	} : function(){
		var element = this;
		if (isBody(element) || styleString(element, 'position') == 'fixed') return null;

		try {
			return element.offsetParent;
		} catch(e){}
		return null;
	},

	getOffsets: function(){
		var hasGetBoundingClientRect = this.getBoundingClientRect;
//<1.4compat>
		hasGetBoundingClientRect = hasGetBoundingClientRect && !Browser.Platform.ios
//</1.4compat>
		if (hasGetBoundingClientRect){
			var bound = this.getBoundingClientRect(),
				html = document.id(this.getDocument().documentElement),
				htmlScroll = html.getScroll(),
				elemScrolls = this.getScrolls(),
				isFixed = (styleString(this, 'position') == 'fixed');

			return {
				x: bound.left.toFloat() + elemScrolls.x + ((isFixed) ? 0 : htmlScroll.x) - html.clientLeft,
				y: bound.top.toFloat() + elemScrolls.y + ((isFixed) ? 0 : htmlScroll.y) - html.clientTop
			};
		}

		var element = this, position = {x: 0, y: 0};
		if (isBody(this)) return position;

		while (element && !isBody(element)){
			position.x += element.offsetLeft;
			position.y += element.offsetTop;
//<1.4compat>
			if (Browser.firefox){
				if (!borderBox(element)){
					position.x += leftBorder(element);
					position.y += topBorder(element);
				}
				var parent = element.parentNode;
				if (parent && styleString(parent, 'overflow') != 'visible'){
					position.x += leftBorder(parent);
					position.y += topBorder(parent);
				}
			} else if (element != this && Browser.safari){
				position.x += leftBorder(element);
				position.y += topBorder(element);
			}
//</1.4compat>
			element = element.offsetParent;
		}
//<1.4compat>
		if (Browser.firefox && !borderBox(this)){
			position.x -= leftBorder(this);
			position.y -= topBorder(this);
		}
//</1.4compat>
		return position;
	},

	getPosition: function(relative){
		var offset = this.getOffsets(),
			scroll = this.getScrolls();
		var position = {
			x: offset.x - scroll.x,
			y: offset.y - scroll.y
		};

		if (relative && (relative = document.id(relative))){
			var relativePosition = relative.getPosition();
			return {x: position.x - relativePosition.x - leftBorder(relative), y: position.y - relativePosition.y - topBorder(relative)};
		}
		return position;
	},

	getCoordinates: function(element){
		if (isBody(this)) return this.getWindow().getCoordinates();
		var position = this.getPosition(element),
			size = this.getSize();
		var obj = {
			left: position.x,
			top: position.y,
			width: size.x,
			height: size.y
		};
		obj.right = obj.left + obj.width;
		obj.bottom = obj.top + obj.height;
		return obj;
	},

	computePosition: function(obj){
		return {
			left: obj.x - styleNumber(this, 'margin-left'),
			top: obj.y - styleNumber(this, 'margin-top')
		};
	},

	setPosition: function(obj){
		return this.setStyles(this.computePosition(obj));
	}

});


[Document, Window].invoke('implement', {

	getSize: function(){
		var doc = getCompatElement(this);
		return {x: doc.clientWidth, y: doc.clientHeight};
	},

	getScroll: function(){
		var win = this.getWindow(), doc = getCompatElement(this);
		return {x: win.pageXOffset || doc.scrollLeft, y: win.pageYOffset || doc.scrollTop};
	},

	getScrollSize: function(){
		var doc = getCompatElement(this),
			min = this.getSize(),
			body = this.getDocument().body;

		return {x: Math.max(doc.scrollWidth, body.scrollWidth, min.x), y: Math.max(doc.scrollHeight, body.scrollHeight, min.y)};
	},

	getPosition: function(){
		return {x: 0, y: 0};
	},

	getCoordinates: function(){
		var size = this.getSize();
		return {top: 0, left: 0, bottom: size.y, right: size.x, height: size.y, width: size.x};
	}

});

// private methods

var styleString = Element.getComputedStyle;

function styleNumber(element, style){
	return styleString(element, style).toInt() || 0;
}

//<1.4compat>
function borderBox(element){
	return styleString(element, '-moz-box-sizing') == 'border-box';
}
//</1.4compat>

function topBorder(element){
	return styleNumber(element, 'border-top-width');
}

function leftBorder(element){
	return styleNumber(element, 'border-left-width');
}

function isBody(element){
	return (/^(?:body|html)$/i).test(element.tagName);
}

function getCompatElement(element){
	var doc = element.getDocument();
	return (!doc.compatMode || doc.compatMode == 'CSS1Compat') ? doc.html : doc.body;
}

})();

//aliases
Element.alias({position: 'setPosition'}); //compatability

[Window, Document, Element].invoke('implement', {

	getHeight: function(){
		return this.getSize().y;
	},

	getWidth: function(){
		return this.getSize().x;
	},

	getScrollTop: function(){
		return this.getScroll().y;
	},

	getScrollLeft: function(){
		return this.getScroll().x;
	},

	getScrollHeight: function(){
		return this.getScrollSize().y;
	},

	getScrollWidth: function(){
		return this.getScrollSize().x;
	},

	getTop: function(){
		return this.getPosition().y;
	},

	getLeft: function(){
		return this.getPosition().x;
	}

});

/*
---

name: Fx

description: Contains the basic animation logic to be extended by all other Fx Classes.

license: MIT-style license.

requires: [Chain, Events, Options]

provides: Fx

...
*/

(function(){

var Fx = this.Fx = new Class({

	Implements: [Chain, Events, Options],

	options: {
		/*
		onStart: nil,
		onCancel: nil,
		onComplete: nil,
		*/
		fps: 60,
		unit: false,
		duration: 500,
		frames: null,
		frameSkip: true,
		link: 'ignore'
	},

	initialize: function(options){
		this.subject = this.subject || this;
		this.setOptions(options);
	},

	getTransition: function(){
		return function(p){
			return -(Math.cos(Math.PI * p) - 1) / 2;
		};
	},

	step: function(now){
		if (this.options.frameSkip){
			var diff = (this.time != null) ? (now - this.time) : 0, frames = diff / this.frameInterval;
			this.time = now;
			this.frame += frames;
		} else {
			this.frame++;
		}

		if (this.frame < this.frames){
			var delta = this.transition(this.frame / this.frames);
			this.set(this.compute(this.from, this.to, delta));
		} else {
			this.frame = this.frames;
			this.set(this.compute(this.from, this.to, 1));
			this.stop();
		}
	},

	set: function(now){
		return now;
	},

	compute: function(from, to, delta){
		return Fx.compute(from, to, delta);
	},

	check: function(){
		if (!this.isRunning()) return true;
		switch (this.options.link){
			case 'cancel': this.cancel(); return true;
			case 'chain': this.chain(this.caller.pass(arguments, this)); return false;
		}
		return false;
	},

	start: function(from, to){
		if (!this.check(from, to)) return this;
		this.from = from;
		this.to = to;
		this.frame = (this.options.frameSkip) ? 0 : -1;
		this.time = null;
		this.transition = this.getTransition();
		var frames = this.options.frames, fps = this.options.fps, duration = this.options.duration;
		this.duration = Fx.Durations[duration] || duration.toInt();
		this.frameInterval = 1000 / fps;
		this.frames = frames || Math.round(this.duration / this.frameInterval);
		this.fireEvent('start', this.subject);
		pushInstance.call(this, fps);
		return this;
	},

	stop: function(){
		if (this.isRunning()){
			this.time = null;
			pullInstance.call(this, this.options.fps);
			if (this.frames == this.frame){
				this.fireEvent('complete', this.subject);
				if (!this.callChain()) this.fireEvent('chainComplete', this.subject);
			} else {
				this.fireEvent('stop', this.subject);
			}
		}
		return this;
	},

	cancel: function(){
		if (this.isRunning()){
			this.time = null;
			pullInstance.call(this, this.options.fps);
			this.frame = this.frames;
			this.fireEvent('cancel', this.subject).clearChain();
		}
		return this;
	},

	pause: function(){
		if (this.isRunning()){
			this.time = null;
			pullInstance.call(this, this.options.fps);
		}
		return this;
	},

	resume: function(){
		if (this.isPaused()) pushInstance.call(this, this.options.fps);
		return this;
	},

	isRunning: function(){
		var list = instances[this.options.fps];
		return list && list.contains(this);
	},

	isPaused: function(){
		return (this.frame < this.frames) && !this.isRunning();
	}

});

Fx.compute = function(from, to, delta){
	return (to - from) * delta + from;
};

Fx.Durations = {'short': 250, 'normal': 500, 'long': 1000};

// global timers

var instances = {}, timers = {};

var loop = function(){
	var now = Date.now();
	for (var i = this.length; i--;){
		var instance = this[i];
		if (instance) instance.step(now);
	}
};

var pushInstance = function(fps){
	var list = instances[fps] || (instances[fps] = []);
	list.push(this);
	if (!timers[fps]) timers[fps] = loop.periodical(Math.round(1000 / fps), list);
};

var pullInstance = function(fps){
	var list = instances[fps];
	if (list){
		list.erase(this);
		if (!list.length && timers[fps]){
			delete instances[fps];
			timers[fps] = clearInterval(timers[fps]);
		}
	}
};

})();

/*
---

name: Fx.CSS

description: Contains the CSS animation logic. Used by Fx.Tween, Fx.Morph, Fx.Elements.

license: MIT-style license.

requires: [Fx, Element.Style]

provides: Fx.CSS

...
*/

Fx.CSS = new Class({

	Extends: Fx,

	//prepares the base from/to object

	prepare: function(element, property, values){
		values = Array.from(values);
		var from = values[0], to = values[1];
		if (to == null){
			to = from;
			from = element.getStyle(property);
			var unit = this.options.unit;
			// adapted from: https://github.com/ryanmorr/fx/blob/master/fx.js#L299
			if (unit && from && typeof from == 'string' && from.slice(-unit.length) != unit && parseFloat(from) != 0){
				element.setStyle(property, to + unit);
				var value = element.getComputedStyle(property);
				// IE and Opera support pixelLeft or pixelWidth
				if (!(/px$/.test(value))){
					value = element.style[('pixel-' + property).camelCase()];
					if (value == null){
						// adapted from Dean Edwards' http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
						var left = element.style.left;
						element.style.left = to + unit;
						value = element.style.pixelLeft;
						element.style.left = left;
					}
				}
				from = (to || 1) / (parseFloat(value) || 1) * (parseFloat(from) || 0);
				element.setStyle(property, from + unit);
			}
		}
		return {from: this.parse(from), to: this.parse(to)};
	},

	//parses a value into an array

	parse: function(value){
		value = Function.from(value)();
		value = (typeof value == 'string') ? value.split(' ') : Array.from(value);
		return value.map(function(val){
			val = String(val);
			var found = false;
			Object.each(Fx.CSS.Parsers, function(parser, key){
				if (found) return;
				var parsed = parser.parse(val);
				if (parsed || parsed === 0) found = {value: parsed, parser: parser};
			});
			found = found || {value: val, parser: Fx.CSS.Parsers.String};
			return found;
		});
	},

	//computes by a from and to prepared objects, using their parsers.

	compute: function(from, to, delta){
		var computed = [];
		(Math.min(from.length, to.length)).times(function(i){
			computed.push({value: from[i].parser.compute(from[i].value, to[i].value, delta), parser: from[i].parser});
		});
		computed.$family = Function.from('fx:css:value');
		return computed;
	},

	//serves the value as settable

	serve: function(value, unit){
		if (typeOf(value) != 'fx:css:value') value = this.parse(value);
		var returned = [];
		value.each(function(bit){
			returned = returned.concat(bit.parser.serve(bit.value, unit));
		});
		return returned;
	},

	//renders the change to an element

	render: function(element, property, value, unit){
		element.setStyle(property, this.serve(value, unit));
	},

	//searches inside the page css to find the values for a selector

	search: function(selector){
		if (Fx.CSS.Cache[selector]) return Fx.CSS.Cache[selector];
		var to = {}, selectorTest = new RegExp('^' + selector.escapeRegExp() + '$');

		var searchStyles = function(rules){
			Array.each(rules, function(rule, i){
				if (rule.media){
					searchStyles(rule.rules || rule.cssRules);
					return;
				}
				if (!rule.style) return;
				var selectorText = (rule.selectorText) ? rule.selectorText.replace(/^\w+/, function(m){
					return m.toLowerCase();
				}) : null;
				if (!selectorText || !selectorTest.test(selectorText)) return;
				Object.each(Element.Styles, function(value, style){
					if (!rule.style[style] || Element.ShortStyles[style]) return;
					value = String(rule.style[style]);
					to[style] = ((/^rgb/).test(value)) ? value.rgbToHex() : value;
				});
			});
		};

		Array.each(document.styleSheets, function(sheet, j){
			var href = sheet.href;
			if (href && href.indexOf('://') > -1 && href.indexOf(document.domain) == -1) return;
			var rules = sheet.rules || sheet.cssRules;
			searchStyles(rules);
		});
		return Fx.CSS.Cache[selector] = to;
	}

});

Fx.CSS.Cache = {};

Fx.CSS.Parsers = {

	Color: {
		parse: function(value){
			if (value.match(/^#[0-9a-f]{3,6}$/i)) return value.hexToRgb(true);
			return ((value = value.match(/(\d+),\s*(\d+),\s*(\d+)/))) ? [value[1], value[2], value[3]] : false;
		},
		compute: function(from, to, delta){
			return from.map(function(value, i){
				return Math.round(Fx.compute(from[i], to[i], delta));
			});
		},
		serve: function(value){
			return value.map(Number);
		}
	},

	Number: {
		parse: parseFloat,
		compute: Fx.compute,
		serve: function(value, unit){
			return (unit) ? value + unit : value;
		}
	},

	String: {
		parse: Function.from(false),
		compute: function(zero, one){
			return one;
		},
		serve: function(zero){
			return zero;
		}
	}

};

//<1.2compat>

Fx.CSS.Parsers = new Hash(Fx.CSS.Parsers);

//</1.2compat>

/*
---

name: Fx.Morph

description: Formerly Fx.Styles, effect to transition any number of CSS properties for an element using an object of rules, or CSS based selector rules.

license: MIT-style license.

requires: Fx.CSS

provides: Fx.Morph

...
*/

Fx.Morph = new Class({

	Extends: Fx.CSS,

	initialize: function(element, options){
		this.element = this.subject = document.id(element);
		this.parent(options);
	},

	set: function(now){
		if (typeof now == 'string') now = this.search(now);
		for (var p in now) this.render(this.element, p, now[p], this.options.unit);
		return this;
	},

	compute: function(from, to, delta){
		var now = {};
		for (var p in from) now[p] = this.parent(from[p], to[p], delta);
		return now;
	},

	start: function(properties){
		if (!this.check(properties)) return this;
		if (typeof properties == 'string') properties = this.search(properties);
		var from = {}, to = {};
		for (var p in properties){
			var parsed = this.prepare(this.element, p, properties[p]);
			from[p] = parsed.from;
			to[p] = parsed.to;
		}
		return this.parent(from, to);
	}

});

Element.Properties.morph = {

	set: function(options){
		this.get('morph').cancel().setOptions(options);
		return this;
	},

	get: function(){
		var morph = this.retrieve('morph');
		if (!morph){
			morph = new Fx.Morph(this, {link: 'cancel'});
			this.store('morph', morph);
		}
		return morph;
	}

};

Element.implement({

	morph: function(props){
		this.get('morph').start(props);
		return this;
	}

});

/*
---

name: Fx.Transitions

description: Contains a set of advanced transitions to be used with any of the Fx Classes.

license: MIT-style license.

credits:
  - Easing Equations by Robert Penner, <http://www.robertpenner.com/easing/>, modified and optimized to be used with MooTools.

requires: Fx

provides: Fx.Transitions

...
*/

Fx.implement({

	getTransition: function(){
		var trans = this.options.transition || Fx.Transitions.Sine.easeInOut;
		if (typeof trans == 'string'){
			var data = trans.split(':');
			trans = Fx.Transitions;
			trans = trans[data[0]] || trans[data[0].capitalize()];
			if (data[1]) trans = trans['ease' + data[1].capitalize() + (data[2] ? data[2].capitalize() : '')];
		}
		return trans;
	}

});

Fx.Transition = function(transition, params){
	params = Array.from(params);
	var easeIn = function(pos){
		return transition(pos, params);
	};
	return Object.append(easeIn, {
		easeIn: easeIn,
		easeOut: function(pos){
			return 1 - transition(1 - pos, params);
		},
		easeInOut: function(pos){
			return (pos <= 0.5 ? transition(2 * pos, params) : (2 - transition(2 * (1 - pos), params))) / 2;
		}
	});
};

Fx.Transitions = {

	linear: function(zero){
		return zero;
	}

};

//<1.2compat>

Fx.Transitions = new Hash(Fx.Transitions);

//</1.2compat>

Fx.Transitions.extend = function(transitions){
	for (var transition in transitions) Fx.Transitions[transition] = new Fx.Transition(transitions[transition]);
};

Fx.Transitions.extend({

	Pow: function(p, x){
		return Math.pow(p, x && x[0] || 6);
	},

	Expo: function(p){
		return Math.pow(2, 8 * (p - 1));
	},

	Circ: function(p){
		return 1 - Math.sin(Math.acos(p));
	},

	Sine: function(p){
		return 1 - Math.cos(p * Math.PI / 2);
	},

	Back: function(p, x){
		x = x && x[0] || 1.618;
		return Math.pow(p, 2) * ((x + 1) * p - x);
	},

	Bounce: function(p){
		var value;
		for (var a = 0, b = 1; 1; a += b, b /= 2){
			if (p >= (7 - 4 * a) / 11){
				value = b * b - Math.pow((11 - 6 * a - 11 * p) / 4, 2);
				break;
			}
		}
		return value;
	},

	Elastic: function(p, x){
		return Math.pow(2, 10 * --p) * Math.cos(20 * p * Math.PI * (x && x[0] || 1) / 3);
	}

});

['Quad', 'Cubic', 'Quart', 'Quint'].each(function(transition, i){
	Fx.Transitions[transition] = new Fx.Transition(function(p){
		return Math.pow(p, i + 2);
	});
});

/*
---

name: Fx.Tween

description: Formerly Fx.Style, effect to transition any CSS property for an element.

license: MIT-style license.

requires: Fx.CSS

provides: [Fx.Tween, Element.fade, Element.highlight]

...
*/

Fx.Tween = new Class({

	Extends: Fx.CSS,

	initialize: function(element, options){
		this.element = this.subject = document.id(element);
		this.parent(options);
	},

	set: function(property, now){
		if (arguments.length == 1){
			now = property;
			property = this.property || this.options.property;
		}
		this.render(this.element, property, now, this.options.unit);
		return this;
	},

	start: function(property, from, to){
		if (!this.check(property, from, to)) return this;
		var args = Array.flatten(arguments);
		this.property = this.options.property || args.shift();
		var parsed = this.prepare(this.element, this.property, args);
		return this.parent(parsed.from, parsed.to);
	}

});

Element.Properties.tween = {

	set: function(options){
		this.get('tween').cancel().setOptions(options);
		return this;
	},

	get: function(){
		var tween = this.retrieve('tween');
		if (!tween){
			tween = new Fx.Tween(this, {link: 'cancel'});
			this.store('tween', tween);
		}
		return tween;
	}

};

Element.implement({

	tween: function(property, from, to){
		this.get('tween').start(property, from, to);
		return this;
	},

	fade: function(how){
		var fade = this.get('tween'), method, args = ['opacity'].append(arguments), toggle;
		if (args[1] == null) args[1] = 'toggle';
		switch (args[1]){
			case 'in': method = 'start'; args[1] = 1; break;
			case 'out': method = 'start'; args[1] = 0; break;
			case 'show': method = 'set'; args[1] = 1; break;
			case 'hide': method = 'set'; args[1] = 0; break;
			case 'toggle':
				var flag = this.retrieve('fade:flag', this.getStyle('opacity') == 1);
				method = 'start';
				args[1] = flag ? 0 : 1;
				this.store('fade:flag', !flag);
				toggle = true;
			break;
			default: method = 'start';
		}
		if (!toggle) this.eliminate('fade:flag');
		fade[method].apply(fade, args);
		var to = args[args.length - 1];
		
		if (method == 'set'){
			this.setStyle('visibility', to == 0 ? 'hidden' : 'visible');
		} else if (to != 0){
			if (fade.$chain.length){
				fade.chain(function(){
					this.element.setStyle('visibility', 'visible');
					this.callChain();
				});
			} else {
				this.setStyle('visibility', 'visible');
			}
		} else {
			fade.chain(function(){
				if (this.element.getStyle('opacity')) return;
				this.element.setStyle('visibility', 'hidden');
				this.callChain();
			});
		}

		return this;
	},

	highlight: function(start, end){
		if (!end){
			end = this.retrieve('highlight:original', this.getStyle('background-color'));
			end = (end == 'transparent') ? '#fff' : end;
		}
		var tween = this.get('tween');
		tween.start('background-color', start || '#ffff88', end).chain(function(){
			this.setStyle('background-color', this.retrieve('highlight:original'));
			tween.callChain();
		}.bind(this));
		return this;
	}

});

/*
---

name: Request

description: Powerful all purpose Request Class. Uses XMLHTTPRequest.

license: MIT-style license.

requires: [Object, Element, Chain, Events, Options, Browser]

provides: Request

...
*/

(function(){

var empty = function(){},
	progressSupport = ('onprogress' in new Browser.Request);

var Request = this.Request = new Class({

	Implements: [Chain, Events, Options],

	options: {/*
		onRequest: function(){},
		onLoadstart: function(event, xhr){},
		onProgress: function(event, xhr){},
		onComplete: function(){},
		onCancel: function(){},
		onSuccess: function(responseText, responseXML){},
		onFailure: function(xhr){},
		onException: function(headerName, value){},
		onTimeout: function(){},
		user: '',
		password: '',
		withCredentials: false,*/
		url: '',
		data: '',
		headers: {
			'X-Requested-With': 'XMLHttpRequest',
			'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
		},
		async: true,
		format: false,
		method: 'post',
		link: 'ignore',
		isSuccess: null,
		emulation: true,
		urlEncoded: true,
		encoding: 'utf-8',
		evalScripts: false,
		evalResponse: false,
		timeout: 0,
		noCache: false
	},

	initialize: function(options){
		this.xhr = new Browser.Request();
		this.setOptions(options);
		this.headers = this.options.headers;
	},

	onStateChange: function(){
		var xhr = this.xhr;
		if (xhr.readyState != 4 || !this.running) return;
		this.running = false;
		this.status = 0;
		Function.attempt(function(){
			var status = xhr.status;
			this.status = (status == 1223) ? 204 : status;
		}.bind(this));
		xhr.onreadystatechange = empty;
		if (progressSupport) xhr.onprogress = xhr.onloadstart = empty;
		if (this.timer){
			clearTimeout(this.timer);
			delete this.timer;
		}

		this.response = {text: this.xhr.responseText || '', xml: this.xhr.responseXML};
		if (this.options.isSuccess.call(this, this.status))
			this.success(this.response.text, this.response.xml);
		else
			this.failure();
	},

	isSuccess: function(){
		var status = this.status;
		return (status >= 200 && status < 300);
	},

	isRunning: function(){
		return !!this.running;
	},

	processScripts: function(text){
		if (this.options.evalResponse || (/(ecma|java)script/).test(this.getHeader('Content-type'))) return Browser.exec(text);
		return text.stripScripts(this.options.evalScripts);
	},

	success: function(text, xml){
		this.onSuccess(this.processScripts(text), xml);
	},

	onSuccess: function(){
		this.fireEvent('complete', arguments).fireEvent('success', arguments).callChain();
	},

	failure: function(){
		this.onFailure();
	},

	onFailure: function(){
		this.fireEvent('complete').fireEvent('failure', this.xhr);
	},

	loadstart: function(event){
		this.fireEvent('loadstart', [event, this.xhr]);
	},

	progress: function(event){
		this.fireEvent('progress', [event, this.xhr]);
	},

	timeout: function(){
		this.fireEvent('timeout', this.xhr);
	},

	setHeader: function(name, value){
		this.headers[name] = value;
		return this;
	},

	getHeader: function(name){
		return Function.attempt(function(){
			return this.xhr.getResponseHeader(name);
		}.bind(this));
	},

	check: function(){
		if (!this.running) return true;
		switch (this.options.link){
			case 'cancel': this.cancel(); return true;
			case 'chain': this.chain(this.caller.pass(arguments, this)); return false;
		}
		return false;
	},

	send: function(options){
		if (!this.check(options)) return this;

		this.options.isSuccess = this.options.isSuccess || this.isSuccess;
		this.running = true;

		var type = typeOf(options);
		if (type == 'string' || type == 'element') options = {data: options};

		var old = this.options;
		options = Object.append({data: old.data, url: old.url, method: old.method}, options);
		var data = options.data, url = String(options.url), method = options.method.toLowerCase();

		switch (typeOf(data)){
			case 'element': data = document.id(data).toQueryString(); break;
			case 'object': case 'hash': data = Object.toQueryString(data);
		}

		if (this.options.format){
			var format = 'format=' + this.options.format;
			data = (data) ? format + '&' + data : format;
		}

		if (this.options.emulation && !['get', 'post'].contains(method)){
			var _method = '_method=' + method;
			data = (data) ? _method + '&' + data : _method;
			method = 'post';
		}

		if (this.options.urlEncoded && ['post', 'put'].contains(method)){
			var encoding = (this.options.encoding) ? '; charset=' + this.options.encoding : '';
			this.headers['Content-type'] = 'application/x-www-form-urlencoded' + encoding;
		}

		if (!url) url = document.location.pathname;

		var trimPosition = url.lastIndexOf('/');
		if (trimPosition > -1 && (trimPosition = url.indexOf('#')) > -1) url = url.substr(0, trimPosition);

		if (this.options.noCache)
			url += (url.indexOf('?') > -1 ? '&' : '?') + String.uniqueID();

		if (data && (method == 'get' || method == 'delete')){
			url += (url.indexOf('?') > -1 ? '&' : '?') + data;
			data = null;
		}

		var xhr = this.xhr;
		if (progressSupport){
			xhr.onloadstart = this.loadstart.bind(this);
			xhr.onprogress = this.progress.bind(this);
		}

		xhr.open(method.toUpperCase(), url, this.options.async, this.options.user, this.options.password);
		if ((/*<1.4compat>*/this.options.user || /*</1.4compat>*/this.options.withCredentials) && 'withCredentials' in xhr) xhr.withCredentials = true;

		xhr.onreadystatechange = this.onStateChange.bind(this);

		Object.each(this.headers, function(value, key){
			try {
				xhr.setRequestHeader(key, value);
			} catch (e){
				this.fireEvent('exception', [key, value]);
			}
		}, this);

		this.fireEvent('request');
		xhr.send(data);
		if (!this.options.async) this.onStateChange();
		else if (this.options.timeout) this.timer = this.timeout.delay(this.options.timeout, this);
		return this;
	},

	cancel: function(){
		if (!this.running) return this;
		this.running = false;
		var xhr = this.xhr;
		xhr.abort();
		if (this.timer){
			clearTimeout(this.timer);
			delete this.timer;
		}
		xhr.onreadystatechange = empty;
		if (progressSupport) xhr.onprogress = xhr.onloadstart = empty;
		this.xhr = new Browser.Request();
		this.fireEvent('cancel');
		return this;
	}

});

var methods = {};
['get', 'post', 'put', 'delete', 'patch', 'head', 'GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD'].each(function(method){
	methods[method] = function(data){
		var object = {
			method: method
		};
		if (data != null) object.data = data;
		return this.send(object);
	};
});

Request.implement(methods);

Element.Properties.send = {

	set: function(options){
		var send = this.get('send').cancel();
		send.setOptions(options);
		return this;
	},

	get: function(){
		var send = this.retrieve('send');
		if (!send){
			send = new Request({
				data: this, link: 'cancel', method: this.get('method') || 'post', url: this.get('action')
			});
			this.store('send', send);
		}
		return send;
	}

};

Element.implement({

	send: function(url){
		var sender = this.get('send');
		sender.send({data: this, url: url || sender.options.url});
		return this;
	}

});

})();

/*
---

name: Request.HTML

description: Extends the basic Request Class with additional methods for interacting with HTML responses.

license: MIT-style license.

requires: [Element, Request]

provides: Request.HTML

...
*/

Request.HTML = new Class({

	Extends: Request,

	options: {
		update: false,
		append: false,
		evalScripts: true,
		filter: false,
		headers: {
			Accept: 'text/html, application/xml, text/xml, */*'
		}
	},

	success: function(text){
		var options = this.options, response = this.response;

		response.html = text.stripScripts(function(script){
			response.javascript = script;
		});

		var match = response.html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
		if (match) response.html = match[1];
		var temp = new Element('div').set('html', response.html);

		response.tree = temp.childNodes;
		response.elements = temp.getElements(options.filter || '*');

		if (options.filter) response.tree = response.elements;
		if (options.update){
			var update = document.id(options.update).empty();
			if (options.filter) update.adopt(response.elements);
			else update.set('html', response.html);
		} else if (options.append){
			var append = document.id(options.append);
			if (options.filter) response.elements.reverse().inject(append);
			else append.adopt(temp.getChildren());
		}
		if (options.evalScripts) Browser.exec(response.javascript);

		this.onSuccess(response.tree, response.elements, response.html, response.javascript);
	}

});

Element.Properties.load = {

	set: function(options){
		var load = this.get('load').cancel();
		load.setOptions(options);
		return this;
	},

	get: function(){
		var load = this.retrieve('load');
		if (!load){
			load = new Request.HTML({data: this, link: 'cancel', update: this, method: 'get'});
			this.store('load', load);
		}
		return load;
	}

};

Element.implement({

	load: function(){
		this.get('load').send(Array.link(arguments, {data: Type.isObject, url: Type.isString}));
		return this;
	}

});

/*
---

name: JSON

description: JSON encoder and decoder.

license: MIT-style license.

SeeAlso: <http://www.json.org/>

requires: [Array, String, Number, Function]

provides: JSON

...
*/

if (typeof JSON == 'undefined') this.JSON = {};

//<1.2compat>

JSON = new Hash({
	stringify: JSON.stringify,
	parse: JSON.parse
});

//</1.2compat>

(function(){

var special = {'\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '"' : '\\"', '\\': '\\\\'};

var escape = function(chr){
	return special[chr] || '\\u' + ('0000' + chr.charCodeAt(0).toString(16)).slice(-4);
};

JSON.validate = function(string){
	string = string.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
					replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
					replace(/(?:^|:|,)(?:\s*\[)+/g, '');

	return (/^[\],:{}\s]*$/).test(string);
};

JSON.encode = JSON.stringify ? function(obj){
	return JSON.stringify(obj);
} : function(obj){
	if (obj && obj.toJSON) obj = obj.toJSON();

	switch (typeOf(obj)){
		case 'string':
			return '"' + obj.replace(/[\x00-\x1f\\"]/g, escape) + '"';
		case 'array':
			return '[' + obj.map(JSON.encode).clean() + ']';
		case 'object': case 'hash':
			var string = [];
			Object.each(obj, function(value, key){
				var json = JSON.encode(value);
				if (json) string.push(JSON.encode(key) + ':' + json);
			});
			return '{' + string + '}';
		case 'number': case 'boolean': return '' + obj;
		case 'null': return 'null';
	}

	return null;
};

JSON.secure = true;
//<1.4compat>
JSON.secure = false;
//</1.4compat>

JSON.decode = function(string, secure){
	if (!string || typeOf(string) != 'string') return null;
    
	if (secure == null) secure = JSON.secure; 
	if (secure){
		if (JSON.parse) return JSON.parse(string);
		if (!JSON.validate(string)) throw new Error('JSON could not decode the input; security is enabled and the value is not secure.');
	}

	return eval('(' + string + ')');
};

})();

/*
---

name: Request.JSON

description: Extends the basic Request Class with additional methods for sending and receiving JSON data.

license: MIT-style license.

requires: [Request, JSON]

provides: Request.JSON

...
*/

Request.JSON = new Class({

	Extends: Request,

	options: {
		/*onError: function(text, error){},*/
		secure: true
	},

	initialize: function(options){
		this.parent(options);
		Object.append(this.headers, {
			'Accept': 'application/json',
			'X-Request': 'JSON'
		});
	},

	success: function(text){
		var json;
		try {
			json = this.response.json = JSON.decode(text, this.options.secure);
		} catch (error){
			this.fireEvent('error', [text, error]);
			return;
		}
		if (json == null) this.onFailure();
		else this.onSuccess(json, text);
	}

});

/*
---

name: Cookie

description: Class for creating, reading, and deleting browser Cookies.

license: MIT-style license.

credits:
  - Based on the functions by Peter-Paul Koch (http://quirksmode.org).

requires: [Options, Browser]

provides: Cookie

...
*/

var Cookie = new Class({

	Implements: Options,

	options: {
		path: '/',
		domain: false,
		duration: false,
		secure: false,
		document: document,
		encode: true,
		httpOnly: false
	},

	initialize: function(key, options){
		this.key = key;
		this.setOptions(options);
	},

	write: function(value){
		if (this.options.encode) value = encodeURIComponent(value);
		if (this.options.domain) value += '; domain=' + this.options.domain;
		if (this.options.path) value += '; path=' + this.options.path;
		if (this.options.duration){
			var date = new Date();
			date.setTime(date.getTime() + this.options.duration * 24 * 60 * 60 * 1000);
			value += '; expires=' + date.toGMTString();
		}
		if (this.options.secure) value += '; secure';
		if (this.options.httpOnly) value += '; HttpOnly';
		this.options.document.cookie = this.key + '=' + value;
		return this;
	},

	read: function(){
		var value = this.options.document.cookie.match('(?:^|;)\\s*' + this.key.escapeRegExp() + '=([^;]*)');
		return (value) ? decodeURIComponent(value[1]) : null;
	},

	dispose: function(){
		new Cookie(this.key, Object.merge({}, this.options, {duration: -1})).write('');
		return this;
	}

});

Cookie.write = function(key, value, options){
	return new Cookie(key, options).write(value);
};

Cookie.read = function(key){
	return new Cookie(key).read();
};

Cookie.dispose = function(key, options){
	return new Cookie(key, options).dispose();
};

/*
---

name: DOMReady

description: Contains the custom event domready.

license: MIT-style license.

requires: [Browser, Element, Element.Event]

provides: [DOMReady, DomReady]

...
*/

(function(window, document){

var ready,
	loaded,
	checks = [],
	shouldPoll,
	timer,
	testElement = document.createElement('div');

var domready = function(){
	clearTimeout(timer);
	if (!ready) {
		Browser.loaded = ready = true;
		document.removeListener('DOMContentLoaded', domready).removeListener('readystatechange', check);
		document.fireEvent('domready');
		window.fireEvent('domready');
	}
	// cleanup scope vars
	document = window = testElement = null;
};

var check = function(){
	for (var i = checks.length; i--;) if (checks[i]()){
		domready();
		return true;
	}
	return false;
};

var poll = function(){
	clearTimeout(timer);
	if (!check()) timer = setTimeout(poll, 10);
};

document.addListener('DOMContentLoaded', domready);

/*<ltIE8>*/
// doScroll technique by Diego Perini http://javascript.nwbox.com/IEContentLoaded/
// testElement.doScroll() throws when the DOM is not ready, only in the top window
var doScrollWorks = function(){
	try {
		testElement.doScroll();
		return true;
	} catch (e){}
	return false;
};
// If doScroll works already, it can't be used to determine domready
//   e.g. in an iframe
if (testElement.doScroll && !doScrollWorks()){
	checks.push(doScrollWorks);
	shouldPoll = true;
}
/*</ltIE8>*/

if (document.readyState) checks.push(function(){
	var state = document.readyState;
	return (state == 'loaded' || state == 'complete');
});

if ('onreadystatechange' in document) document.addListener('readystatechange', check);
else shouldPoll = true;

if (shouldPoll) poll();

Element.Events.domready = {
	onAdd: function(fn){
		if (ready) fn.call(this);
	}
};

// Make sure that domready fires before load
Element.Events.load = {
	base: 'load',
	onAdd: function(fn){
		if (loaded && this == window) fn.call(this);
	},
	condition: function(){
		if (this == window){
			domready();
			delete Element.Events.load;
		}
		return true;
	}
};

// This is based on the custom load event
window.addEvent('load', function(){
	loaded = true;
});

})(window, document);
/*
---

script: More.js

name: More

description: MooTools More

license: MIT-style license

authors:
  - Guillermo Rauch
  - Thomas Aylott
  - Scott Kyle
  - Arian Stolwijk
  - Tim Wienk
  - Christoph Pojer
  - Aaron Newton
  - Jacob Thornton

requires:
  - Core/MooTools

provides: [MooTools.More]

...
*/

MooTools.More = {
	version: '1.5.2',
	build: 'facdf0458d10fd214aa9f5fa71935a23a772cc48'
};
/*
---

script: Class.Binds.js

name: Class.Binds

description: Automagically binds specified methods in a class to the instance of the class.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Class
  - MooTools.More

provides: [Class.Binds]

...
*/

Class.Mutators.Binds = function(binds){
	if (!this.prototype.initialize) this.implement('initialize', function(){});
	return Array.from(binds).concat(this.prototype.Binds || []);
};

Class.Mutators.initialize = function(initialize){
	return function(){
		Array.from(this.Binds).each(function(name){
			var original = this[name];
			if (original) this[name] = original.bind(this);
		}, this);
		return initialize.apply(this, arguments);
	};
};
/*
---

script: Class.Occlude.js

name: Class.Occlude

description: Prevents a class from being applied to a DOM element twice.

license: MIT-style license.

authors:
  - Aaron Newton

requires:
  - Core/Class
  - Core/Element
  - MooTools.More

provides: [Class.Occlude]

...
*/

Class.Occlude = new Class({

	occlude: function(property, element){
		element = document.id(element || this.element);
		var instance = element.retrieve(property || this.property);
		if (instance && !this.occluded)
			return (this.occluded = instance);

		this.occluded = false;
		element.store(property || this.property, this);
		return this.occluded;
	}

});
/*
---

script: Element.Forms.js

name: Element.Forms

description: Extends the Element native object to include methods useful in managing inputs.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Element
  - String.Extras
  - MooTools.More

provides: [Element.Forms]

...
*/

Element.implement({

	tidy: function(){
		this.set('value', this.get('value').tidy());
	},

	getTextInRange: function(start, end){
		return this.get('value').substring(start, end);
	},

	getSelectedText: function(){
		if (this.setSelectionRange) return this.getTextInRange(this.getSelectionStart(), this.getSelectionEnd());
		return document.selection.createRange().text;
	},

	getSelectedRange: function(){
		if (this.selectionStart != null){
			return {
				start: this.selectionStart,
				end: this.selectionEnd
			};
		}

		var pos = {
			start: 0,
			end: 0
		};
		var range = this.getDocument().selection.createRange();
		if (!range || range.parentElement() != this) return pos;
		var duplicate = range.duplicate();

		if (this.type == 'text'){
			pos.start = 0 - duplicate.moveStart('character', -100000);
			pos.end = pos.start + range.text.length;
		} else {
			var value = this.get('value');
			var offset = value.length;
			duplicate.moveToElementText(this);
			duplicate.setEndPoint('StartToEnd', range);
			if (duplicate.text.length) offset -= value.match(/[\n\r]*$/)[0].length;
			pos.end = offset - duplicate.text.length;
			duplicate.setEndPoint('StartToStart', range);
			pos.start = offset - duplicate.text.length;
		}
		return pos;
	},

	getSelectionStart: function(){
		return this.getSelectedRange().start;
	},

	getSelectionEnd: function(){
		return this.getSelectedRange().end;
	},

	setCaretPosition: function(pos){
		if (pos == 'end') pos = this.get('value').length;
		this.selectRange(pos, pos);
		return this;
	},

	getCaretPosition: function(){
		return this.getSelectedRange().start;
	},

	selectRange: function(start, end){
		if (this.setSelectionRange){
			this.focus();
			this.setSelectionRange(start, end);
		} else {
			var value = this.get('value');
			var diff = value.substr(start, end - start).replace(/\r/g, '').length;
			start = value.substr(0, start).replace(/\r/g, '').length;
			var range = this.createTextRange();
			range.collapse(true);
			range.moveEnd('character', start + diff);
			range.moveStart('character', start);
			range.select();
		}
		return this;
	},

	insertAtCursor: function(value, select){
		var pos = this.getSelectedRange();
		var text = this.get('value');
		this.set('value', text.substring(0, pos.start) + value + text.substring(pos.end, text.length));
		if (select !== false) this.selectRange(pos.start, pos.start + value.length);
		else this.setCaretPosition(pos.start + value.length);
		return this;
	},

	insertAroundCursor: function(options, select){
		options = Object.append({
			before: '',
			defaultMiddle: '',
			after: ''
		}, options);

		var value = this.getSelectedText() || options.defaultMiddle;
		var pos = this.getSelectedRange();
		var text = this.get('value');

		if (pos.start == pos.end){
			this.set('value', text.substring(0, pos.start) + options.before + value + options.after + text.substring(pos.end, text.length));
			this.selectRange(pos.start + options.before.length, pos.end + options.before.length + value.length);
		} else {
			var current = text.substring(pos.start, pos.end);
			this.set('value', text.substring(0, pos.start) + options.before + current + options.after + text.substring(pos.end, text.length));
			var selStart = pos.start + options.before.length;
			if (select !== false) this.selectRange(selStart, selStart + current.length);
			else this.setCaretPosition(selStart + text.length);
		}
		return this;
	}

});
/*
---

script: Element.Shortcuts.js

name: Element.Shortcuts

description: Extends the Element native object to include some shortcut methods.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Element.Style
  - MooTools.More

provides: [Element.Shortcuts]

...
*/

Element.implement({

	isDisplayed: function(){
		return this.getStyle('display') != 'none';
	},

	isVisible: function(){
		var w = this.offsetWidth,
			h = this.offsetHeight;
		return (w == 0 && h == 0) ? false : (w > 0 && h > 0) ? true : this.style.display != 'none';
	},

	toggle: function(){
		return this[this.isDisplayed() ? 'hide' : 'show']();
	},

	hide: function(){
		var d;
		try {
			//IE fails here if the element is not in the dom
			d = this.getStyle('display');
		} catch(e){}
		if (d == 'none') return this;
		return this.store('element:_originalDisplay', d || '').setStyle('display', 'none');
	},

	show: function(display){
		if (!display && this.isDisplayed()) return this;
		display = display || this.retrieve('element:_originalDisplay') || 'block';
		return this.setStyle('display', (display == 'none') ? 'block' : display);
	},

	swapClass: function(remove, add){
		return this.removeClass(remove).addClass(add);
	}

});

Document.implement({

	clearSelection: function(){
		if (window.getSelection){
			var selection = window.getSelection();
			if (selection && selection.removeAllRanges) selection.removeAllRanges();
		} else if (document.selection && document.selection.empty){
			try {
				//IE fails here if selected element is not in dom
				document.selection.empty();
			} catch(e){}
		}
	}

});
/*
---

script: Element.Measure.js

name: Element.Measure

description: Extends the Element native object to include methods useful in measuring dimensions.

credits: "Element.measure / .expose methods by Daniel Steigerwald License: MIT-style license. Copyright: Copyright (c) 2008 Daniel Steigerwald, daniel.steigerwald.cz"

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Element.Style
  - Core/Element.Dimensions
  - MooTools.More

provides: [Element.Measure]

...
*/

(function(){

var getStylesList = function(styles, planes){
	var list = [];
	Object.each(planes, function(directions){
		Object.each(directions, function(edge){
			styles.each(function(style){
				list.push(style + '-' + edge + (style == 'border' ? '-width' : ''));
			});
		});
	});
	return list;
};

var calculateEdgeSize = function(edge, styles){
	var total = 0;
	Object.each(styles, function(value, style){
		if (style.test(edge)) total = total + value.toInt();
	});
	return total;
};

var isVisible = function(el){
	return !!(!el || el.offsetHeight || el.offsetWidth);
};


Element.implement({

	measure: function(fn){
		if (isVisible(this)) return fn.call(this);
		var parent = this.getParent(),
			toMeasure = [];
		while (!isVisible(parent) && parent != document.body){
			toMeasure.push(parent.expose());
			parent = parent.getParent();
		}
		var restore = this.expose(),
			result = fn.call(this);
		restore();
		toMeasure.each(function(restore){
			restore();
		});
		return result;
	},

	expose: function(){
		if (this.getStyle('display') != 'none') return function(){};
		var before = this.style.cssText;
		this.setStyles({
			display: 'block',
			position: 'absolute',
			visibility: 'hidden'
		});
		return function(){
			this.style.cssText = before;
		}.bind(this);
	},

	getDimensions: function(options){
		options = Object.merge({computeSize: false}, options);
		var dim = {x: 0, y: 0};

		var getSize = function(el, options){
			return (options.computeSize) ? el.getComputedSize(options) : el.getSize();
		};

		var parent = this.getParent('body');

		if (parent && this.getStyle('display') == 'none'){
			dim = this.measure(function(){
				return getSize(this, options);
			});
		} else if (parent){
			try { //safari sometimes crashes here, so catch it
				dim = getSize(this, options);
			}catch(e){}
		}

		return Object.append(dim, (dim.x || dim.x === 0) ? {
				width: dim.x,
				height: dim.y
			} : {
				x: dim.width,
				y: dim.height
			}
		);
	},

	getComputedSize: function(options){
		//<1.2compat>
		//legacy support for my stupid spelling error
		if (options && options.plains) options.planes = options.plains;
		//</1.2compat>

		options = Object.merge({
			styles: ['padding','border'],
			planes: {
				height: ['top','bottom'],
				width: ['left','right']
			},
			mode: 'both'
		}, options);

		var styles = {},
			size = {width: 0, height: 0},
			dimensions;

		if (options.mode == 'vertical'){
			delete size.width;
			delete options.planes.width;
		} else if (options.mode == 'horizontal'){
			delete size.height;
			delete options.planes.height;
		}

		getStylesList(options.styles, options.planes).each(function(style){
			styles[style] = this.getStyle(style).toInt();
		}, this);

		Object.each(options.planes, function(edges, plane){

			var capitalized = plane.capitalize(),
				style = this.getStyle(plane);

			if (style == 'auto' && !dimensions) dimensions = this.getDimensions();

			style = styles[plane] = (style == 'auto') ? dimensions[plane] : style.toInt();
			size['total' + capitalized] = style;

			edges.each(function(edge){
				var edgesize = calculateEdgeSize(edge, styles);
				size['computed' + edge.capitalize()] = edgesize;
				size['total' + capitalized] += edgesize;
			});

		}, this);

		return Object.append(size, styles);
	}

});

})();
/*
---

script: Element.Pin.js

name: Element.Pin

description: Extends the Element native object to include the pin method useful for fixed positioning for elements.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Element.Event
  - Core/Element.Dimensions
  - Core/Element.Style
  - MooTools.More

provides: [Element.Pin]

...
*/

(function(){
	var supportsPositionFixed = false,
		supportTested = false;

	var testPositionFixed = function(){
		var test = new Element('div').setStyles({
			position: 'fixed',
			top: 0,
			right: 0
		}).inject(document.body);
		supportsPositionFixed = (test.offsetTop === 0);
		test.dispose();
		supportTested = true;
	};

	Element.implement({

		pin: function(enable, forceScroll){
			if (!supportTested) testPositionFixed();
			if (this.getStyle('display') == 'none') return this;

			var pinnedPosition,
				scroll = window.getScroll(),
				parent,
				scrollFixer;

			if (enable !== false){
				pinnedPosition = this.getPosition();
				if (!this.retrieve('pin:_pinned')) {
					var currentPosition = {
						top: pinnedPosition.y - scroll.y,
						left: pinnedPosition.x - scroll.x,
						margin: '0px',
						padding: '0px'
					};

					if (supportsPositionFixed && !forceScroll){
						this.setStyle('position', 'fixed').setStyles(currentPosition);
					} else {

						parent = this.getOffsetParent();
						var position = this.getPosition(parent),
							styles = this.getStyles('left', 'top');

						if (parent && styles.left == 'auto' || styles.top == 'auto') this.setPosition(position);
						if (this.getStyle('position') == 'static') this.setStyle('position', 'absolute');

						position = {
							x: styles.left.toInt() - scroll.x,
							y: styles.top.toInt() - scroll.y
						};

						scrollFixer = function(){
							if (!this.retrieve('pin:_pinned')) return;
							var scroll = window.getScroll();
							this.setStyles({
								left: position.x + scroll.x,
								top: position.y + scroll.y
							});
						}.bind(this);

						this.store('pin:_scrollFixer', scrollFixer);
						window.addEvent('scroll', scrollFixer);
					}
					this.store('pin:_pinned', true);
				}

			} else {
				if (!this.retrieve('pin:_pinned')) return this;

				parent = this.getParent();
				var offsetParent = (parent.getComputedStyle('position') != 'static' ? parent : parent.getOffsetParent());

				pinnedPosition = this.getPosition();

				this.store('pin:_pinned', false);
				scrollFixer = this.retrieve('pin:_scrollFixer');
				if (!scrollFixer){
					this.setStyles({
						position: 'absolute',
						top: pinnedPosition.y + scroll.y,
						left: pinnedPosition.x + scroll.x
					});
				} else {
					this.store('pin:_scrollFixer', null);
					window.removeEvent('scroll', scrollFixer);
				}
				this.removeClass('isPinned');
			}
			return this;
		},

		unpin: function(){
			return this.pin(false);
		},

		togglePin: function(){
			return this.pin(!this.retrieve('pin:_pinned'));
		}

	});

//<1.2compat>
Element.alias('togglepin', 'togglePin');
//</1.2compat>

})();
/*
---

script: Element.Position.js

name: Element.Position

description: Extends the Element native object to include methods useful positioning elements relative to others.

license: MIT-style license

authors:
  - Aaron Newton
  - Jacob Thornton

requires:
  - Core/Options
  - Core/Element.Dimensions
  - Element.Measure

provides: [Element.Position]

...
*/

(function(original){

var local = Element.Position = {

	options: {/*
		edge: false,
		returnPos: false,
		minimum: {x: 0, y: 0},
		maximum: {x: 0, y: 0},
		relFixedPosition: false,
		ignoreMargins: false,
		ignoreScroll: false,
		allowNegative: false,*/
		relativeTo: document.body,
		position: {
			x: 'center', //left, center, right
			y: 'center' //top, center, bottom
		},
		offset: {x: 0, y: 0}
	},

	getOptions: function(element, options){
		options = Object.merge({}, local.options, options);
		local.setPositionOption(options);
		local.setEdgeOption(options);
		local.setOffsetOption(element, options);
		local.setDimensionsOption(element, options);
		return options;
	},

	setPositionOption: function(options){
		options.position = local.getCoordinateFromValue(options.position);
	},

	setEdgeOption: function(options){
		var edgeOption = local.getCoordinateFromValue(options.edge);
		options.edge = edgeOption ? edgeOption :
			(options.position.x == 'center' && options.position.y == 'center') ? {x: 'center', y: 'center'} :
			{x: 'left', y: 'top'};
	},

	setOffsetOption: function(element, options){
		var parentOffset = {x: 0, y: 0};
		var parentScroll = {x: 0, y: 0};
		var offsetParent = element.measure(function(){
			return document.id(this.getOffsetParent());
		});

		if (!offsetParent || offsetParent == element.getDocument().body) return;

		parentScroll = offsetParent.getScroll();
		parentOffset = offsetParent.measure(function(){
			var position = this.getPosition();
			if (this.getStyle('position') == 'fixed'){
				var scroll = window.getScroll();
				position.x += scroll.x;
				position.y += scroll.y;
			}
			return position;
		});

		options.offset = {
			parentPositioned: offsetParent != document.id(options.relativeTo),
			x: options.offset.x - parentOffset.x + parentScroll.x,
			y: options.offset.y - parentOffset.y + parentScroll.y
		};
	},

	setDimensionsOption: function(element, options){
		options.dimensions = element.getDimensions({
			computeSize: true,
			styles: ['padding', 'border', 'margin']
		});
	},

	getPosition: function(element, options){
		var position = {};
		options = local.getOptions(element, options);
		var relativeTo = document.id(options.relativeTo) || document.body;

		local.setPositionCoordinates(options, position, relativeTo);
		if (options.edge) local.toEdge(position, options);

		var offset = options.offset;
		position.left = ((position.x >= 0 || offset.parentPositioned || options.allowNegative) ? position.x : 0).toInt();
		position.top = ((position.y >= 0 || offset.parentPositioned || options.allowNegative) ? position.y : 0).toInt();

		local.toMinMax(position, options);

		if (options.relFixedPosition || relativeTo.getStyle('position') == 'fixed') local.toRelFixedPosition(relativeTo, position);
		if (options.ignoreScroll) local.toIgnoreScroll(relativeTo, position);
		if (options.ignoreMargins) local.toIgnoreMargins(position, options);

		position.left = Math.ceil(position.left);
		position.top = Math.ceil(position.top);
		delete position.x;
		delete position.y;

		return position;
	},

	setPositionCoordinates: function(options, position, relativeTo){
		var offsetY = options.offset.y,
			offsetX = options.offset.x,
			calc = (relativeTo == document.body) ? window.getScroll() : relativeTo.getPosition(),
			top = calc.y,
			left = calc.x,
			winSize = window.getSize();

		switch(options.position.x){
			case 'left': position.x = left + offsetX; break;
			case 'right': position.x = left + offsetX + relativeTo.offsetWidth; break;
			default: position.x = left + ((relativeTo == document.body ? winSize.x : relativeTo.offsetWidth) / 2) + offsetX; break;
		}

		switch(options.position.y){
			case 'top': position.y = top + offsetY; break;
			case 'bottom': position.y = top + offsetY + relativeTo.offsetHeight; break;
			default: position.y = top + ((relativeTo == document.body ? winSize.y : relativeTo.offsetHeight) / 2) + offsetY; break;
		}
	},

	toMinMax: function(position, options){
		var xy = {left: 'x', top: 'y'}, value;
		['minimum', 'maximum'].each(function(minmax){
			['left', 'top'].each(function(lr){
				value = options[minmax] ? options[minmax][xy[lr]] : null;
				if (value != null && ((minmax == 'minimum') ? position[lr] < value : position[lr] > value)) position[lr] = value;
			});
		});
	},

	toRelFixedPosition: function(relativeTo, position){
		var winScroll = window.getScroll();
		position.top += winScroll.y;
		position.left += winScroll.x;
	},

	toIgnoreScroll: function(relativeTo, position){
		var relScroll = relativeTo.getScroll();
		position.top -= relScroll.y;
		position.left -= relScroll.x;
	},

	toIgnoreMargins: function(position, options){
		position.left += options.edge.x == 'right'
			? options.dimensions['margin-right']
			: (options.edge.x != 'center'
				? -options.dimensions['margin-left']
				: -options.dimensions['margin-left'] + ((options.dimensions['margin-right'] + options.dimensions['margin-left']) / 2));

		position.top += options.edge.y == 'bottom'
			? options.dimensions['margin-bottom']
			: (options.edge.y != 'center'
				? -options.dimensions['margin-top']
				: -options.dimensions['margin-top'] + ((options.dimensions['margin-bottom'] + options.dimensions['margin-top']) / 2));
	},

	toEdge: function(position, options){
		var edgeOffset = {},
			dimensions = options.dimensions,
			edge = options.edge;

		switch(edge.x){
			case 'left': edgeOffset.x = 0; break;
			case 'right': edgeOffset.x = -dimensions.x - dimensions.computedRight - dimensions.computedLeft; break;
			// center
			default: edgeOffset.x = -(Math.round(dimensions.totalWidth / 2)); break;
		}

		switch(edge.y){
			case 'top': edgeOffset.y = 0; break;
			case 'bottom': edgeOffset.y = -dimensions.y - dimensions.computedTop - dimensions.computedBottom; break;
			// center
			default: edgeOffset.y = -(Math.round(dimensions.totalHeight / 2)); break;
		}

		position.x += edgeOffset.x;
		position.y += edgeOffset.y;
	},

	getCoordinateFromValue: function(option){
		if (typeOf(option) != 'string') return option;
		option = option.toLowerCase();

		return {
			x: option.test('left') ? 'left'
				: (option.test('right') ? 'right' : 'center'),
			y: option.test(/upper|top/) ? 'top'
				: (option.test('bottom') ? 'bottom' : 'center')
		};
	}

};

Element.implement({

	position: function(options){
		if (options && (options.x != null || options.y != null)){
			return (original ? original.apply(this, arguments) : this);
		}
		var position = this.setStyle('position', 'absolute').calculatePosition(options);
		return (options && options.returnPos) ? position : this.setStyles(position);
	},

	calculatePosition: function(options){
		return local.getPosition(this, options);
	}

});

})(Element.prototype.position);
/*
---

script: Fx.Scroll.js

name: Fx.Scroll

description: Effect to smoothly scroll any element, including the window.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Fx
  - Core/Element.Event
  - Core/Element.Dimensions
  - MooTools.More

provides: [Fx.Scroll]

...
*/

(function(){

Fx.Scroll = new Class({

	Extends: Fx,

	options: {
		offset: {x: 0, y: 0},
		wheelStops: true
	},

	initialize: function(element, options){
		this.element = this.subject = document.id(element);
		this.parent(options);

		if (typeOf(this.element) != 'element') this.element = document.id(this.element.getDocument().body);

		if (this.options.wheelStops){
			var stopper = this.element,
				cancel = this.cancel.pass(false, this);
			this.addEvent('start', function(){
				stopper.addEvent('mousewheel', cancel);
			}, true);
			this.addEvent('complete', function(){
				stopper.removeEvent('mousewheel', cancel);
			}, true);
		}
	},

	set: function(){
		var now = Array.flatten(arguments);
		this.element.scrollTo(now[0], now[1]);
		return this;
	},

	compute: function(from, to, delta){
		return [0, 1].map(function(i){
			return Fx.compute(from[i], to[i], delta);
		});
	},

	start: function(x, y){
		if (!this.check(x, y)) return this;
		var scroll = this.element.getScroll();
		return this.parent([scroll.x, scroll.y], [x, y]);
	},

	calculateScroll: function(x, y){
		var element = this.element,
			scrollSize = element.getScrollSize(),
			scroll = element.getScroll(),
			size = element.getSize(),
			offset = this.options.offset,
			values = {x: x, y: y};

		for (var z in values){
			if (!values[z] && values[z] !== 0) values[z] = scroll[z];
			if (typeOf(values[z]) != 'number') values[z] = scrollSize[z] - size[z];
			values[z] += offset[z];
		}

		return [values.x, values.y];
	},

	toTop: function(){
		return this.start.apply(this, this.calculateScroll(false, 0));
	},

	toLeft: function(){
		return this.start.apply(this, this.calculateScroll(0, false));
	},

	toRight: function(){
		return this.start.apply(this, this.calculateScroll('right', false));
	},

	toBottom: function(){
		return this.start.apply(this, this.calculateScroll(false, 'bottom'));
	},

	toElement: function(el, axes){
		axes = axes ? Array.from(axes) : ['x', 'y'];
		var scroll = isBody(this.element) ? {x: 0, y: 0} : this.element.getScroll();
		var position = Object.map(document.id(el).getPosition(this.element), function(value, axis){
			return axes.contains(axis) ? value + scroll[axis] : false;
		});
		return this.start.apply(this, this.calculateScroll(position.x, position.y));
	},

	toElementEdge: function(el, axes, offset){
		axes = axes ? Array.from(axes) : ['x', 'y'];
		el = document.id(el);
		var to = {},
			position = el.getPosition(this.element),
			size = el.getSize(),
			scroll = this.element.getScroll(),
			containerSize = this.element.getSize(),
			edge = {
				x: position.x + size.x,
				y: position.y + size.y
			};

		['x', 'y'].each(function(axis){
			if (axes.contains(axis)){
				if (edge[axis] > scroll[axis] + containerSize[axis]) to[axis] = edge[axis] - containerSize[axis];
				if (position[axis] < scroll[axis]) to[axis] = position[axis];
			}
			if (to[axis] == null) to[axis] = scroll[axis];
			if (offset && offset[axis]) to[axis] = to[axis] + offset[axis];
		}, this);

		if (to.x != scroll.x || to.y != scroll.y) this.start(to.x, to.y);
		return this;
	},

	toElementCenter: function(el, axes, offset){
		axes = axes ? Array.from(axes) : ['x', 'y'];
		el = document.id(el);
		var to = {},
			position = el.getPosition(this.element),
			size = el.getSize(),
			scroll = this.element.getScroll(),
			containerSize = this.element.getSize();

		['x', 'y'].each(function(axis){
			if (axes.contains(axis)){
				to[axis] = position[axis] - (containerSize[axis] - size[axis]) / 2;
			}
			if (to[axis] == null) to[axis] = scroll[axis];
			if (offset && offset[axis]) to[axis] = to[axis] + offset[axis];
		}, this);

		if (to.x != scroll.x || to.y != scroll.y) this.start(to.x, to.y);
		return this;
	}

});

//<1.2compat>
Fx.Scroll.implement({
	scrollToCenter: function(){
		return this.toElementCenter.apply(this, arguments);
	},
	scrollIntoView: function(){
		return this.toElementEdge.apply(this, arguments);
	}
});
//</1.2compat>

function isBody(element){
	return (/^(?:body|html)$/i).test(element.tagName);
}

})();
/*
---

script: Fx.Slide.js

name: Fx.Slide

description: Effect to slide an element in and out of view.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Fx
  - Core/Element.Style
  - MooTools.More

provides: [Fx.Slide]

...
*/

Fx.Slide = new Class({

	Extends: Fx,

	options: {
		mode: 'vertical',
		wrapper: false,
		hideOverflow: true,
		resetHeight: false
	},

	initialize: function(element, options){
		element = this.element = this.subject = document.id(element);
		this.parent(options);
		options = this.options;

		var wrapper = element.retrieve('wrapper'),
			styles = element.getStyles('margin', 'position', 'overflow');

		if (options.hideOverflow) styles = Object.append(styles, {overflow: 'hidden'});
		if (options.wrapper) wrapper = document.id(options.wrapper).setStyles(styles);

		if (!wrapper) wrapper = new Element('div', {
			styles: styles
		}).wraps(element);

		element.store('wrapper', wrapper).setStyle('margin', 0);
		if (element.getStyle('overflow') == 'visible') element.setStyle('overflow', 'hidden');

		this.now = [];
		this.open = true;
		this.wrapper = wrapper;

		this.addEvent('complete', function(){
			this.open = (wrapper['offset' + this.layout.capitalize()] != 0);
			if (this.open && this.options.resetHeight) wrapper.setStyle('height', '');
		}, true);
	},

	vertical: function(){
		this.margin = 'margin-top';
		this.layout = 'height';
		this.offset = this.element.offsetHeight;
	},

	horizontal: function(){
		this.margin = 'margin-left';
		this.layout = 'width';
		this.offset = this.element.offsetWidth;
	},

	set: function(now){
		this.element.setStyle(this.margin, now[0]);
		this.wrapper.setStyle(this.layout, now[1]);
		return this;
	},

	compute: function(from, to, delta){
		return [0, 1].map(function(i){
			return Fx.compute(from[i], to[i], delta);
		});
	},

	start: function(how, mode){
		if (!this.check(how, mode)) return this;
		this[mode || this.options.mode]();

		var margin = this.element.getStyle(this.margin).toInt(),
			layout = this.wrapper.getStyle(this.layout).toInt(),
			caseIn = [[margin, layout], [0, this.offset]],
			caseOut = [[margin, layout], [-this.offset, 0]],
			start;

		switch (how){
			case 'in': start = caseIn; break;
			case 'out': start = caseOut; break;
			case 'toggle': start = (layout == 0) ? caseIn : caseOut;
		}
		return this.parent(start[0], start[1]);
	},

	slideIn: function(mode){
		return this.start('in', mode);
	},

	slideOut: function(mode){
		return this.start('out', mode);
	},

	hide: function(mode){
		this[mode || this.options.mode]();
		this.open = false;
		return this.set([-this.offset, 0]);
	},

	show: function(mode){
		this[mode || this.options.mode]();
		this.open = true;
		return this.set([0, this.offset]);
	},

	toggle: function(mode){
		return this.start('toggle', mode);
	}

});

Element.Properties.slide = {

	set: function(options){
		this.get('slide').cancel().setOptions(options);
		return this;
	},

	get: function(){
		var slide = this.retrieve('slide');
		if (!slide){
			slide = new Fx.Slide(this, {link: 'cancel'});
			this.store('slide', slide);
		}
		return slide;
	}

};

Element.implement({

	slide: function(how, mode){
		how = how || 'toggle';
		var slide = this.get('slide'), toggle;
		switch (how){
			case 'hide': slide.hide(mode); break;
			case 'show': slide.show(mode); break;
			case 'toggle':
				var flag = this.retrieve('slide:flag', slide.open);
				slide[flag ? 'slideOut' : 'slideIn'](mode);
				this.store('slide:flag', !flag);
				toggle = true;
			break;
			default: slide.start(how, mode);
		}
		if (!toggle) this.eliminate('slide:flag');
		return this;
	}

});
/*
---

script: Fx.SmoothScroll.js

name: Fx.SmoothScroll

description: Class for creating a smooth scrolling effect to all internal links on the page.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Slick.Finder
  - Fx.Scroll

provides: [Fx.SmoothScroll]

...
*/

/*<1.2compat>*/var SmoothScroll = /*</1.2compat>*/Fx.SmoothScroll = new Class({

	Extends: Fx.Scroll,

	options: {
		axes: ['x', 'y']
	},

	initialize: function(options, context){
		context = context || document;
		this.doc = context.getDocument();
		this.parent(this.doc, options);

		var win = context.getWindow(),
			location = win.location.href.match(/^[^#]*/)[0] + '#',
			links = $$(this.options.links || this.doc.links);

		links.each(function(link){
			if (link.href.indexOf(location) != 0) return;
			var anchor = link.href.substr(location.length);
			if (anchor) this.useLink(link, anchor);
		}, this);

		this.addEvent('complete', function(){
			win.location.hash = this.anchor;
			this.element.scrollTo(this.to[0], this.to[1]);
		}, true);
	},

	useLink: function(link, anchor){

		link.addEvent('click', function(event){
			var el = document.id(anchor) || this.doc.getElement('a[name=' + anchor + ']');
			if (!el) return;

			event.preventDefault();
			this.toElement(el, this.options.axes).chain(function(){
				this.fireEvent('scrolledTo', [link, el]);
			}.bind(this));

			this.anchor = anchor;

		}.bind(this));

		return this;
	}
});
/*
---

script: Assets.js

name: Assets

description: Provides methods to dynamically load JavaScript, CSS, and Image files into the document.

license: MIT-style license

authors:
  - Valerio Proietti

requires:
  - Core/Element.Event
  - MooTools.More

provides: [Assets]

...
*/
;(function(){

var Asset = this.Asset = {

	javascript: function(source, properties){
		if (!properties) properties = {};

		var script = new Element('script', {src: source, type: 'text/javascript'}),
			doc = properties.document || document,
			load = properties.onload || properties.onLoad;

		delete properties.onload;
		delete properties.onLoad;
		delete properties.document;

		if (load){
			if (!script.addEventListener){
				script.addEvent('readystatechange', function(){
					if (['loaded', 'complete'].contains(this.readyState)) load.call(this);
				});
			} else {
				script.addEvent('load', load);
			}
		}

		return script.set(properties).inject(doc.head);
	},

	css: function(source, properties){
		if (!properties) properties = {};

		var load = properties.onload || properties.onLoad,
			doc = properties.document || document,
			timeout = properties.timeout || 3000;

		['onload', 'onLoad', 'document'].each(function(prop){
			delete properties[prop];
		});

		var link = new Element('link', {
			type: 'text/css',
			rel: 'stylesheet',
			media: 'screen',
			href: source
		}).setProperties(properties).inject(doc.head);

		if (load){
			// based on article at http://www.yearofmoo.com/2011/03/cross-browser-stylesheet-preloading.html
			var loaded = false, retries = 0;
			var check = function(){
				var stylesheets = document.styleSheets;
				for (var i = 0; i < stylesheets.length; i++){
					var file = stylesheets[i];
					var owner = file.ownerNode ? file.ownerNode : file.owningElement;
					if (owner && owner == link){
						loaded = true;
						return load.call(link);
					}
				}
				retries++;
				if (!loaded && retries < timeout / 50) return setTimeout(check, 50);
			};
			setTimeout(check, 0);
		}
		return link;
	},

	image: function(source, properties){
		if (!properties) properties = {};

		var image = new Image(),
			element = document.id(image) || new Element('img');

		['load', 'abort', 'error'].each(function(name){
			var type = 'on' + name,
				cap = 'on' + name.capitalize(),
				event = properties[type] || properties[cap] || function(){};

			delete properties[cap];
			delete properties[type];

			image[type] = function(){
				if (!image) return;
				if (!element.parentNode){
					element.width = image.width;
					element.height = image.height;
				}
				image = image.onload = image.onabort = image.onerror = null;
				event.delay(1, element, element);
				element.fireEvent(name, element, 1);
			};
		});

		image.src = element.src = source;
		if (image && image.complete) image.onload.delay(1);
		return element.set(properties);
	},

	images: function(sources, options){
		sources = Array.from(sources);

		var fn = function(){},
			counter = 0;

		options = Object.merge({
			onComplete: fn,
			onProgress: fn,
			onError: fn,
			properties: {}
		}, options);

		return new Elements(sources.map(function(source, index){
			return Asset.image(source, Object.append(options.properties, {
				onload: function(){
					counter++;
					options.onProgress.call(this, counter, index, source);
					if (counter == sources.length) options.onComplete();
				},
				onerror: function(){
					counter++;
					options.onError.call(this, counter, index, source);
					if (counter == sources.length) options.onComplete();
				}
			}));
		}));
	}

};

})();
/*
---

name: Swiff

description: Wrapper for embedding SWF movies. Supports External Interface Communication.

license: MIT-style license.

credits:
  - Flash detection & Internet Explorer + Flash Player 9 fix inspired by SWFObject.

requires: [Core/Options, Core/Object, Core/Element]

provides: Swiff

...
*/

(function(){

var Swiff = this.Swiff = new Class({

	Implements: Options,

	options: {
		id: null,
		height: 1,
		width: 1,
		container: null,
		properties: {},
		params: {
			quality: 'high',
			allowScriptAccess: 'always',
			wMode: 'window',
			swLiveConnect: true
		},
		callBacks: {},
		vars: {}
	},

	toElement: function(){
		return this.object;
	},

	initialize: function(path, options){
		this.instance = 'Swiff_' + String.uniqueID();

		this.setOptions(options);
		options = this.options;
		var id = this.id = options.id || this.instance;
		var container = document.id(options.container);

		Swiff.CallBacks[this.instance] = {};

		var params = options.params, vars = options.vars, callBacks = options.callBacks;
		var properties = Object.append({height: options.height, width: options.width}, options.properties);

		var self = this;

		for (var callBack in callBacks){
			Swiff.CallBacks[this.instance][callBack] = (function(option){
				return function(){
					return option.apply(self.object, arguments);
				};
			})(callBacks[callBack]);
			vars[callBack] = 'Swiff.CallBacks.' + this.instance + '.' + callBack;
		}

		params.flashVars = Object.toQueryString(vars);
		if ('ActiveXObject' in window){
			properties.classid = 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000';
			params.movie = path;
		} else {
			properties.type = 'application/x-shockwave-flash';
		}
		properties.data = path;

		var build = '<object id="' + id + '"';
		for (var property in properties) build += ' ' + property + '="' + properties[property] + '"';
		build += '>';
		for (var param in params){
			if (params[param]) build += '<param name="' + param + '" value="' + params[param] + '" />';
		}
		build += '</object>';
		this.object = ((container) ? container.empty() : new Element('div')).set('html', build).firstChild;
	},

	replaces: function(element){
		element = document.id(element, true);
		element.parentNode.replaceChild(this.toElement(), element);
		return this;
	},

	inject: function(element){
		document.id(element, true).appendChild(this.toElement());
		return this;
	},

	remote: function(){
		return Swiff.remote.apply(Swiff, [this.toElement()].append(arguments));
	}

});

Swiff.CallBacks = {};

Swiff.remote = function(obj, fn){
	var rs = obj.CallFunction('<invoke name="' + fn + '" returntype="javascript">' + __flash__argumentsToXML(arguments, 2) + '</invoke>');
	return eval(rs);
};

})();
/*
---

script: IframeShim.js

name: IframeShim

description: Defines IframeShim, a class for obscuring select lists and flash objects in IE.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Element.Event
  - Core/Element.Style
  - Core/Options
  - Core/Events
  - Element.Position
  - Class.Occlude

provides: [IframeShim]

...
*/

(function(){

var browsers = false;
//<1.4compat>
browsers = Browser.ie6 || (Browser.firefox && Browser.version < 3 && Browser.Platform.mac);
//</1.4compat>

var IframeShim = this.IframeShim = new Class({

	Implements: [Options, Events, Class.Occlude],

	options: {
		className: 'iframeShim',
		src: 'javascript:false;document.write("");',
		display: false,
		zIndex: null,
		margin: 0,
		offset: {x: 0, y: 0},
		browsers: browsers
	},

	property: 'IframeShim',

	initialize: function(element, options){
		this.element = document.id(element);
		if (this.occlude()) return this.occluded;
		this.setOptions(options);
		this.makeShim();
		return this;
	},

	makeShim: function(){
		if (this.options.browsers){
			var zIndex = this.element.getStyle('zIndex').toInt();

			if (!zIndex){
				zIndex = 1;
				var pos = this.element.getStyle('position');
				if (pos == 'static' || !pos) this.element.setStyle('position', 'relative');
				this.element.setStyle('zIndex', zIndex);
			}
			zIndex = ((this.options.zIndex != null || this.options.zIndex === 0) && zIndex > this.options.zIndex) ? this.options.zIndex : zIndex - 1;
			if (zIndex < 0) zIndex = 1;
			this.shim = new Element('iframe', {
				src: this.options.src,
				scrolling: 'no',
				frameborder: 0,
				styles: {
					zIndex: zIndex,
					position: 'absolute',
					border: 'none',
					filter: 'progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0)'
				},
				'class': this.options.className
			}).store('IframeShim', this);
			var inject = (function(){
				this.shim.inject(this.element, 'after');
				this[this.options.display ? 'show' : 'hide']();
				this.fireEvent('inject');
			}).bind(this);
			if (!IframeShim.ready) window.addEvent('load', inject);
			else inject();
		} else {
			this.position = this.hide = this.show = this.dispose = Function.from(this);
		}
	},

	position: function(){
		if (!IframeShim.ready || !this.shim) return this;
		var size = this.element.measure(function(){
			return this.getSize();
		});
		if (this.options.margin != undefined){
			size.x = size.x - (this.options.margin * 2);
			size.y = size.y - (this.options.margin * 2);
			this.options.offset.x += this.options.margin;
			this.options.offset.y += this.options.margin;
		}
		this.shim.set({width: size.x, height: size.y}).position({
			relativeTo: this.element,
			offset: this.options.offset
		});
		return this;
	},

	hide: function(){
		if (this.shim) this.shim.setStyle('display', 'none');
		return this;
	},

	show: function(){
		if (this.shim) this.shim.setStyle('display', 'block');
		return this.position();
	},

	dispose: function(){
		if (this.shim) this.shim.dispose();
		return this;
	},

	destroy: function(){
		if (this.shim) this.shim.destroy();
		return this;
	}

});

})();

window.addEvent('load', function(){
	IframeShim.ready = true;
});
/*
---

script: Mask.js

name: Mask

description: Creates a mask element to cover another.

license: MIT-style license

authors:
  - Aaron Newton

requires:
  - Core/Options
  - Core/Events
  - Core/Element.Event
  - Class.Binds
  - Element.Position
  - IframeShim

provides: [Mask]

...
*/
(function(){

var Mask = this.Mask = new Class({

	Implements: [Options, Events],

	Binds: ['position'],

	options: {/*
		onShow: function(){},
		onHide: function(){},
		onDestroy: function(){},
		onClick: function(event){},
		inject: {
			where: 'after',
			target: null,
		},
		hideOnClick: false,
		id: null,
		destroyOnHide: false,*/
		style: {},
		'class': 'mask',
		maskMargins: false,
		useIframeShim: true,
		iframeShimOptions: {}
	},

	initialize: function(target, options){
		this.target = document.id(target) || document.id(document.body);
		this.target.store('mask', this);
		this.setOptions(options);
		this.render();
		this.inject();
	},

	render: function(){
		this.element = new Element('div', {
			'class': this.options['class'],
			id: this.options.id || 'mask-' + String.uniqueID(),
			styles: Object.merge({}, this.options.style, {
				display: 'none'
			}),
			events: {
				click: function(event){
					this.fireEvent('click', event);
					if (this.options.hideOnClick) this.hide();
				}.bind(this)
			}
		});

		this.hidden = true;
	},

	toElement: function(){
		return this.element;
	},

	inject: function(target, where){
		where = where || (this.options.inject ? this.options.inject.where : '') || (this.target == document.body ? 'inside' : 'after');
		target = target || (this.options.inject && this.options.inject.target) || this.target;

		this.element.inject(target, where);

		if (this.options.useIframeShim){
			this.shim = new IframeShim(this.element, this.options.iframeShimOptions);

			this.addEvents({
				show: this.shim.show.bind(this.shim),
				hide: this.shim.hide.bind(this.shim),
				destroy: this.shim.destroy.bind(this.shim)
			});
		}
	},

	position: function(){
		this.resize(this.options.width, this.options.height);

		this.element.position({
			relativeTo: this.target,
			position: 'topLeft',
			ignoreMargins: !this.options.maskMargins,
			ignoreScroll: this.target == document.body
		});

		return this;
	},

	resize: function(x, y){
		var opt = {
			styles: ['padding', 'border']
		};
		if (this.options.maskMargins) opt.styles.push('margin');

		var dim = this.target.getComputedSize(opt);
		if (this.target == document.body){
			this.element.setStyles({width: 0, height: 0});
			var win = window.getScrollSize();
			if (dim.totalHeight < win.y) dim.totalHeight = win.y;
			if (dim.totalWidth < win.x) dim.totalWidth = win.x;
		}
		this.element.setStyles({
			width: Array.pick([x, dim.totalWidth, dim.x]),
			height: Array.pick([y, dim.totalHeight, dim.y])
		});

		return this;
	},

	show: function(){
		if (!this.hidden) return this;

		window.addEvent('resize', this.position);
		this.position();
		this.showMask.apply(this, arguments);

		return this;
	},

	showMask: function(){
		this.element.setStyle('display', 'block');
		this.hidden = false;
		this.fireEvent('show');
	},

	hide: function(){
		if (this.hidden) return this;

		window.removeEvent('resize', this.position);
		this.hideMask.apply(this, arguments);
		if (this.options.destroyOnHide) return this.destroy();

		return this;
	},

	hideMask: function(){
		this.element.setStyle('display', 'none');
		this.hidden = true;
		this.fireEvent('hide');
	},

	toggle: function(){
		this[this.hidden ? 'show' : 'hide']();
	},

	destroy: function(){
		this.hide();
		this.element.destroy();
		this.fireEvent('destroy');
		this.target.eliminate('mask');
	}

});

})();


Element.Properties.mask = {

	set: function(options){
		var mask = this.retrieve('mask');
		if (mask) mask.destroy();
		return this.eliminate('mask').store('mask:options', options);
	},

	get: function(){
		var mask = this.retrieve('mask');
		if (!mask){
			mask = new Mask(this, this.retrieve('mask:options'));
			this.store('mask', mask);
		}
		return mask;
	}

};

Element.implement({

	mask: function(options){
		if (options) this.set('mask', options);
		this.get('mask').show();
		return this;
	},

	unmask: function(){
		this.get('mask').hide();
		return this;
	}

});
/*
---

script: Tips.js

name: Tips

description: Class for creating nice tips that follow the mouse cursor when hovering an element.

license: MIT-style license

authors:
  - Valerio Proietti
  - Christoph Pojer
  - Luis Merino

requires:
  - Core/Options
  - Core/Events
  - Core/Element.Event
  - Core/Element.Style
  - Core/Element.Dimensions
  - MooTools.More

provides: [Tips]

...
*/

(function(){

var read = function(option, element){
	return (option) ? (typeOf(option) == 'function' ? option(element) : element.get(option)) : '';
};

var Tips = this.Tips = new Class({

	Implements: [Events, Options],

	options: {/*
		id: null,
		onAttach: function(element){},
		onDetach: function(element){},
		onBound: function(coords){},*/
		onShow: function(){
			this.tip.setStyle('display', 'block');
		},
		onHide: function(){
			this.tip.setStyle('display', 'none');
		},
		title: 'title',
		text: function(element){
			return element.get('rel') || element.get('href');
		},
		showDelay: 100,
		hideDelay: 100,
		className: 'tip-wrap',
		offset: {x: 16, y: 16},
		windowPadding: {x:0, y:0},
		fixed: false,
		waiAria: true,
		hideEmpty: false
	},

	initialize: function(){
		var params = Array.link(arguments, {
			options: Type.isObject,
			elements: function(obj){
				return obj != null;
			}
		});
		this.setOptions(params.options);
		if (params.elements) this.attach(params.elements);
		this.container = new Element('div', {'class': 'tip'});

		if (this.options.id){
			this.container.set('id', this.options.id);
			if (this.options.waiAria) this.attachWaiAria();
		}
	},

	toElement: function(){
		if (this.tip) return this.tip;

		this.tip = new Element('div', {
			'class': this.options.className,
			styles: {
				position: 'absolute',
				top: 0,
				left: 0,
				display: 'none'
			}
		}).adopt(
			new Element('div', {'class': 'tip-top'}),
			this.container,
			new Element('div', {'class': 'tip-bottom'})
		);

		return this.tip;
	},

	attachWaiAria: function(){
		var id = this.options.id;
		this.container.set('role', 'tooltip');

		if (!this.waiAria){
			this.waiAria = {
				show: function(element){
					if (id) element.set('aria-describedby', id);
					this.container.set('aria-hidden', 'false');
				},
				hide: function(element){
					if (id) element.erase('aria-describedby');
					this.container.set('aria-hidden', 'true');
				}
			};
		}
		this.addEvents(this.waiAria);
	},

	detachWaiAria: function(){
		if (this.waiAria){
			this.container.erase('role');
			this.container.erase('aria-hidden');
			this.removeEvents(this.waiAria);
		}
	},

	attach: function(elements){
		$$(elements).each(function(element){
			var title = read(this.options.title, element),
				text = read(this.options.text, element);

			element.set('title', '').store('tip:native', title).retrieve('tip:title', title);
			element.retrieve('tip:text', text);
			this.fireEvent('attach', [element]);

			var events = ['enter', 'leave'];
			if (!this.options.fixed) events.push('move');

			events.each(function(value){
				var event = element.retrieve('tip:' + value);
				if (!event) event = function(event){
					this['element' + value.capitalize()].apply(this, [event, element]);
				}.bind(this);

				element.store('tip:' + value, event).addEvent('mouse' + value, event);
			}, this);
		}, this);

		return this;
	},

	detach: function(elements){
		$$(elements).each(function(element){
			['enter', 'leave', 'move'].each(function(value){
				element.removeEvent('mouse' + value, element.retrieve('tip:' + value)).eliminate('tip:' + value);
			});

			this.fireEvent('detach', [element]);

			if (this.options.title == 'title'){ // This is necessary to check if we can revert the title
				var original = element.retrieve('tip:native');
				if (original) element.set('title', original);
			}
		}, this);

		return this;
	},

	elementEnter: function(event, element){
		clearTimeout(this.timer);
		this.timer = (function(){
			this.container.empty();
			var showTip = !this.options.hideEmpty;
			['title', 'text'].each(function(value){
				var content = element.retrieve('tip:' + value);
				var div = this['_' + value + 'Element'] = new Element('div', {
						'class': 'tip-' + value
					}).inject(this.container);
				if (content){
					this.fill(div, content);
					showTip = true;
				}
			}, this);
			if (showTip){
				this.show(element);
			} else {
				this.hide(element);
			}
			this.position((this.options.fixed) ? {page: element.getPosition()} : event);
		}).delay(this.options.showDelay, this);
	},

	elementLeave: function(event, element){
		clearTimeout(this.timer);
		this.timer = this.hide.delay(this.options.hideDelay, this, element);
		this.fireForParent(event, element);
	},

	setTitle: function(title){
		if (this._titleElement){
			this._titleElement.empty();
			this.fill(this._titleElement, title);
		}
		return this;
	},

	setText: function(text){
		if (this._textElement){
			this._textElement.empty();
			this.fill(this._textElement, text);
		}
		return this;
	},

	fireForParent: function(event, element){
		element = element.getParent();
		if (!element || element == document.body) return;
		if (element.retrieve('tip:enter')) element.fireEvent('mouseenter', event);
		else this.fireForParent(event, element);
	},

	elementMove: function(event, element){
		this.position(event);
	},

	position: function(event){
		if (!this.tip) document.id(this);

		var size = window.getSize(), scroll = window.getScroll(),
			tip = {x: this.tip.offsetWidth, y: this.tip.offsetHeight},
			props = {x: 'left', y: 'top'},
			bounds = {y: false, x2: false, y2: false, x: false},
			obj = {};

		for (var z in props){
			obj[props[z]] = event.page[z] + this.options.offset[z];
			if (obj[props[z]] < 0) bounds[z] = true;
			if ((obj[props[z]] + tip[z] - scroll[z]) > size[z] - this.options.windowPadding[z]){
				obj[props[z]] = event.page[z] - this.options.offset[z] - tip[z];
				bounds[z+'2'] = true;
			}
		}

		this.fireEvent('bound', bounds);
		this.tip.setStyles(obj);
	},

	fill: function(element, contents){
		if (typeof contents == 'string') element.set('html', contents);
		else element.adopt(contents);
	},

	show: function(element){
		if (!this.tip) document.id(this);
		if (!this.tip.getParent()) this.tip.inject(document.body);
		this.fireEvent('show', [this.tip, element]);
	},

	hide: function(element){
		if (!this.tip) document.id(this);
		this.fireEvent('hide', [this.tip, element]);
	}

});

})();
/*
Script: ToElement.js
    Defines the toElement method for a class.

License:
    http://www.clientcide.com/wiki/cnet-libraries#license
*/
Class.ToElement = new Class({
    toElement: function(){
        return this.element;
    }
});
var ToElement = Class.ToElement;/*
Script: StyleWriter.js

Provides a simple method for injecting a css style element into the DOM if it's not already present.

License:
    http://www.clientcide.com/wiki/cnet-libraries#license
*/

var StyleWriter = new Class({
    createStyle: function(css, id) {
        window.addEvent('domready', function(){
            try {
                if (document.id(id) && id) return;
                var style = new Element('style', {id: id||''}).inject($$('head')[0]);
                if (Browser.Engine.trident) style.styleSheet.cssText = css;
                else style.set('text', css);
            }catch(e){console.log('error: %s',e);}
        }.bind(this));
    }
});
/*
Script: StickyWin.js

Creates a div within the page with the specified contents at the location relative to the element you specify; basically an in-page popup maker.

License:
    http://www.clientcide.com/wiki/cnet-libraries#license
*/


var StickyWin = new Class({
    Binds: ['destroy', 'hide', 'togglepin', 'esc'],
    Implements: [Options, Events, StyleWriter, Class.ToElement],
    options: {
//        onDisplay: $empty,
//        onClose: $empty,
//        onDestroy: $empty,
        closeClassName: 'closeSticky',
        pinClassName: 'pinSticky',
        content: '',
        zIndex: 10000,
        className: '',
//        id: ... set above in initialize function
/*      these are the defaults for Element.position anyway
        ************************************************
        edge: false, //see Element.position
        position: 'center', //center, corner == upperLeft, upperRight, bottomLeft, bottomRight
        offset: {x:0,y:0},
        relativeTo: document.body, */
        width: false,
        height: false,
        timeout: -1,
        allowMultipleByClass: true,
        allowMultiple: true,
        showNow: true,
        useIframeShim: true,
        iframeShimSelector: '',
        destroyOnClose: false,
        closeOnClickOut: false,
        closeOnEsc: false,
        getWindowManager: function(){ return StickyWin.WM; }
    },

    css: '.SWclearfix:after {content: "."; display: block; height: 0; clear: both; visibility: hidden;}'+
         '.SWclearfix {display: inline-table;} * html .SWclearfix {height: 1%;} .SWclearfix {display: block;}',
    
    initialize: function(options){
        this.options.inject = this.options.inject || {
            target: document.body,
            where: 'bottom'
        };
        this.setOptions(options);
        this.windowManager = this.options.getWindowManager();
        this.id = this.options.id || 'StickyWin_'+new Date().getTime();
        this.makeWindow();
        if (this.windowManager) this.windowManager.add(this);

        if (this.options.content) this.setContent(this.options.content);
        if (this.options.timeout > 0) {
            this.addEvent('onDisplay', function(){
                this.hide.delay(this.options.timeout, this);
            }.bind(this));
        }
        //add css for clearfix
        this.createStyle(this.css, 'StickyWinClearFix');
        if (this.options.closeOnClickOut || this.options.closeOnEsc) this.attach();
        if (this.options.destroyOnClose) this.addEvent('close', this.destroy);
        if (this.options.showNow) this.show();
    },
    attach: function(attach){
        var method = $pick(attach, true) ? 'addEvents' : 'removeEvents';
        var events = {};
        if (this.options.closeOnClickOut) events.click = this.esc;
        if (this.options.closeOnEsc) events.keyup = this.esc;
        document[method](events);
    },
    esc: function(e) {
        if (e.key == "esc") this.hide();
        if (e.type == "click" && this.element != e.target && !this.element.hasChild(e.target)) this.hide();
    },
    makeWindow: function(){
        this.destroyOthers();
        if (!document.id(this.id)) {
            this.win = new Element('div', {
                id:        this.id
            }).addClass(this.options.className).addClass('StickyWinInstance').addClass('SWclearfix').setStyles({
                 display:'none',
                position:'absolute',
                zIndex:this.options.zIndex
            }).inject(this.options.inject.target, this.options.inject.where).store('StickyWin', this);            
        } else this.win = document.id(this.id);
        this.element = this.win;
        if (this.options.width && $type(this.options.width.toInt())=="number") this.win.setStyle('width', this.options.width.toInt());
        if (this.options.height && $type(this.options.height.toInt())=="number") this.win.setStyle('height', this.options.height.toInt());
        return this;
    },
    show: function(suppressEvent){
        this.showWin();
        if (!suppressEvent) this.fireEvent('display');
        if (this.options.useIframeShim) this.showIframeShim();
        this.visible = true;
        return this;
    },
    showWin: function(){
        var defaultOptions =  {
                relativeTo: document.body,
        
                position: {
                    x: 'center', //left, center, right
                    y: 'center' //top, center, bottom
                },
                edge: false,
                offset: {x: 0, y: 0},
                returnPos: false,
                relFixedPosition: false,
                ignoreMargins: false,
                ignoreScroll: false,
                allowNegative: false
        };
        
        if (this.windowManager) this.windowManager.focus(this);
        if (!this.positioned) this.position(defaultOptions);
        this.win.show();
    },
    hide: function(suppressEvent){
        if ($type(suppressEvent) == "event" || !suppressEvent) this.fireEvent('close');
        this.hideWin();
        if (this.options.useIframeShim) this.hideIframeShim();
        this.visible = false;
        return this;
    },
    hideWin: function(){
        this.win.setStyle('display','none');
    },
    destroyOthers: function() {
        if (!this.options.allowMultipleByClass || !this.options.allowMultiple) {
            $$('div.StickyWinInstance').each(function(sw) {
                if (!this.options.allowMultiple || (!this.options.allowMultipleByClass && sw.hasClass(this.options.className))) 
                    sw.retrieve('StickyWin').destroy();
            }, this);
        }
    },
    setContent: function(html) {
        if (this.win.getChildren().length>0) this.win.empty();
        if ($type(html) == "string") this.win.set('html', html);
        else if (document.id(html)) this.win.adopt(html);
        this.win.getElements('.'+this.options.closeClassName).each(function(el){
            el.addEvent('click', this.hide);
        }, this);
        this.win.getElements('.'+this.options.pinClassName).each(function(el){
            el.addEvent('click', this.togglepin);
        }, this);
        return this;
    },
    position: function(options){
        this.positioned = true;
        this.setOptions(options);
        this.win.position({
            allowNegative: $pick(this.options.allowNegative, this.options.relativeTo != document.body),
            relativeTo: this.options.relativeTo,
            position: this.options.position,
            offset: this.options.offset,
            edge: this.options.edge
        });
        if (this.shim) this.shim.position();
        return this;
    },
    pin: function(pin) {
        if (!this.win.pin) {
            console.log('you must include element.pin.js!');
            return this;
        }
        this.pinned = $pick(pin, true);
        this.win.pin(pin);
        return this;
    },
    unpin: function(){
        return this.pin(false);
    },
    togglepin: function(){
        return this.pin(!this.pinned);
    },
    makeIframeShim: function(){
        if (!this.shim){
            var el = (this.options.iframeShimSelector)?this.win.getElement(this.options.iframeShimSelector):this.win;
            this.shim = new IframeShim(el, {
                display: false,
                name: 'StickyWinShim'
            });
        }
    },
    showIframeShim: function(){
        if (this.options.useIframeShim) {
            this.makeIframeShim();
            this.shim.show();
        }
    },
    hideIframeShim: function(){
        if (this.shim) this.shim.hide();
    },
    destroy: function(){
        if (this.windowManager) this.windowManager.remove(this);
        if (this.win) this.win.destroy();
        if (this.options.useIframeShim && this.shim) this.shim.destroy();
        if (document.id('modalOverlay')) document.id('modalOverlay').destroy();
        this.fireEvent('destroy');
    }
});

StickyWin.Stacker = new Class({
    Implements: [Options, Events],
    Binds: ['click'],
    instances: [],
    options: {
        zIndexBase: 9000
    },
    initialize: function(options) {
        this.setOptions(options);
        this.zIndex = this.options.zIndex;
    },
    add: function(sw) {
        this.instances.include(sw);
        $(sw).addEvent('mousedown', this.click);
    },
    click: function(e) {
        this.instances.each(function(sw){
            var el = $(sw);
            if (el == e.target || el.hasChild($(e.target))) this.focus(sw);
        }, this);
    },
    focus: function(instance){
        if (this.focused == instance) return;
        this.focused = instance;
        if (instance) this.instances.erase(instance).push(instance);
        this.instances.each(function(current, i){
            $(current).setStyle('z-index', this.options.zIndexBase + i);
        }, this);
        this.focused = instance;
    },
    remove: function(sw) {
        this.instances.erase(sw);
        $(sw).removeEvent('click', this.click);
    }
});
StickyWin.WM = new StickyWin.Stacker();
/*
Script: StickyWin.Modal.js

This script extends StickyWin and StickyWin.Fx classes to add Mask functionality.

License:
    http://www.clientcide.com/wiki/cnet-libraries#license
*/
StickyWin.Modal = new Class({

    Extends: StickyWin,

    options: {
        modalize: true,
        maskOptions: {
            style: {
                'background-color':'#333',
                opacity:0.8
            }
        },
        hideOnClick: true,
        getWindowManager: function(){ return StickyWin.ModalWM; }
    },

    initialize: function(options) {
        this.options.maskTarget = this.options.maskTarget || document.body;
        if (!Browser.Engine.trident) {
            this.options.maskOptions.style.position='fixed !important';
        }
        this.setOptions(options);
        this.mask = new Mask(this.options.maskTarget, this.options.maskOptions).addEvent('click', function() {
            if (this.options.hideOnClick) this.hide();
        }.bind(this));
        this.parent(options);
    },

    show: function(showModal){
        if ($pick(showModal, this.options.modalize)) this.mask.show();
        this.parent();
    },

    hide: function(hideModal){
        if ($pick(hideModal, true)) this.mask.hide();
        this.parent();
    }

});

StickyWin.ModalWM = new StickyWin.Stacker({
    zIndexBase: 11000
});
if (StickyWin.Fx) StickyWin.Fx.Modal = StickyWin.Modal;
;
/**
 * Roar - Notifications
 *
 * Inspired by Growl
 *
 * @version		1.0.1
 *
 * @license		MIT-style license
 * @author		Harald Kirschner <mail [at] digitarald.de>
 * @copyright	Author
 */

var Roar = new Class({

	Implements: [Options, Events, Chain],

	options: {
		duration: 4000,
		position: 'upperLeft',
		container: null,
		bodyFx: null,
		itemFx: null,
		margin: {x: 10, y: 10},
		offset: 5,
		className: 'roar',
		onShow: $empty,
		onHide: $empty,
		onRender: $empty,
		style: 'notice'
	},

	initialize: function(options) {
		this.setOptions(options);
		this.items = [];
		this.container = $(this.options.container) || document;
	},

	alert: function(title, message, options) {
		var params = Array.link(arguments, {title: String.type, message: String.type, options: Object.type});
		var items = [new Element('h3', {'html': $pick(params.title, '')})];
		if (params.message) items.push(new Element('p', {'html': params.message}));
		return this.inject(items, params.options);
	},

	inject: function(elements, options) {
		if (!this.body) this.render();
		options = options || {};

		var offset = [-this.options.offset, 0];
		var last = this.items.getLast();
		if (last) {
			offset[0] = last.retrieve('roar:offset');
			offset[1] = offset[0] + last.offsetHeight + this.options.offset;
		}
		var to = {'opacity': 1};
		to[this.align.y] = offset;

		var item = new Element('div', {
			'class': this.options.className,
			'styles': {'opacity': 0}
		}).adopt(
			new Element('div', {
				'class': this.options.className+'-bg',
				'styles': {'opacity': 0.7, 'visibility': 'visible'}
			}),
			elements
		);

		item.setStyle(this.align.x, 0).store('roar:offset', offset[1]).set('morph', $merge({
			unit: 'px',
			link: 'cancel',
			onStart: Chain.prototype.clearChain,
			transition: Fx.Transitions.Back.easeOut
		}, this.options.itemFx));

		var remove = this.remove.create({
			bind: this,
			arguments: [item],
			delay: 10
		});
		this.items.push(item.addEvent('click', remove));

		if (this.options.duration) {
			var over = false;
			var trigger = (function() {
				trigger = null;
				if (!over) remove();
			}).delay(this.options.duration);
			item.addEvents({
				mouseover: function() {
					over = true;
				},
				mouseout: function() {
					over = false;
					if (!trigger) remove();
				}
			});
		}
		item.inject(this.body).morph(to);
		return this.fireEvent('onShow', [item, this.items.length]);
	},

	remove: function(item) {
		var index = this.items.indexOf(item);
		if (index == -1) return this;
		this.items.splice(index, 1);
		item.removeEvents();
		var to = {opacity: 0};
		to[this.align.y] = item.getStyle(this.align.y).toInt() - item.offsetHeight - this.options.offset;
		item.morph(to).get('morph').chain(item.destroy.bind(item));
		return this.fireEvent('onHide', [item, this.items.length]).callChain(item);
	},

	empty: function() {
		while (this.items.length) this.remove(this.items[0]);
		return this;
	},

	render: function() {
		this.position = this.options.position;
		if ($type(this.position) == 'string') {
			var position = {x: 'center', y: 'center'};
			this.align = {x: 'left', y: 'top'};
			if ((/left|west/i).test(this.position)) position.x = 'left';
			else if ((/right|east/i).test(this.position)) this.align.x = position.x = 'right';
			if ((/upper|top|north/i).test(this.position)) position.y = 'top';
			else if ((/bottom|lower|south/i).test(this.position)) this.align.y = position.y = 'bottom';
			this.position = position;
		}
		this.body = new Element('div', {'class': this.options.className+'-body'}).inject(document.body);
		if (Browser.Engine.trident4) this.body.addClass(this.options.className+'-body-ugly');
		this.moveTo = this.body.setStyles.bind(this.body);
		this.reposition();
		if (this.options.bodyFx) {
			var morph = new Fx.Morph(this.body, $merge({
				unit: 'px',
				chain: 'cancel',
				transition: Fx.Transitions.Circ.easeOut
			}, this.options.bodyFx));
			this.moveTo = morph.start.bind(morph);
		}
		var repos = this.reposition.bind(this);
		window.addEvents({
			scroll: repos,
			resize: repos
		});
		this.fireEvent('onRender', this.body);
	},

	reposition: function() {
		var max = document.getCoordinates(), scroll = document.getScroll(), margin = this.options.margin;
		max.left += scroll.x;
		max.right += scroll.x;
		max.top += scroll.y;
		max.bottom += scroll.y;
		var rel = ($type(this.container) == 'element') ? this.container.getCoordinates() : max;
		this.moveTo({
			left: (this.position.x == 'right')
				? (Math.min(rel.right, max.right) - margin.x)
				: (Math.max(rel.left, max.left) + margin.x),
			top: (this.position.y == 'bottom')
				? (Math.min(rel.bottom, max.bottom) - margin.y)
				: (Math.max(rel.top, max.top) + margin.y)
		});
	}

});
/**
 * Observer - Observe formelements for changes
 *
 * - Additional code from clientside.cnet.com
 *
 * @version		1.1
 *
 * @license		MIT-style license
 * @author		Harald Kirschner <mail [at] digitarald.de>
 * @copyright	Author
 */
var Observer = new Class({

	Implements: [Options, Events],

	options: {
		periodical: false,
		delay: 1000
	},

	initialize: function(el, onFired, options){
		this.element = $(el) || $$(el);
		this.addEvent('onFired', onFired);
		this.setOptions(options);
		this.bound = this.changed.bind(this);
		this.resume();
	},

	changed: function() {
		var value = this.element.get('value');
		if ($equals(this.value, value)) return;
		this.clear();
		this.value = value;
		this.timeout = this.onFired.delay(this.options.delay, this);
	},

	setValue: function(value) {
		this.value = value;
		this.element.set('value', value);
		return this.clear();
	},

	onFired: function() {
		this.fireEvent('onFired', [this.value, this.element]);
	},

	clear: function() {
		$clear(this.timeout || null);
		return this;
	},

	pause: function(){
		if (this.timer) $clear(this.timer);
		else this.element.removeEvent('keyup', this.bound);
		return this.clear();
	},

	resume: function(){
		this.value = this.element.get('value');
		if (this.options.periodical) this.timer = this.changed.periodical(this.options.periodical, this);
		else this.element.addEvent('keyup', this.bound);
		return this;
	}

});

var $equals = function(obj1, obj2) {
	return (obj1 == obj2 || JSON.encode(obj1) == JSON.encode(obj2));
};
/**
 * Autocompleter
 *
 * http://digitarald.de/project/autocompleter/
 *
 * @version		1.1.2
 *
 * @license		MIT-style license
 * @author		Harald Kirschner <mail [at] digitarald.de>
 * @copyright	Author
 */

var Autocompleter = new Class({

    Implements: [Options, Events],

    options: {/*
		onOver: $empty,
		onSelect: $empty,
		onSelection: $empty,
		onShow: $empty,
		onHide: $empty,
		onBlur: $empty,
		onFocus: $empty,*/
        minLength: 1,
        markQuery: true,
        width: 'inherit',
        maxChoices: 10,
        injectChoice: null,
        customChoices: null,
        emptyChoices: null,
        visibleChoices: true,
        className: 'autocompleter-choices',
        zIndex: 42,
        delay: 400,
        observerOptions: {},
        fxOptions: {},

        autoSubmit: false,
        overflow: false,
        overflowMargin: 25,
        selectFirst: false,
        filter: null,
        filterCase: false,
        filterSubset: false,
        forceSelect: false,
        selectMode: true,
        choicesMatch: null,

        multiple: false,
        separator: ', ',
        separatorSplit: /\s*[,;]\s*/,
        autoTrim: false,
        allowDupes: false,

        cache: true,
        relative: false
    },

    initialize: function(element, options)
    {
        this.element = $(element);
        this.setOptions(options);
        this.build();
        this.observer = new Observer(this.element, this.prefetch.bind(this), $merge({
            'delay': this.options.delay
        }, this.options.observerOptions));
        this.queryValue = null;
        if (this.options.filter) this.filter = this.options.filter.bind(this);
        var mode = this.options.selectMode;
        this.typeAhead = (mode == 'type-ahead');
        this.selectMode = (mode === true) ? 'selection' : mode;
        this.cached = [];
    },

    /**
	 * build - Initialize DOM
	 *
	 * Builds the html structure for choices and appends the events to the element.
	 * Override this function to modify the html generation.
	 */
    build: function()
    {
        if ($(this.options.customChoices))
        {
            this.choices = this.options.customChoices;
        }
        else
        {
            this.choices = new Element('ul', {
                'class': this.options.className,
                'styles': {
                    'zIndex': this.options.zIndex
                }
            }).inject(document.body);
            this.relative = false;
            if (this.options.relative)
            {
                this.choices.inject(this.element, 'after');
                this.relative = this.element.getOffsetParent();
            }
            this.fix = new OverlayFix(this.choices);
        }
        if (!this.options.separator.test(this.options.separatorSplit))
        {
            this.options.separatorSplit = this.options.separator;
        }
        this.fx = (!this.options.fxOptions) ? null : new Fx.Tween(this.choices, $merge({
            'property': 'opacity',
            'link': 'cancel',
            'duration': 0
        }, this.options.fxOptions)).addEvent('onStart', Chain.prototype.clearChain).set(0);
        this.element.setProperty('autocomplete', 'off')
            .addEvent((Browser.Engine.trident || Browser.Engine.webkit) ? 'keydown' : 'keypress', this.onCommand.bind(this))
            .addEvent('click', this.onCommand.bind(this, [false]))
            .addEvent('focus', this.toggleFocus.create({bind: this, arguments: true, delay: 100}))
            .addEvent('blur', this.toggleFocus.create({bind: this, arguments: false, delay: 100}));
    },

    destroy: function()
    {
        if (this.fix) this.fix.destroy();
        this.choices = this.selected = this.choices.destroy();
    },

    toggleFocus: function(state)
    {
        this.focussed = state;
        if (!state) this.hideChoices(true);
        this.fireEvent((state) ? 'onFocus' : 'onBlur', [this.element]);
    },

    onCommand: function(e)
    {
        if (!e && this.focussed) return this.prefetch();
        if (e && e.key && !e.shift)
        {
            switch (e.key)
            {
                case 'enter':
                    if (this.element.value != this.opted) return true;
                    if (this.selected && this.visible)
                    {
                        this.choiceSelect(this.selected);
                        return !!(this.options.autoSubmit);
                    }
                    break;
                case 'up': case 'down':
                    if (!this.prefetch() && this.queryValue !== null)
                    {
                        var up = (e.key == 'up');
                        this.choiceOver((this.selected || this.choices)[
                            (this.selected) ? ((up) ? 'getPrevious' : 'getNext') : ((up) ? 'getLast' : 'getFirst')
                        ](this.options.choicesMatch), true);
                    }
                    return false;
                case 'esc': case 'tab':
                    this.hideChoices(true);
                    break;
            }
        }
        return true;
    },

    setSelection: function(finish)
    {
	 	var input = this.selected.inputValue, value = input;
        var start = this.queryValue.length, end = input.length;
        if (input.substr(0, start).toLowerCase() != this.queryValue.toLowerCase()) start = 0;
        if (this.options.multiple)
        {
            var split = this.options.separatorSplit;
            value = this.element.value;
            start += this.queryIndex;
            end += this.queryIndex;
            var old = value.substr(this.queryIndex).split(split, 1)[0];
            value = value.substr(0, this.queryIndex) + input + value.substr(this.queryIndex + old.length);
            if (finish)
            {
                var tokens = value.split(this.options.separatorSplit).filter(function(entry)
                {
                    return this.test(entry);
                }, /[^\s,]+/);
                if (!this.options.allowDupes) tokens = [].combine(tokens);
                var sep = this.options.separator;
                value = tokens.join(sep) + sep;
                end = value.length;
            }
        }
        this.observer.setValue(value);
        this.opted = value;
        if (finish || this.selectMode == 'pick') start = end;
        this.element.selectRange(start, end);
        this.fireEvent('onSelection', [this.element, this.selected, value, input]);
    },

    showChoices: function()
    {
        var match = this.options.choicesMatch, first = this.choices.getFirst(match);
        this.selected = this.selectedValue = null;
        if (this.fix)
        {
            var pos = this.element.getCoordinates(this.relative), width = this.options.width || 'auto';
            this.choices.setStyles({
                'left': pos.left,
                'top': pos.bottom,
                'width': (width === true || width == 'inherit') ? pos.width : width
            });
        }
        if (!first) return;
        if (!this.visible)
        {
            this.visible = true;
            this.choices.setStyle('display', '');
            if (this.fx) this.fx.start(1);
            this.fireEvent('onShow', [this.element, this.choices]);
        }
        if (this.options.selectFirst || this.typeAhead || first.inputValue == this.queryValue) this.choiceOver(first, this.typeAhead);
        var items = this.choices.getChildren(match), max = this.options.maxChoices;
        var styles = {'overflowY': 'hidden', 'height': ''};
        this.overflown = false;
        if (items.length > max)
        {
            var item = items[max - 1];
            styles.overflowY = 'scroll';
            styles.height = item.getCoordinates(this.choices).bottom;
            this.overflown = true;
        }
        this.choices.setStyles(styles);
        this.fix.show();
        if (this.options.visibleChoices)
        {
            var scroll = document.getScroll(),
                    size = document.getSize(),
                    coords = this.choices.getCoordinates();
            if (coords.right > scroll.x + size.x) scroll.x = coords.right - size.x;
            if (coords.bottom > scroll.y + size.y) scroll.y = coords.bottom - size.y;
            window.scrollTo(Math.min(scroll.x, coords.left), Math.min(scroll.y, coords.top));
        }
    },

    hideChoices: function(clear)
    {
        if (clear)
        {
            var value = this.element.value;
            if (this.options.forceSelect) value = this.opted;
            if (this.options.autoTrim)
            {
                value = value.split(this.options.separatorSplit).filter($arguments(0)).join(this.options.separator);
            }
            this.observer.setValue(value);
        }
        if (!this.visible) return;
        this.visible = false;
        if (this.selected) this.selected.removeClass('autocompleter-selected');
        this.observer.clear();
        var hide = function()
        {
            this.choices.setStyle('display', 'none');
            this.fix.hide();
        }.bind(this);
        if (this.fx) this.fx.start(0).chain(hide);
        else hide();
        this.fireEvent('onHide', [this.element, this.choices]);
    },

    prefetch: function()
    {
        var value = this.element.value, query = value;
        if (this.options.multiple)
        {
            var split = this.options.separatorSplit;
            var values = value.split(split);
            var index = this.element.getSelectedRange().start;
            var toIndex = value.substr(0, index).split(split);
            var last = toIndex.length - 1;
            index -= toIndex[last].length;
            query = values[last];
        }
        if (query.length < this.options.minLength)
        {
            this.hideChoices();
        }
        else
        {
            if (query === this.queryValue || (this.visible && query == this.selectedValue))
            {
                if (this.visible) return false;
                this.showChoices();
            }
            else
            {
                this.queryValue = query;
                this.queryIndex = index;
                if (!this.fetchCached()) this.query();
            }
        }
        return true;
    },

    fetchCached: function()
    {
        return false;
    },

    update: function(tokens)
    {
        this.choices.empty();
        this.cached = tokens;
        var type = tokens && $type(tokens);
        if (!type || (type == 'array' && !tokens.length) || (type == 'hash' && !tokens.getLength()))
        {
            (this.options.emptyChoices || this.hideChoices).call(this);
        }
        else
        {
            if (this.options.maxChoices < tokens.length && !this.options.overflow)
			    tokens.length = this.options.maxChoices;

            tokens.each(this.options.injectChoice || function(token)
            {
                var choice = new Element('li', {'html': this.markQueryValue(token)});
                choice.inputValue = token;
                this.addChoiceEvents(choice).inject(this.choices);
            }, this);
            this.showChoices();
        }
    },

    choiceOver: function(choice, selection)
    {
        if (!choice || choice == this.selected) return;
        if (this.selected) this.selected.removeClass('autocompleter-selected');
        this.selected = choice.addClass('autocompleter-selected');
        this.fireEvent('onSelect', [this.element, this.selected, selection]);
        if (!this.selectMode) this.opted = this.element.value;
        if (!selection) return;
        this.selectedValue = this.selected.inputValue;
        if (this.overflown)
        {
            var coords = this.selected.getCoordinates(this.choices), margin = this.options.overflowMargin,
                    top = this.choices.scrollTop, height = this.choices.offsetHeight, bottom = top + height;
            if (coords.top - margin < top && top) this.choices.scrollTop = Math.max(coords.top - margin, 0);
            else if (coords.bottom + margin > bottom) this.choices.scrollTop = Math.min(coords.bottom - height + margin, bottom);
        }
        if (this.selectMode) this.setSelection();
    },

    choiceSelect: function(choice)
    {
        if (choice) this.choiceOver(choice);
        this.setSelection(true);
        this.queryValue = false;
        this.hideChoices();
    },

    filter: function(tokens)
    {
        return (tokens || this.tokens).filter(function(token)
        {
            return this.test(token);
        }, new RegExp(((this.options.filterSubset) ? '' : '^') + this.queryValue.escapeRegExp(), (this.options.filterCase) ? '' : 'i'));
    },

    /**
	 * markQueryValue
	 *
	 * Marks the queried word in the given string with <span class="autocompleter-queried">*</span>
	 * Call this i.e. from your custom parseChoices, same for addChoiceEvents
	 *
	 * @param		{String} Text
	 * @return		{String} Text
	 */
    markQueryValue: function(str)
    {
        return (!this.options.markQuery || !this.queryValue) ? str
            : str.replace(new RegExp('(' + ((this.options.filterSubset) ? '' : '^') + this.queryValue.escapeRegExp() + ')', (this.options.filterCase) ? '' : 'i'), '<span class="autocompleter-queried">$1</span>');
    },

    /**
	 * addChoiceEvents
	 *
	 * Appends the needed event handlers for a choice-entry to the given element.
	 *
	 * @param		{Element} Choice entry
	 * @return		{Element} Choice entry
	 */
    addChoiceEvents: function(el)
    {
        return el.addEvents({
            'mouseover': this.choiceOver.bind(this, [el]),
            'click': this.choiceSelect.bind(this, [el])
        });
    }
});

var OverlayFix = new Class({

    initialize: function(el)
    {
        if (Browser.Engine.trident)
        {
            this.element = $(el);
            this.relative = this.element.getOffsetParent();
            this.fix = new Element('iframe', {
                'frameborder': '0',
                'scrolling': 'no',
                'src': 'javascript:false;',
                'styles': {
                    'position': 'absolute',
                    'border': 'none',
                    'display': 'none',
                    'filter': 'progid:DXImageTransform.Microsoft.Alpha(opacity=0)'
                }
            }).inject(this.element, 'after');
        }
    },

    show: function()
    {
        if (this.fix)
        {
            var coords = this.element.getCoordinates(this.relative);
            delete coords.right;
            delete coords.bottom;
            this.fix.setStyles($extend(coords, {
                'display': '',
                'zIndex': (this.element.getStyle('zIndex') || 1) - 1
            }));
        }
        return this;
    },

    hide: function()
    {
        if (this.fix) this.fix.setStyle('display', 'none');
        return this;
    },

    destroy: function()
    {
        if (this.fix) this.fix = this.fix.destroy();
    }

});


/* compatibility */
Autocompleter.Base = Autocompleter;
/**
 * Autocompleter.Request
 *
 * http://digitarald.de/project/autocompleter/
 *
 * @version		1.1.2
 *
 * @license		MIT-style license
 * @author		Harald Kirschner <mail [at] digitarald.de>
 * @copyright	Author
 */

Autocompleter.Request = new Class({

    Extends: Autocompleter,

    options: {/*
		indicator: null,
		indicatorClass: null,
		onRequest: $empty,
		onComplete: $empty,*/
        postData: {},
        ajaxOptions: {},
        postVar: 'value'

    },

    query: function()
    {
        var data = $unlink(this.options.postData) || {};
        data[this.options.postVar] = this.queryValue;
        var indicator = $(this.options.indicator);
        if (indicator) indicator.setStyle('display', '');
        var cls = this.options.indicatorClass;
        if (cls) this.element.addClass(cls);
        this.fireEvent('onRequest', [this.element, this.request, data, this.queryValue]);
        this.request.send({'data': data});
    },

    /**
	 * queryResponse - abstract
	 *
	 * Inherated classes have to extend this function and use this.parent()
	 */
    queryResponse: function()
    {
        var indicator = $(this.options.indicator);
        if (indicator) indicator.setStyle('display', 'none');
        var cls = this.options.indicatorClass;
        if (cls) this.element.removeClass(cls);
        return this.fireEvent('onComplete', [this.element, this.request]);
    }

});

Autocompleter.Request.JSON = new Class({

    Extends: Autocompleter.Request,

    initialize: function(el, url, options)
    {
        this.parent(el, options);
        this.request = new Request.JSON($merge({
            'url': url,
            'link': 'cancel'
        }, this.options.ajaxOptions)).addEvent('onComplete', this.queryResponse.bind(this));
    },

    queryResponse: function(response)
    {
        this.parent();
        this.update(response);
    }

});

Autocompleter.Request.HTML = new Class({

    Extends: Autocompleter.Request,

    initialize: function(el, url, options)
    {
        this.parent(el, options);
        this.request = new Request.HTML($merge({
            'url': url,
            'link': 'cancel',
            'update': this.choices
        }, this.options.ajaxOptions)).addEvent('onComplete', this.queryResponse.bind(this));
    },

    queryResponse: function(tree, elements)
    {
        this.parent();
        if (!elements || !elements.length)
        {
            this.hideChoices();
        }
        else
        {
            this.choices.getChildren(this.options.choicesMatch).each(this.options.injectChoice || function(choice)
            {
                var value = choice.get('text');
                choice.inputValue = value;
                this.addChoiceEvents(choice.set('html', this.markQueryValue(value)));
            }, this);
            this.showChoices();
        }

    }

});

/* compatibility */
Autocompleter.Ajax = {
    Base: Autocompleter.Request,
    Json: Autocompleter.Request.JSON,
    Xhtml: Autocompleter.Request.HTML
};
;
 /*********************************************************/
 /*   vlaCalendar version 2.1 for mootools release 1.2    */
/*********************************************************/

var vlaCalendar = new Class({
	'slideDuration': 500,
	'fadeDuration': 500,
	'transition': Fx.Transitions.Quart.easeOut,
	'startMonday': false,
	'filePath': 'inc/',
	'defaultView': 'month',
	'style': '',
	
	initialize: function(_container, _options) {
		//Add the provided options to this object by extending
		if(_options) $extend(this, _options);
		
		this.loading = false;
		this.container = _container = $(_container);
		var _class = this;
		
		//Insert the base into the container and initialize elements
		var  pars = 'defaultView='+ this.defaultView;
		if(this.picker) {
			if($type(this.prefillDate) == 'object' && this.getInputDate(this.prefillDate)) pars += '&pickedDate='+ this.getInputDate(this.prefillDate);
			if(this.linkWithInput) pars += '&gotoPickedDate=1';
		}
		this.u('base', pars, function() { 
			_class.mainLoader = _container.getElement('div[class=loaderA]');
			_class.tempLoader = _container.getElement('div[class=loaderB]');
			_class.label 	  = _container.getElement('span[class=label]');
			_class.arrowLeft  = _container.getElement('div[class=arrowLeft]');
			_class.arrowRight = _container.getElement('div[class=arrowRight]');				
			_class.initializeCalendarFunctions();
			
			//Prefill/load picker date elements
			if(_class.picker) {
				if($type(_class.prefillDate) == 'object' && _class.getInputDate(_class.prefillDate)) _class.pick(_class.prefillDate);
				else if(_class.prefillDate == true) _class.pick(JSON.decode(_class.label.getProperty('date')));
			}
		}, _container);
	},
	
	initializeCalendarFunctions: function() {
		this.resetArrows();
		
		//Retrieve data (label, timestamp etc) which are stored as a Json string in the table attribute summary
		var vars = JSON.decode(this.mainLoader.getElement('table').getProperty('summary'));
		var _class = this; 
		
		//Change the label
		this.label.removeClass('noHover').set('html', vars.label)
			.onclick = vars.parent ? function() { _class.u(vars.parent, 'ts=' + vars.ts + '&parent=' + vars.current, function() { _class.fade() }) } : null;
			
		//Hide arrows if necessary and add arrow click events
		if(vars.hide_left_arrow) this.hideLeftArrow();
		else if(vars.hide_right_arrow) this.hideRightArrow();
		
		this.arrowLeft.onclick  = function() { _class.u(vars.current, 'ts=' + vars.pr_ts, function() { _class.slideLeft() }) }
		this.arrowRight.onclick = function() { _class.u(vars.current, 'ts=' + vars.nx_ts, function() { _class.slideRight() }) }		
		
		//Add cell click events
		var clickables = this.mainLoader.getElements('td');
		switch(vars.current) {
			case 'month':
				if(this.picker) {
					clickables.each(function(_clickable) {
						_clickable.onclick = function() { 
							_class.pick(JSON.decode(_clickable.getProperty('date')));
							_class.mainLoader.getElements('td').each(function(_clickable) { _clickable.removeClass('selected') });
							this.addClass('selected'); 
						}
					});
				}
				break;
			case 'year':
				clickables.each(function(_clickable) {
					_clickable.onclick = function() { _class.u('month', 'ts=' + _clickable.getProperty('ts'), function() { _class.fade() }) }
				});
				break;
			case 'decade':
				this.label.addClass('noHover');
				clickables.each(function(_clickable) {
					_clickable.onclick = function() { _class.u('year', 'ts=' + _clickable.getProperty('ts') + '&m_ts=' + _clickable.getProperty('m_ts'), function() { _class.fade() }) }
				});
				break;
		}
	},
	
	//Ajax updater function which handles all requests
	u: function(_url, _pars, _onComplete, _id) {
		if(!this.loading && !this.transitioning) {
			var _class = this;
			this.loading = true;
			var element = $(_id ? _id : this.tempLoader);
			_pars += '&picker=' + (this.picker ? 1 : 0) + '&startMonday=' + (this.startMonday ? 1 : 0) + '&style=' +  this.style;
			if(this.picker && this.getInputDate()) _pars += '&pickedDate='+ this.getInputDate();
			new Request({ method: 'post',
						  url: this.filePath + _url + '.php',
						  onComplete: function(data) { element.set('html', data); _onComplete(); _class.loading = false; }
						}).send(_pars);
		}
	},
	
	slideLeft: function() {
		var _class = this;
		this.transitioning = true;	
		this.tempLoader.setStyle('opacity', 1).set('tween', { duration: this.slideDuration, transition: this.transition }).tween('margin-left', [-164, 0]);
		this.mainLoader.setStyle('opacity', 1).set('tween', { duration: this.slideDuration, transition: this.transition, onComplete: function() { _class.transitioning = false } })
			.tween('margin-left', [0, 164]);
		this.switchLoaders();
	},
	
	slideRight: function() {
		var _class = this;
		this.transitioning = true;
		this.mainLoader.setStyle('opacity', 1).set('tween', { duration: this.slideDuration, transition: this.transition }).tween('margin-left', [0, -164]);
		this.tempLoader.setStyle('opacity', 1).set('tween', { duration: this.slideDuration, transition: this.transition, onComplete: function() { _class.transitioning = false } })
			.tween('margin-left', [164, 0]);
		this.switchLoaders();
	},
	
	fade: function(overRuleTrans) {
		var _class = this;
		this.transitioning = overRuleTrans ? false : true;
		this.tempLoader.setStyles({'opacity': 0, 'margin-left': 0});
		this.mainLoader.set('tween', { duration: this.fadeDuration, transition: this.transition}).fade('out');
		this.tempLoader.set('tween', { duration: this.fadeDuration, transition: this.transition, 
			onComplete: function() { 
					_class.tempLoader.setStyles({'opacity': 1, 'margin-left': -999});
					_class.transitioning = false;
				} 
			}).fade('in');
		this.switchLoaders();
	},
	
	switchLoaders: function() {
		this.mainLoader = this.mainLoader.className == 'loaderA' ? this.container.getElement('div[class=loaderB]') : this.container.getElement('div[class=loaderA]');
		this.tempLoader = this.tempLoader.className == 'loaderA' ? this.container.getElement('div[class=loaderB]') : this.container.getElement('div[class=loaderA]');
		this.initializeCalendarFunctions();
	},
	
	resetArrows: function() {
		this.arrowLeft.setStyle('visibility', 'visible');
		this.arrowRight.setStyle('visibility', 'visible');
	},
	
	hideLeftArrow: function() {
		this.arrowLeft.setStyle('visibility', 'hidden');
	},
	
	hideRightArrow: function() {
		this.arrowRight.setStyle('visibility', 'hidden');
	} 
});

var vlaDatePicker = new Class({
	Extends: vlaCalendar,
	
	'onSelect': false,
	'separateInput': false,
	'prefillDate': true,
	'linkWithInput': true,
	'leadingZero': true,
	'twoDigitYear': false,
	'separator': '/',
	'format': 'd/m/y',
	'openWith': null,
	'alignX': 'right',
	'alignY': 'inputTop',
	'offset': { 'x': 0, 'y': 0 },
	'style': '',
	'ieTransitionColor' : '#ffffff',
	'toggleDuration': 350,
	
	initialize: function(_element, _options) {
		//Add the provided options to this object by extending
		if(_options) $extend(this, _options);
		
		this.element = $(_element);
		if(!this.element) throw 'No (existing) element to create a datepicker for specified: new vlaDatePicker(ELEMENT, [options])';
		
		//Check if the user wants multiple input
		if(this.separateInput) {
			this.element.day   = this.element.getElement('input[name='+ this.separateInput.day +']');
			this.element.month = this.element.getElement('input[name='+ this.separateInput.month +']');
			this.element.year  = this.element.getElement('input[name='+ this.separateInput.year +']');
		}
		
		//Create the picker and calendar and inject in in the body
		this.picker = new Element('div', { 'class': 'vlaCalendarPicker' + (this.style != '' ? ' ' + this.style : '') }).injectTop($(document.body));
		this.pickerContent = new Element('div', { 'class': 'pickerBackground' }).injectTop(this.picker);
		this.parent(this.pickerContent);
		
		//Add events for showing and hiding the picker
		var _class = this;
		(this.openWith ? $(this.openWith) : this.element)
			.addEvent('focus',  function() { _class.show(); })
			.addEvent('click',  function() { _class.openWith ? _class.toggle() : _class.show() })
			.addEvent('keydown', function(e){ if (e.key=='tab') _class.hide() });
		
		//If the datepicker is visible an outside click makes it hide
		document.addEvent('mousedown', function(e) { if(_class.outsideHide && _class.outsideClick(e, _class.picker)) _class.hide() });
				
		//linkWithInput
		if(this.linkWithInput) {
			if(this.separateInput) {
				this.element.day.addEvent('keyup',  function() { _class.linkedUpdate() });
				this.element.month.addEvent('keyup',  function() { _class.linkedUpdate() });
				this.element.year.addEvent('keyup',  function() { _class.linkedUpdate() });
			} else {
				this.element.addEvent('keyup',  function() { _class.linkedUpdate() });
			}
		}
		
		this.visible = false;
		this.outsideHide = false;
	},
	
	//Position the picker
	position: function() {
		var top, left;
		
		switch(this.alignX) {
			case 'left':
				left = this.element.getLeft();
				break;
			case 'center':
				var pickerMiddle = this.pickerContent.getStyle('width').toInt() / 2;
				if(pickerMiddle == 0) pickerMiddle = 83;
				left = this.element.getLeft() + (this.element.getSize().x / 2) - pickerMiddle -
						((parseInt(this.pickerContent.getStyle('padding-left')) + parseInt(this.pickerContent.getStyle('padding-right'))) / 2);
				break;
			case 'right': default:
				left = this.element.getLeft() + this.element.getSize().x;
				break;
		}
		
		switch(this.alignY) {
			case 'bottom':
				top = this.getPos(this.element).y + this.element.getSize().y;
				break;
			case 'top': 
				top = this.getPos(this.element).y - parseInt(this.pickerContent.getStyle('height')) - 
					(parseInt(this.pickerContent.getStyle('padding-top')) + parseInt(this.pickerContent.getStyle('padding-bottom')));
				break;
			case 'inputTop': default:
				top = this.getPos(this.element).y;
		}
		
		if(this.isNumber(this.offset.x)) left += this.offset.x;
		if(this.isNumber(this.offset.y)) top += this.offset.y;
		
		this.picker.setStyles({ 'top': top, 'left': left });
	},
	
	show: function() {
    	this.position();
		if(!this.visible) {
			this.visible = true;
			var _class = this;
			this.picker.setStyles({ 'opacity': 100, 'display': 'inline' });
			this.picker.set('tween', { onComplete: function() { 
					_class.outsideHide = true; 
				}, duration: this.toggleDuration }).fade('in');
		}
	},
	
	hide: function() {
		if(this.visible) 
		{
			this.visible = false;
			this.outsideHide = false; 
			this.picker.hide();
		}
	},
	
	toggle: function() {
		if(this.visible) this.hide();
		else this.show();
	},
	
	pick: function(_date) {
		if(this.leadingZero) {
			if(_date.day < 10)   _date.day = '0' + _date.day;
			if(_date.month < 10) _date.month = '0' + _date.month;
		}
		if(this.twoDigitYear) _date.year = _date.year.toString().substring(2, 4);
		
		if(this.separateInput) {
			if(this.element.day)   this.element.day.set('value', _date.day);
			if(this.element.month) this.element.month.set('value', _date.month);
			if(this.element.year)  this.element.year.set('value', _date.year);
			this.hide();
		} else {
			switch(this.format) {
				case "m/d/y": this.element.set('value', _date.month + this.separator + _date.day + this.separator + _date.year); break;
				case "y/m/d": this.element.set('value', _date.year + this.separator + _date.month + this.separator + _date.day); break;
				case "y/d/m": this.element.set('value', _date.year + this.separator +  _date.day + this.separator + _date.month); break;
				case "d/m/y": default: this.element.set('value', _date.day + this.separator + _date.month + this.separator + _date.year);
			}
			this.hide();

			if (this.onSelect)
			    this.onSelect(this.element);

		}
	},
	
	getInputDate: function(_date) {
		var day, month, year;
		
		if(_date) {
			day = _date.day;
			month = _date.month;
			year = _date.year;
		} else if(this.separateInput) {
			day = this.element.day.get('value').toInt();
			month = this.element.month.get('value').toInt();
			year = this.element.year.get('value').toInt();
		} else {
			var date = this.element.get('value').split(this.separator);
			if(date.length != 3) return null;
			switch(this.format) {
				case "m/d/y": day = date[1]; month = date[0]; year = date[2]; break;
				case "y/m/d": day = date[2]; month = date[1]; year = date[0]; break;
				case "y/d/m": day = date[1]; month = date[2]; year = date[0]; break;
				case "d/m/y": default: day = date[0]; month = date[1]; year = date[2];
			}
		}
		
		if( !this.isNumber(day) || !this.isNumber(month) || !this.isNumber(year) ||	day == 0 || month == 0 || year == '0' ||
		    (this.twoDigitYear && year > 99) || (!this.twoDigitYear && year < 1979) || (!this.twoDigitYear && year > 2030) || month > 12 || day > 31 ) return null;
		
		if(this.twoDigitYear && this.isNumber(year) && year < 100) {
			year = year.toInt();
			if(year < 10) year = '200'+  year;
			else if(year < 70) year = '20'+  year;
			else if(year > 69) year = '19'+  year;
			else year = new Date().getFullYear();
		}
		
		return day +'/'+ month +'/'+ year;
	},
	
	//This function is being called on keyup event if linkWithInput is set to true and when a date is picked
	//If the full date is inserted the picker will change itself to that specific date (month view)
	linkedUpdate: function() {
		var _class = this;
		var date = this.getInputDate();
		if(date && this.pickedDate != date) {
			this.u('month', 'gotoPickedDate=1', function() { _class.fade(true) });
			this.pickedDate = date;
		}
	},
	
	outsideClick: function(_event, _element) {
		var mousePos = this.getMousePos(_event);
		var elementData = _element.getCoordinates();
		return (mousePos.x > elementData.left && mousePos.x < (elementData.left + elementData.width)) &&
			   (mousePos.y > elementData.top  && mousePos.y < (elementData.top + elementData.height)) ? false : true;
	},
	
	getMousePos: function(_event) {
		if(document.all) {
			return { 'x': window.event.clientX + window.getScrollLeft(),
					 'y': window.event.clientY + window.getScrollTop() };
		} else {
			return { 'x': _event.page['x'],
					 'y': _event.page['y'] };
		}
	},
	
	isNumber: function(_number) {
		if(_number == '') return false;
		return (_number >= 0) || (_number < 0) ? true : false;
	},
	
	//Retrieving positition funtions (like getCoordinates, getTop etc) don't seem to return correct values in some situations in mootools 1.2; 
	//Opera returns wrong values, IE returns too small values. This function returns the correct coordinates.
	getPos: function(_element) { 
		var x, y = 0;
		if(_element.offsetParent) {
			do {
				x += _element.offsetLeft;
				y += _element.offsetTop;
			} while(_element = _element.offsetParent);
		} else if(_element.x) {
			x += _element.x;
			y += _element.y;
		}
		return { 'x': x, 'y': y };
	}
});
/*!
    Slimbox v1.8 - The ultimate lightweight Lightbox clone
    (c) 2007-2011 Christophe Beyls <http://www.digitalia.be>
    MIT-style license.
    
    Slimbox v1.9 adopted for mysku.ru
*/

var Slimbox = (function()
{

    // Global variables, accessible to Slimbox only
    var win = window, ie6 = Browser.ie6, options, images, activeImage = -1, activeURL, prevImage, nextImage, middle, centerWidth, centerHeight,

            // Preload images
            preload = {}, preloadPrev = new Image(), preloadNext = new Image(),

            // DOM elements
            overlay, center, image, sizer, prevLink, nextLink, bottomContainer, bottom, caption, number,

            // Effects
            fxOverlay, fxResize, fxImage, fxBottom;

    /*
     * Initialization
     */

    win.addEvent("domready", function()
    {
        // Append the Slimbox HTML code at the bottom of the document
        $(document.body).adopt(
            $$(
                overlay = new Element("div#lbOverlay", {events: {click: close}}),
                center = new Element("div#lbCenter"),
                bottomContainer = new Element("div#lbBottomContainer")
            ).setStyle("display", "none")
        );

        image = new Element("div#lbImage").inject(center).adopt(
            sizer = new Element("div", {styles: {position: "relative"}})
        );


        center.adopt(
            prevLink = new Element("a#lbPrevLink[href=#]", {events: {click: previous}}),
            nextLink = new Element("a#lbNextLink[href=#]", {events: {click: next}})
        );

        bottom = new Element("div#lbBottom").inject(bottomContainer).adopt(
            new Element("a#lbCloseLink[href=#]", {events: {click: close}}),
            caption = new Element("div#lbCaption"),
            number = new Element("div#lbNumber"),
            new Element("div", {styles: {clear: "both"}})
        );
    });


    /*
        Internal functions
    */

    function position()
    {
        var scroll = win.getScroll(), size = win.getSize();
        $$(center, bottomContainer).setStyle("left", scroll.x + (size.x / 2));
    }

    function setup(open)
    {
        ["object", ie6 ? "select" : "embed"].forEach(function(tag)
        {
            Array.forEach(document.getElementsByTagName(tag), function(el)
            {
                if (open) el._slimbox = el.style.visibility;
                el.style.visibility = open ? "hidden" : el._slimbox;
            });
        });

        overlay.style.display = open ? "" : "none";
        var fn = open ? "addEvent" : "removeEvent";

        document[fn]("keydown", keyDown);
    }

    function keyDown(event)
    {
        var code = event.code;
        // Prevent default keyboard action (like navigating inside the page)
        return options.closeKeys.contains(code) ? close()
            : options.nextKeys.contains(code) ? next()
                : options.previousKeys.contains(code) ? previous()
                    : false;
    }

    function previous()
    {
        return changeImage(prevImage);
    }

    function next()
    {
        return changeImage(nextImage);
    }

    function changeImage(imageIndex)
    {
        if (imageIndex >= 0)
        {
            activeImage = imageIndex;
            activeURL = images[imageIndex][0];
            prevImage = (activeImage || (options.loop ? images.length : 0)) - 1;
            nextImage = ((activeImage + 1) % images.length) || (options.loop ? 0 : -1);

            stop();
            center.className = "lbLoading";

            preload = new Image();
            preload.onload = animateBox;
            preload.src = activeURL;
        }

        return false;
    }

    function animateBox()
    {
        center.className = "";
        fxImage.set(0);
        image.setStyles({backgroundImage: "url(" + activeURL + ")", display: ""});
        sizer.setStyle("width", preload.width);
        $$(sizer, prevLink, nextLink).setStyle("height", preload.height);

        caption.set("html", images[activeImage][1] || "");
        number.set("html", (((images.length > 1) && options.counterText) || "").replace(/{x}/, activeImage + 1).replace(/{y}/, images.length));

        if (prevImage >= 0) preloadPrev.src = images[prevImage][0];
        if (nextImage >= 0) preloadNext.src = images[nextImage][0];

        var size = win.getSize();
        var overflowStyle = {overflow: 'hidden'};

        /* 10 по каждому краю + 15px для нижней панели навигации */    
        centerWidth = Math.min(image.offsetWidth,size.x - 20);
        centerHeight = Math.min(image.offsetHeight,size.y - 35);

        if ( (centerWidth < image.offsetWidth) || (centerHeight < image.offsetHeight))
        {
            overflowStyle = {overflow: 'auto'};
        }

        center.setStyles(overflowStyle);

        var top = Math.max(0, middle - (centerHeight / 2)), check = 0, fn;
        if (center.offsetHeight != centerHeight)
        {
            check = fxResize.start({height: centerHeight, top: top});
        }
        if (center.offsetWidth != centerWidth)
        {
            check = fxResize.start({width: centerWidth, marginLeft: -centerWidth/2});
        }
        fn = function()
        {
            bottomContainer.setStyles({width: centerWidth, top: top + centerHeight, marginLeft: -centerWidth/2, visibility: "hidden", display: ""});
            fxImage.start(1);
        };
        if (check)
        {
            fxResize.chain(fn);
        }
        else
        {
            fn();
        }
    }

    function animateCaption()
    {
        if (prevImage >= 0) prevLink.style.display = "";
        if (nextImage >= 0) nextLink.style.display = "";
        fxBottom.set(-bottom.offsetHeight).start(0);
        bottomContainer.style.visibility = "";
    }

    function stop()
    {
        preload.onload = null;
        preload.src = preloadPrev.src = preloadNext.src = activeURL;
        fxResize.cancel();
        fxImage.cancel();
        fxBottom.cancel();
        $$(prevLink, nextLink, image, bottomContainer).setStyle("display", "none");
    }

    function close()
    {
        if (activeImage >= 0)
        {
            stop();
            activeImage = prevImage = nextImage = -1;
            center.style.display = "none";
            fxOverlay.cancel().chain(setup).start(0);
        }

        return false;
    }


    /*
     * API
     */

    Element.implement({
        slimbox: function(_options, linkMapper)
        {
            // The processing of a single element is similar to the processing of a collection with a single element
            $$(this).slimbox(_options, linkMapper);

            return this;
        }
    });

    Elements.implement({
        /*
            options:    Optional options object, see Slimbox.open()
            linkMapper: Optional function taking a link DOM element and an index as arguments and returning an array containing 2 elements:
                    the image URL and the image caption (may contain HTML)
            linksFilter:    Optional function taking a link DOM element and an index as arguments and returning true if the element is part of
                    the image collection that will be shown on click, false if not. "this" refers to the element that was clicked.
                    This function must always return true when the DOM element argument is "this".
        */
        slimbox: function(_options, linkMapper, linksFilter)
        {
            linkMapper = linkMapper || function(el)
            {
                return [el.href, el.title];
            };

            linksFilter = linksFilter || function()
            {
                return true;
            };

            var self = this;

            this.removeEvents("click").addEvent("click", function()
            {
                // Build the list of images that will be displayed
                var filteredLinks = self.filter(linksFilter, this);
                return Slimbox.open(filteredLinks.map(linkMapper), filteredLinks.indexOf(this), _options);
            });

            return this;
        }
    });

    return {
        open: function(_images, startImage, _options)
        {
            options = Object.append({
                loop: false,                // Allows to navigate between first and last images
                overlayOpacity: 0.8,            // 1 is opaque, 0 is completely transparent (change the color in the CSS file)
                overlayFadeDuration: 400,       // Duration of the overlay fade-in and fade-out animations (in milliseconds)
                resizeDuration: 400,            // Duration of each of the box resize animations (in milliseconds)
                resizeTransition: false,        // false uses the mootools default transition
                initialWidth: 250,          // Initial width of the box (in pixels)
                initialHeight: 250,         // Initial height of the box (in pixels)
                imageFadeDuration: 400,         // Duration of the image fade-in animation (in milliseconds)
                captionAnimationDuration: 0,      // Duration of the caption animation (in milliseconds)
                counterText: "Image {x} of {y}",    // Translate or change as you wish, or set it to false to disable counter text for image groups
                closeKeys: [27, 88, 67],        // Array of keycodes to close Slimbox, default: Esc (27), 'x' (88), 'c' (67)
                previousKeys: [37, 80],         // Array of keycodes to navigate to the previous image, default: Left arrow (37), 'p' (80)
                nextKeys: [39, 78]          // Array of keycodes to navigate to the next image, default: Right arrow (39), 'n' (78)
            }, _options || {});

            // Setup effects
            fxOverlay = new Fx.Tween(overlay, {property: "opacity", duration: options.overlayFadeDuration});
            fxResize = new Fx.Morph(center, Object.append({duration: options.resizeDuration, link: "chain"}, options.resizeTransition ? {transition: options.resizeTransition} : {}));
            fxImage = new Fx.Tween(image, {property: "opacity", duration: options.imageFadeDuration, onComplete: animateCaption});
            fxBottom = new Fx.Tween(bottom, {property: "margin-top", duration: options.captionAnimationDuration});

            // The function is called for a single image, with URL and Title as first two arguments
            if (typeof _images == "string")
            {
                _images = [[_images, startImage]];
                startImage = 0;
            }

            /* 15px для нижней панели навигации */
            middle = win.getHeight() / 2 - 15;

            centerWidth = options.initialWidth;
            centerHeight = options.initialHeight;

            center.setStyles({top: Math.max(0, middle - (centerHeight / 2)), width: centerWidth, height: centerHeight, marginLeft: -centerWidth/2, display: ""});

            fxOverlay.set(0).start(options.overlayOpacity);
            position();
            setup(1);

            images = _images;
            options.loop = options.loop && (images.length > 1);
            return changeImage(startImage);
        }
    };

})();
;
function H(){var x=navigator&&navigator.userAgent&&/\bMSIE 6\./.test(navigator.userAgent);H=function(){return x};return x}(function(){function x(b){b=b.split(/ /g);var a={};for(var c=b.length;--c>=0;){var d=b[c];if(d)a[d]=null}return a}var y="break continue do else for if return while ",U=y+"auto case char const default double enum extern float goto int long register short signed sizeof static struct switch typedef union unsigned void volatile ",D=U+"catch class delete false import new operator private protected public this throw true try ",
I=D+"alignof align_union asm axiom bool concept concept_map const_cast constexpr decltype dynamic_cast explicit export friend inline late_check mutable namespace nullptr reinterpret_cast static_assert static_cast template typeid typename typeof using virtual wchar_t where ",J=D+"boolean byte extends final finally implements import instanceof null native package strictfp super synchronized throws transient ",V=J+"as base by checked decimal delegate descending event fixed foreach from group implicit in interface internal into is lock object out override orderby params readonly ref sbyte sealed stackalloc string select uint ulong unchecked unsafe ushort var ",
K=D+"debugger eval export function get null set undefined var with Infinity NaN ",L="caller delete die do dump elsif eval exit foreach for goto if import last local my next no our print package redo require sub undef unless until use wantarray while BEGIN END ",M=y+"and as assert class def del elif except exec finally from global import in is lambda nonlocal not or pass print raise try with yield False True None ",N=y+"alias and begin case class def defined elsif end ensure false in module next nil not or redo rescue retry self super then true undef unless until when yield BEGIN END ",
O=y+"case done elif esac eval fi function in local set then until ",W=I+V+K+L+M+N+O;function X(b){return b>="a"&&b<="z"||b>="A"&&b<="Z"}function u(b,a,c,d){b.unshift(c,d||0);try{a.splice.apply(a,b)}finally{b.splice(0,2)}}var Y=(function(){var b=["!","!=","!==","#","%","%=","&","&&","&&=","&=","(","*","*=","+=",",","-=","->","/","/=",":","::",";","<","<<","<<=","<=","=","==","===",">",">=",">>",">>=",">>>",">>>=","?","@","[","^","^=","^^","^^=","{","|","|=","||","||=","~","break","case","continue",
"delete","do","else","finally","instanceof","return","throw","try","typeof"],a="(?:(?:(?:^|[^0-9.])\\.{1,3})|(?:(?:^|[^\\+])\\+)|(?:(?:^|[^\\-])-)";for(var c=0;c<b.length;++c){var d=b[c];a+=X(d.charAt(0))?"|\\b"+d:"|"+d.replace(/([^=<>:&])/g,"\\$1")}a+="|^)\\s*$";return new RegExp(a)})(),P=/&/g,Q=/</g,R=/>/g,Z=/\"/g;function $(b){return b.replace(P,"&amp;").replace(Q,"&lt;").replace(R,"&gt;").replace(Z,"&quot;")}function E(b){return b.replace(P,"&amp;").replace(Q,"&lt;").replace(R,"&gt;")}var aa=
/&lt;/g,ba=/&gt;/g,ca=/&apos;/g,da=/&quot;/g,ea=/&amp;/g,fa=/&nbsp;/g;function ga(b){var a=b.indexOf("&");if(a<0)return b;for(--a;(a=b.indexOf("&#",a+1))>=0;){var c=b.indexOf(";",a);if(c>=0){var d=b.substring(a+3,c),g=10;if(d&&d.charAt(0)==="x"){d=d.substring(1);g=16}var e=parseInt(d,g);if(!isNaN(e))b=b.substring(0,a)+String.fromCharCode(e)+b.substring(c+1)}}return b.replace(aa,"<").replace(ba,">").replace(ca,"'").replace(da,'"').replace(ea,"&").replace(fa," ")}function S(b){return"XMP"===b.tagName}
function z(b,a){switch(b.nodeType){case 1:var c=b.tagName.toLowerCase();a.push("<",c);for(var d=0;d<b.attributes.length;++d){var g=b.attributes[d];if(!g.specified)continue;a.push(" ");z(g,a)}a.push(">");for(var e=b.firstChild;e;e=e.nextSibling)z(e,a);if(b.firstChild||!/^(?:br|link|img)$/.test(c))a.push("</",c,">");break;case 2:a.push(b.name.toLowerCase(),'="',$(b.value),'"');break;case 3:case 4:a.push(E(b.nodeValue));break}}var F=null;function ha(b){if(null===F){var a=document.createElement("PRE");
a.appendChild(document.createTextNode('<!DOCTYPE foo PUBLIC "foo bar">\n<foo />'));F=!/</.test(a.innerHTML)}if(F){var c=b.innerHTML;if(S(b))c=E(c);return c}var d=[];for(var g=b.firstChild;g;g=g.nextSibling)z(g,d);return d.join("")}function ia(b){var a=0;return function(c){var d=null,g=0;for(var e=0,h=c.length;e<h;++e){var f=c.charAt(e);switch(f){case "\t":if(!d)d=[];d.push(c.substring(g,e));var i=b-a%b;a+=i;for(;i>=0;i-="                ".length)d.push("                ".substring(0,i));g=e+1;break;
case "\n":a=0;break;default:++a}}if(!d)return c;d.push(c.substring(g));return d.join("")}}var ja=/(?:[^<]+|<!--[\s\S]*?--\>|<!\[CDATA\[([\s\S]*?)\]\]>|<\/?[a-zA-Z][^>]*>|<)/g,ka=/^<!--/,la=/^<\[CDATA\[/,ma=/^<br\b/i;function na(b){var a=b.match(ja),c=[],d=0,g=[];if(a)for(var e=0,h=a.length;e<h;++e){var f=a[e];if(f.length>1&&f.charAt(0)==="<"){if(ka.test(f))continue;if(la.test(f)){c.push(f.substring(9,f.length-3));d+=f.length-12}else if(ma.test(f)){c.push("\n");++d}else g.push(d,f)}else{var i=ga(f);
c.push(i);d+=i.length}}return{source:c.join(""),tags:g}}function v(b,a){var c={};(function(){var g=b.concat(a);for(var e=g.length;--e>=0;){var h=g[e],f=h[3];if(f)for(var i=f.length;--i>=0;)c[f.charAt(i)]=h}})();var d=a.length;return function(g,e){e=e||0;var h=[e,"pln"],f="",i=0,j=g;while(j.length){var o,m=null,k,l=c[j.charAt(0)];if(l){k=j.match(l[1]);m=k[0];o=l[0]}else{for(var n=0;n<d;++n){l=a[n];var p=l[2];if(p&&!p.test(f))continue;k=j.match(l[1]);if(k){m=k[0];o=l[0];break}}if(!m){o="pln";m=j.substring(0,
1)}}h.push(e+i,o);i+=m.length;j=j.substring(m.length);if(o!=="com"&&/\S/.test(m))f=m}return h}}var oa=v([],[["pln",/^[^<]+/,null],["dec",/^<!\w[^>]*(?:>|$)/,null],["com",/^<!--[\s\S]*?(?:--\>|$)/,null],["src",/^<\?[\s\S]*?(?:\?>|$)/,null],["src",/^<%[\s\S]*?(?:%>|$)/,null],["src",/^<(script|style|xmp)\b[^>]*>[\s\S]*?<\/\1\b[^>]*>/i,null],["tag",/^<\/?\w[^<>]*>/,null]]);function pa(b){var a=oa(b);for(var c=0;c<a.length;c+=2)if(a[c+1]==="src"){var d,g;d=a[c];g=c+2<a.length?a[c+2]:b.length;var e=b.substring(d,
g),h=e.match(/^(<[^>]*>)([\s\S]*)(<\/[^>]*>)$/);if(h)a.splice(c,2,d,"tag",d+h[1].length,"src",d+h[1].length+(h[2]||"").length,"tag")}return a}var qa=v([["atv",/^\'[^\']*(?:\'|$)/,null,"'"],["atv",/^\"[^\"]*(?:\"|$)/,null,'"'],["pun",/^[<>\/=]+/,null,"<>/="]],[["tag",/^[\w:\-]+/,/^</],["atv",/^[\w\-]+/,/^=/],["atn",/^[\w:\-]+/,null],["pln",/^\s+/,null," \t\r\n"]]);function ra(b,a){for(var c=0;c<a.length;c+=2){var d=a[c+1];if(d==="tag"){var g,e;g=a[c];e=c+2<a.length?a[c+2]:b.length;var h=b.substring(g,
e),f=qa(h,g);u(f,a,c,2);c+=f.length-2}}return a}function r(b){var a=[],c=[];if(b.tripleQuotedStrings)a.push(["str",/^(?:\'\'\'(?:[^\'\\]|\\[\s\S]|\'{1,2}(?=[^\']))*(?:\'\'\'|$)|\"\"\"(?:[^\"\\]|\\[\s\S]|\"{1,2}(?=[^\"]))*(?:\"\"\"|$)|\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$))/,null,"'\""]);else if(b.multiLineStrings)a.push(["str",/^(?:\'(?:[^\\\']|\\[\s\S])*(?:\'|$)|\"(?:[^\\\"]|\\[\s\S])*(?:\"|$)|\`(?:[^\\\`]|\\[\s\S])*(?:\`|$))/,null,"'\"`"]);else a.push(["str",/^(?:\'(?:[^\\\'\r\n]|\\.)*(?:\'|$)|\"(?:[^\\\"\r\n]|\\.)*(?:\"|$))/,
null,"\"'"]);c.push(["pln",/^(?:[^\'\"\`\/\#]+)/,null," \r\n"]);if(b.hashComments)a.push(["com",/^#[^\r\n]*/,null,"#"]);if(b.cStyleComments)c.push(["com",/^\/\/[^\r\n]*/,null]);if(b.regexLiterals)c.push(["str",/^\/(?:[^\\\*\/\[]|\\[\s\S]|\[(?:[^\]\\]|\\.)*(?:\]|$))+(?:\/|$)/,Y]);if(b.cStyleComments)c.push(["com",/^\/\*[\s\S]*?(?:\*\/|$)/,null]);var d=x(b.keywords);b=null;var g=v(a,c),e=v([],[["pln",/^\s+/,null," \r\n"],["pln",/^[a-z_$@][a-z_$@0-9]*/i,null],["lit",/^0x[a-f0-9]+[a-z]/i,null],["lit",
/^(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d+)(?:e[+\-]?\d+)?[a-z]*/i,null,"123456789"],["pun",/^[^\s\w\.$@]+/,null]]);function h(f,i){for(var j=0;j<i.length;j+=2){var o=i[j+1];if(o==="pln"){var m,k,l,n;m=i[j];k=j+2<i.length?i[j+2]:f.length;l=f.substring(m,k);n=e(l,m);for(var p=0,t=n.length;p<t;p+=2){var w=n[p+1];if(w==="pln"){var A=n[p],B=p+2<t?n[p+2]:l.length,s=f.substring(A,B);if(s===".")n[p+1]="pun";else if(s in d)n[p+1]="kwd";else if(/^@?[A-Z][A-Z$]*[a-z][A-Za-z$]*$/.test(s))n[p+1]=s.charAt(0)==="@"?"lit":
"typ"}}u(n,i,j,2);j+=n.length-2}}return i}return function(f){var i=g(f);i=h(f,i);return i}}var G=r({keywords:W,hashComments:true,cStyleComments:true,multiLineStrings:true,regexLiterals:true});function sa(b,a){for(var c=0;c<a.length;c+=2){var d=a[c+1];if(d==="src"){var g,e;g=a[c];e=c+2<a.length?a[c+2]:b.length;var h=G(b.substring(g,e));for(var f=0,i=h.length;f<i;f+=2)h[f]+=g;u(h,a,c,2);c+=h.length-2}}return a}function ta(b,a){var c=false;for(var d=0;d<a.length;d+=2){var g=a[d+1],e,h;if(g==="atn"){e=
a[d];h=d+2<a.length?a[d+2]:b.length;c=/^on|^style$/i.test(b.substring(e,h))}else if(g==="atv"){if(c){e=a[d];h=d+2<a.length?a[d+2]:b.length;var f=b.substring(e,h),i=f.length,j=i>=2&&/^[\"\']/.test(f)&&f.charAt(0)===f.charAt(i-1),o,m,k;if(j){m=e+1;k=h-1;o=f}else{m=e+1;k=h-1;o=f.substring(1,f.length-1)}var l=G(o);for(var n=0,p=l.length;n<p;n+=2)l[n]+=m;if(j){l.push(k,"atv");u(l,a,d+2,0)}else u(l,a,d,2)}c=false}}return a}function ua(b){var a=pa(b);a=ra(b,a);a=sa(b,a);a=ta(b,a);return a}function va(b,
a,c){var d=[],g=0,e=null,h=null,f=0,i=0,j=ia(8);function o(k){if(k>g){if(e&&e!==h){d.push("</span>");e=null}if(!e&&h){e=h;d.push('<span class="',e,'">')}var l=E(j(b.substring(g,k))).replace(/(\r\n?|\n| ) /g,"$1&nbsp;").replace(/\r\n?|\n/g,"<br />");d.push(l);g=k}}while(true){var m;m=f<a.length?(i<c.length?a[f]<=c[i]:true):false;if(m){o(a[f]);if(e){d.push("</span>");e=null}d.push(a[f+1]);f+=2}else if(i<c.length){o(c[i]);h=c[i+1];i+=2}else break}o(b.length);if(e)d.push("</span>");return d.join("")}
var C={};function q(b,a){for(var c=a.length;--c>=0;){var d=a[c];if(!C.hasOwnProperty(d))C[d]=b;else if("console"in window)console.log("cannot override language handler %s",d)}}q(G,["default-code"]);q(ua,["default-markup","html","htm","xhtml","xml","xsl"]);q(r({keywords:I,hashComments:true,cStyleComments:true}),["c","cc","cpp","cs","cxx","cyc"]);q(r({keywords:J,cStyleComments:true}),["java"]);q(r({keywords:O,hashComments:true,multiLineStrings:true}),["bsh","csh","sh"]);q(r({keywords:M,hashComments:true,
multiLineStrings:true,tripleQuotedStrings:true}),["cv","py"]);q(r({keywords:L,hashComments:true,multiLineStrings:true,regexLiterals:true}),["perl","pl","pm"]);q(r({keywords:N,hashComments:true,multiLineStrings:true,regexLiterals:true}),["rb"]);q(r({keywords:K,cStyleComments:true,regexLiterals:true}),["js"]);function T(b,a){try{var c=na(b),d=c.source,g=c.tags;if(!C.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";var e=C[a].call({},d);return va(d,g,e)}catch(h){if("console"in window){console.log(h);
console.trace()}return b}}function wa(b){var a=H(),c=[document.getElementsByTagName("pre"),document.getElementsByTagName("code"),document.getElementsByTagName("xmp")],d=[];for(var g=0;g<c.length;++g)for(var e=0;e<c[g].length;++e)d.push(c[g][e]);c=null;var h=0;function f(){var i=(new Date).getTime()+250;for(;h<d.length&&(new Date).getTime()<i;h++){var j=d[h];if(j.className&&j.className.indexOf("prettyprint")>=0){var o=j.className.match(/\blang-(\w+)\b/);if(o)o=o[1];var m=false;for(var k=j.parentNode;k;k=
k.parentNode)if((k.tagName==="pre"||k.tagName==="code"||k.tagName==="xmp")&&k.className&&k.className.indexOf("prettyprint")>=0){m=true;break}if(!m){var l=ha(j);l=l.replace(/(?:\r\n?|\n)$/,"");var n=T(l,o);if(!S(j))j.innerHTML=n;else{var p=document.createElement("PRE");for(var t=0;t<j.attributes.length;++t){var w=j.attributes[t];if(w.specified)p.setAttribute(w.name,w.value)}p.innerHTML=n;j.parentNode.replaceChild(p,j);p=j}if(a&&j.tagName==="PRE"){var A=j.getElementsByTagName("br");for(var B=A.length;--B>=
0;){var s=A[B];s.parentNode.replaceChild(document.createTextNode("\r\n"),s)}}}}}if(h<d.length)setTimeout(f,250);else if(b)b()}f()}window.PR_normalizedHtml=z;window.prettyPrintOne=T;window.prettyPrint=wa;window.PR={createSimpleLexer:v,registerLangHandler:q,sourceDecorator:r,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ"}})();
;
/**
 * Этот файл подключается после того как все библиотеки 
 * загрузились и можно создавать глобальные переменные
 * которые дальше будут использоваться в скриптах
 */
 

/**
 * Системые всплывающие окошки, их используют практически все скрипты
 */
var msgErrorBox= new Roar({
    position: 'upperRight',
    className: 'roar-error',
    margin: {x: 30, y: 10}
}); 

var msgNoticeBox = new Roar({
    position: 'upperRight',
    className: 'roar-notice',
    margin: {x: 30, y: 10}
});     


 

;
/* exported lsVote */
var lsVote;

var lsVoteClass = new Class({

    Implements: Options,

    options: {
        classes_action: {
            voted:          'voted',
            plus:           'plus',
            minus:          'minus',
            positive:       'positive',
            negative:       'negative',
            quest:          'quest'
        },
        classes_element: {
            voting:         'voting',
            count:          'count',
            total:          'total',
            plus:           'plus',
            minus:          'minus'
        }
    },

    typeVote: {
        comment: {
            url: DIR_WEB_ROOT+'/include/ajax/voteComment.php',
            targetName: 'idComment'
        },
        topic: {
            url: DIR_WEB_ROOT+'/include/ajax/voteTopic.php',
            targetName: 'idTopic'
        },
        blog: {
            url: DIR_WEB_ROOT+'/include/ajax/voteBlog.php',
            targetName: 'idBlog'
        },
        store: {
            url: DIR_WEB_ROOT+'/include/ajax/voteStore.php',
            targetName: 'idStore'
        },
        user: {
            url: DIR_WEB_ROOT+'/include/ajax/voteUser.php',
            targetName: 'idUser'
        }
    },

    initialize: function(options)
    {
        var self = this;
        this.setOptions(options);

        /*
         * Обработка рейтинга звездочками 
         */
        $$('.stars_rating__stars').each(function(rating, index)
        {
            rating.addEvents(
            {
                click: function(event)
                {
                    event.stop();
                    self.doStarRating(event,rating);
                },
                
                mouseenter: function(event)
                {
                    event.stop();
                    self.doStarRating(event,rating);
                },
                
                mouseleave: function(event)
                {
                    event.stop();
                    self.doStarRating(event,rating);
                },
                
                mouseover: function(event)
                {
                    event.stop();
                    self.doStarRating(event,rating);    
                }
            });           
            
        });
        
    },
    
    /** 
     * Обработка манипуляций с рейтингом звездочками
     */
    doStarRating: function(event,element)
    {
        if (element.retrieve('voted',false) || element.hasClass('voted'))
        {
            return false;
        }    

        /*
         * Расчитываем насколько делеко курсор ушел от начала элемента 
         * и какая это будет оценка 
         */
        var elementWidth = element.getSize().x,
            cursorPos = event.page.x - element.getPosition().x;
        
        var value =  Math.ceil(cursorPos/elementWidth * 100 / 20);

        /* Контейнер который показывае прогресс бар */
        var ratingProgress = element.getElement('.stars_rating__progress');
        
        switch (event.type)
        {
        case 'click':
        
            if (!USER_CURRENT)
            {
                return showLoginForm();
            }
            
            var targetId = element.get('data-target-id');
            var targetType = element.get('data-target-type');
            var currentWidth = value * 20;
            
            element.store('voted',true);
            element.addClass('voted');

            ratingProgress.setStyle('width',currentWidth + '%');
            
            this.vote(targetId,element,value,targetType);
            break;
            
        case 'mouseleave':
            /* Восстанавливаем значение рейтинга */
            ratingProgress.setStyle('width',element.retrieve('width','0'));     
            element.eliminate('width');            
            break;

        case 'mouseenter':
            /* Сохраняем текущее значение ширины */
            element.store('width',ratingProgress.getSize().x);
            ratingProgress.setStyle('width','0px');            
            
            /* break специально опущен, чтобы после mouseenter сразу выполнился mouseover */
            
        case 'mouseover':
            /* Можем что-то делать, но только если у нас есть сохраненная ширина элемента */
            var savedWidth = element.retrieve('width',null);
            
            if (savedWidth == null)
            {
                break;
            }  
            
            var currentWidth = value * 20;
            
            ratingProgress.setStyle('width',currentWidth + '%');
            break;
        }
        
    },

    /**
     * Посылка голоса на сервер
     */
    vote: function(idTarget,objVote,value,type)
    {
        if (!USER_CURRENT)
        {
            return showLoginForm();
        }

        var self = this;
        objVote = $(objVote);

        if (!this.typeVote[type])
        {
            return false;
        }

        var reqParams = {};
        reqParams['value']=value;
        reqParams[this.typeVote[type].targetName]=idTarget;
        reqParams['security_ls_key']=LIVESTREET_SECURITY_KEY;

        JsHttpRequest.query(
            'POST '+this.typeVote[type].url,
            reqParams,
            function(result)
            {
                self.onVote(result, value, objVote);
            },
            true
        );
    },

    /**
     * Обработка результатов голосования
     */
    onVote: function(result, value, objVote)
    {
        if (!result)
        {
            msgErrorBox.alert('Error','Please try again later');
        }

        if (result.bStateError)
        {
            msgErrorBox.alert(result.sMsgTitle,result.sMsg);
        }
        else
        {
            msgNoticeBox.alert(result.sMsgTitle,result.sMsg);

            var divVoting = objVote.getParent('.'+this.options.classes_element.voting);
            divVoting.addClass(this.options.classes_action.voted);

            if (value > 0 )
            {
                divVoting.addClass(this.options.classes_action.plus);
            }

            if (value < 0)
            {
                divVoting.addClass(this.options.classes_action.minus);
            }

            var divCount=divVoting.getSiblings('.'+this.options.classes_element.count);

            if (divCount && divCount[0])
            {
                divCount.set('text',result.iCountVote);
            }

            var divTotal=divVoting.getChildren('.'+this.options.classes_element.total);

            result.iRating=parseFloat(result.iRating);

            divVoting.removeClass(this.options.classes_action.negative);
            divVoting.removeClass(this.options.classes_action.positive);

            if (result.iRating > 0)
            {
                divVoting.addClass(this.options.classes_action.positive);
                divTotal.set('text','+'+result.iRating);
            }

            if (result.iRating < 0)
            {
                divVoting.addClass(this.options.classes_action.negative);
                divTotal.set('text',result.iRating);
            }

            if (result.iRating == 0)
            {
                divTotal.set('text','0');
            }
        }
    }
});

window.addEvent('domready', function()
{
    lsVote = new lsVoteClass();
});
;
/* exported lsFavourite */
var lsFavourite;
var lsFavouriteClass = new Class({

    Implements: Options,

    options: {
        classes_action: {
            active:    'active',
            quest:     'quest'
        },
        classes_element: {
            favorite:  'fv'
        }
    },

    typeFavourite: {
        topic: {
            url: DIR_WEB_ROOT+'/include/ajax/topicFavourite.php',
            targetName: 'idTopic'
        },
        watchlist: {
            url: DIR_WEB_ROOT+'/include/ajax/topicFavourite.php',
            targetName: 'idTopic'
        },
        comment: {
            url: DIR_WEB_ROOT+'/include/ajax/commentFavourite.php',
            targetName: 'idComment'
        },
        talk : {
            url: DIR_WEB_ROOT+'/include/ajax/talkFavourite.php',
            targetName: 'idTalk'
        }
    },

    initialize: function(options)
    {
        this.setOptions(options);
    },

    toggle: function(idTarget,objFavourite,type)
    {

        if (!USER_CURRENT)
        {
            return showLoginForm();
        }

        objFavourite = $(objFavourite);

        if (!this.typeFavourite[type])
        {
            return false;
        }

        var self = this;
        var value = ( objFavourite.hasClass(this.options.classes_action.active) ? 0 : 1 );

        var reqParams = {};
        reqParams['type'] = value;
        reqParams[this.typeFavourite[type].targetName] = idTarget;
        reqParams['security_ls_key'] = LIVESTREET_SECURITY_KEY;

        if( type=='watchlist' )
        {
            reqParams['watchlist'] = 1;
        }

        JsHttpRequest.query(
            'POST ' + this.typeFavourite[type].url,
            reqParams,
            function(result)
            {
                $$('.dropdwn_list').hide();
                self.onToggle(result, objFavourite);
            },
            true
        );
    },

    onToggle: function(result,objFavourite)
    {
        if (!result)
        {
            msgErrorBox.alert('Error','Please try again later');
        }

        if (result.bStateError)
        {
            msgErrorBox.alert(result.sMsgTitle,result.sMsg);
        }
        else
        {
            msgNoticeBox.alert(result.sMsgTitle,result.sMsg);

            objFavourite.removeClass(this.options.classes_action.active);

            /* У нас есть возможность сменить надпись на элементе при добавлении товара в избранное */
            if (objFavourite.get('data-toggle-0') && objFavourite.get('data-toggle-1') )
            {
                if (result.bState)
                    objFavourite.set('text',objFavourite.get('data-toggle-1'));
                else
                    objFavourite.set('text',objFavourite.get('data-toggle-0'));
            }

            if (result.bState)
            {
                objFavourite.addClass(this.options.classes_action.active);
            }
        }
    }

});

/* exported toggleButtonMenu */
function toggleButtonMenu(element)
{
    $$('.button_menu').hide();
    $(element).getParent().getChildren('.dropdwn_list').toggle();
}


window.addEvent('domready', function()
{
    lsFavourite = new lsFavouriteClass();
});
/* exported lsBlockLoaderClass */ 
var lsBlockLoaderClass = new Class({

    Implements: Options,

    options: {
        classes_nav: {
            nav:     'block-nav',
            content: 'block-content',
            active:  'active'
        }
    },

    type: {
        comment_stream: {
            url: DIR_WEB_ROOT+'/include/ajax/stream_comment.php'
        },
        topic_stream: {
            url: DIR_WEB_ROOT+'/include/ajax/stream_topic.php'
        },
        blogs_top: {
            url: DIR_WEB_ROOT+'/include/ajax/blogs_top.php'
        },
        stores_top: {
            url: DIR_WEB_ROOT+'/include/ajax/stores_top.php'
        },
        blogs_join: {
            url: DIR_WEB_ROOT+'/include/ajax/blogs_join.php'
        },
        blogs_self: {
            url: DIR_WEB_ROOT+'/include/ajax/blogs_self.php'
        }
    },

    initialize: function(options)
    {
        this.setOptions(options);
    },

    toggle: function(obj,type,params)
    {
        if (!this.type[type])
        {
            return false;
        }

        var self = this;

        this.obj=$(obj);

        var liCurrent=this.obj.getParent('li');
        var blockNav=liCurrent.getParent('ul.'+self.options.classes_nav.nav);
        var liList=blockNav.getChildren('li');

        liList.each(function(li)
        {
            li.removeClass(self.options.classes_nav.active);
        });

        liCurrent.addClass(this.options.classes_nav.active);

        var blockContent=blockNav.getParent('div').getParent('div').getChildren('div.'+this.options.classes_nav.content)[0].set('html','');
        this.showStatus(blockContent);

        if(!params)
        {
            params={ security_ls_key: LIVESTREET_SECURITY_KEY };
        }
        else
        {
            params['security_ls_key']=LIVESTREET_SECURITY_KEY;
        }

        JsHttpRequest.query(
            'POST '+this.type[type].url,
            params,
            function(result, errors)
            {
                self.onLoad(result, errors, blockContent);
            },
            true
        );

    },

    onLoad: function(result, errors, blockContent)
    {
        blockContent.set('html','');
        if (!result)
        {
            msgErrorBox.alert('Error','Please try again later');
        }
        if (result.bStateError)
        {
            //msgErrorBox.alert(result.sMsgTitle,result.sMsg);
        }
        else
        {
            blockContent.set('html',result.sText);
        }
    },

    showStatus: function(obj)
    {
        var newDiv = new Element('div');
        newDiv.setStyle('text-align','center');
        newDiv.set('html','<img src="'+DIR_STATIC_SKIN+'/images/elements/loader.gif" />');

        newDiv.inject(obj);
    }
});

/* Выносим переменную в глобальное пространство */
var lsBlockLoader;

window.addEvent('domready', function() 
{       
    lsBlockLoader = new lsBlockLoaderClass();
    
    /* Устанавливаем обработчики */
    $$('.js-block-loader').addEvent('click',function(event){
        var template = this.getProperty('data-template');
        
        lsBlockLoader.toggle(this,template);   
        event.stopPropagation();
        return false;
    });
    
});
/* exported toogleFriendForm */
function toogleFriendForm()
{
    var friendForm=$('add_friend_form');
    var slideForm = new Fx.Slide('add_friend_form');

    friendForm.getElements('textarea').set('value','');
    if(friendForm.getStyle('display')=='none')
    {
        friendForm.setStyle('display','block');
        slideForm.hide();
    }
    slideForm.toggle();
    slideForm.addEvent('complete', function()
    {
        friendForm.getElement('textarea').focus();
    });

    return false;
}

/* exported ajaxAddUserFriend */
function ajaxAddUserFriend(obj,idUser,sAction)
{
    var sText, sPath;
    obj = $(obj).getParent('li');

    if(sAction != 'link' && sAction != 'accept')
    {
        sText = obj.getElement('form textarea').get('value');
        obj.getElement('form').getChildren().each(function(item)
        {
            item.setProperty('disabled','disabled');
        });
    }
    else
    {
        sText="";
    }

    if(sAction=='accept')
    {
        sPath=aRouter.profile+'/ajaxfriendaccept';
    }
    else
    {
        sPath=aRouter.profile+'/ajaxfriendadd';
    }

    JsHttpRequest.query(
        'POST ' + sPath,
        { idUser: idUser,userText: sText, security_ls_key: LIVESTREET_SECURITY_KEY },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
                obj.getElement('form').getChildren().each(function(item)
                {
                    item.removeProperty('disabled');
                });
            }
            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
                obj.getElement('form').getChildren().each(function(item)
                {
                    item.removeProperty('disabled');
                });
            }
            else
            {
                msgNoticeBox.alert(result.sMsgTitle,result.sMsg);
                if (obj)
                {
                    var item = new Element('li',{'html':result.sToggleText});
                    item.getElement('li').inject(obj.getParent('ul'),'top');
                    obj.dispose();
                }
            }
        },
        true
    );
}

/* exported ajaxDeleteUserFriend */
function ajaxDeleteUserFriend(obj,idUser,sAction)
{
    obj=$(obj).getParent('li');

    JsHttpRequest.query(
        'POST '+aRouter.profile+'/ajaxfrienddelete',
        { idUser: idUser,sAction: sAction, security_ls_key: LIVESTREET_SECURITY_KEY },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
            }

            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                msgNoticeBox.alert(result.sMsgTitle,result.sMsg);
                if (obj)
                {
                    var item = new Element('li',{'html':result.sToggleText});
                    item.getElement('li').inject(obj.getParent('ul'),'top');
                    obj.dispose();
                }
            }
        },
        true
    );
};
/* global ImageUrlChange */
/* exported ajaxJoinLeaveBlog */
function ajaxJoinLeaveBlog(obj,idBlog)
{
    obj=$(obj);

    JsHttpRequest.query(
        'POST '+DIR_WEB_ROOT+'/include/ajax/joinLeaveBlog.php',
        { idBlog: idBlog, security_ls_key: LIVESTREET_SECURITY_KEY },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
            }

            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                msgNoticeBox.alert(result.sMsgTitle,result.sMsg);
                if (obj)
                {
                    obj.getParent().removeClass('active');
                    if (result.bState)
                    {
                        obj.getParent().addClass('active');
                    }

                    var divCount=$('blog_user_count_'+idBlog);
                    if (divCount)
                    {
                        divCount.set('text',result.iCountUser);
                    }
                }
            }
        },
        true
    );
}

/* exported getSkuInfo */
function getSkuInfo(skuUrl,skuUrlContainer,skuImageContainer,skuPriceContainer)
{
    /* Нет ссылки на товар, нечего обрабатывать */
    if (skuUrl.trim() == "")
    {
        return;
    }

    var skuImage = (skuImageContainer && $(skuImageContainer) ) ? $(skuImageContainer).value : '';
    var skuPrice = (skuPriceContainer && $(skuPriceContainer) ) ? $(skuPriceContainer).value : '';

    ImageUrlChange('/templates/skin/mysku.v3/images/elements/loader_large.gif');

    JsHttpRequest.query(
        'POST '+DIR_WEB_ROOT+'/include/ajax/skuInfo.php',
        { skuUrl: skuUrl, security_ls_key: LIVESTREET_SECURITY_KEY  },
        function(result)
        {
            var imageUpdated = false;

            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
                ImageUrlChange(skuImage);
                return;
            }

            if (result.bIsWarning)
            {
                msgErrorBox.alert('Error',result.sWarningText);
                ImageUrlChange(skuImage);
                return;
            }

            if (! result.bStateError)
            {
                if ( (skuPrice.trim() == '') && result.sPrice && skuPriceContainer && $(skuPriceContainer) )
                {
                    $(skuPriceContainer).set('value',result.sPrice);
                }

                if ((skuImage.trim() == '') && result.sImageUrl && skuImageContainer && $(skuImageContainer))
                {
                    $(skuImageContainer).set('value',result.sImageUrl);
                    ImageUrlChange(result.sImageUrl);
                    imageUpdated = true;
                }

                if (result.sSkuUrl && skuUrlContainer && $(skuUrlContainer))
                {
                    $(skuUrlContainer).set('value',result.sSkuUrl);
                }

            } /* ! result.bStateError */

            /* 
             * Мы не обновили картинку , поэтому убираем загрузчик 
             */
            if (imageUpdated == false)
            {
                ImageUrlChange(skuImage);
            }

        },
        true
    );
}
;
/* global lsPanel */

var winFormImgUpload;
var sToLoadOverride = null; /* Куда выводить результат */
var sLoadOutputFormat = 'html'; /* В каком формате выводить результат загрузки html или plain */
var bIsToolbarHidden = true;

var winFormMultiImgUpload; /* HTML форма мульти загрузки */
var oMultiUpload = false;  /* Сам объект */
var oMultiUploadData = {   /* Допольнительные данные */
    'totalSize' : 0,
    'uploadedSizePartial' :0,
    'uploadedSizeFull' : 0
};

/**
 * Подписка/отписка
 */
/* exported subscribeToggle */
function subscribeToggle(sTargetType, iTargetId, sMail, iValue)
{
    JsHttpRequest.query(
        aRouter['subscribe']+'/ajax-subscribe-toggle',
        { security_ls_key: LIVESTREET_SECURITY_KEY, target_type: sTargetType, target_id: iTargetId, mail: sMail, value: iValue },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
            }

            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                msgNoticeBox.alert(result.sMsgTitle,result.sMsg);
            }
        },
        true
    );
    return false;
}

/* exported subscribeToggleButton */
function subscribeToggleButton(sTargetType, iTargetId, sMail, obj)
{
    obj=$(obj);
    var iValue = obj.getParent().hasClass('active') ? 0 : 1;

    JsHttpRequest.query(
        aRouter['subscribe']+'/ajax-subscribe-toggle',
        { security_ls_key: LIVESTREET_SECURITY_KEY, target_type: sTargetType, target_id: iTargetId, mail: sMail, value: iValue },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
            }

            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                msgNoticeBox.alert(result.sMsgTitle,result.sMsg);

                if (!iValue)
                {
                    obj.getParent().removeClass('active');
                }
                else
                {
                    obj.getParent().addClass('active');
                }

            }
        },
        true
    );
    return false;
}

/**
 *
 * Загружает всех друзей/подписчиков/на кого подписан/  пользователя
 *
 * @param iUserId
 * @param sActionName
 * @returns {Boolean}
 */
/* exported userLoadRelated */
function userLoadRelated(iUserId,sActionName)
{
    var container;
    var ajaxUrl;

    switch (sActionName)
    {
        case 'friends':
            container = $('user_friends');
            ajaxUrl = aRouter['profile']+'/ajax-load-friends';
            break;

        case 'subscribe_to':
            container = $('user_subscribe_to');
            ajaxUrl = aRouter['profile']+'/ajax-load-subscribe-to';
            break;

        case 'subscribers':
            container = $('user_subscribers');
            ajaxUrl = aRouter['profile']+'/ajax-load-subscribers';
            break;

        default:
            return;
    }

    container.getElement('.show-related-more').destroy();

    JsHttpRequest.query(
        ajaxUrl,
        { security_ls_key: LIVESTREET_SECURITY_KEY, user_id: iUserId },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
            }

            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                if (result.aLogins)
                {
                    Array.each(result.aLogins, function (login)
                    {
                        var el = new Element('a', { 'href':aRouter['profile']+'/'+login, text: login } );
                        el.inject(container);
                        container.appendChild(document.createTextNode(" "));
                    });
                }
            }
        },
        true
    );
    return false;
}

/* exported scrollToTop */
function scrollToTop()
{
    new Fx.Scroll(document.body,{duration:400}).toTop();
}

/**
 * Показывает тулбар только если пользователь прокрутил немного вниз
 */
/* exported toolbarScrollHandler */
function toolbarScrollHandler()
{
    var iLine1 = 600; /* когда начинает показываться тулбар */
    var iLine2 = 900; /* когда он полностью показан */

    var iCurrentLine = window.getScroll().y;

    if ( (!bIsToolbarHidden) && (iCurrentLine < iLine1) )
    {
        $('toolbar').setStyle('visibility','hidden');
        bIsToolbarHidden = true;
        return;
    }

    if ( (bIsToolbarHidden) && (iCurrentLine > iLine2) )
    {
        $('toolbar').setStyle('visibility','visible').setStyle('opacity',1);
        bIsToolbarHidden = false;
        return;
    }

    if ( (iCurrentLine <= iLine2) && (iCurrentLine >= iLine1) )
    {
        var opacity = (iCurrentLine - iLine1) / (iLine2 - iLine1);
        $('toolbar').setStyle('visibility','visible').setStyle('opacity',opacity);
        return;
    }

}

/* exported ajaxTextPreview */
function ajaxTextPreview(textId,save,divPreview)
{
    var text = $(textId).value;

    JsHttpRequest.query(
        'POST '+DIR_WEB_ROOT+'/include/ajax/textPreview.php',
        { text: text, title: '', save: save, security_ls_key: LIVESTREET_SECURITY_KEY },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
            }

            if (result.bStateError)
            {
                msgErrorBox.alert('Error','Please try again later');
            }
            else
            {
                if (!divPreview)
                {
                    divPreview='text_preview';
                }
                if ($(divPreview))
                {
                    $(divPreview).set('html',result.sText).setStyle('display','block');
                }
            }
        },
        true
    );
}

/* exported requestRemoderation */
function requestRemoderation(idTopic)
{
    JsHttpRequest.query(
        'POST '+DIR_WEB_ROOT+'/include/ajax/requestRemoderation.php',
        { idTopic: idTopic,  security_ls_key: LIVESTREET_SECURITY_KEY},

        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Ошибка','Please try again later');
            }

            else if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                msgNoticeBox.alert(result.sMsgTitle,result.sMsg);
            }
        },
        true
    );
}

/* exported ajaxSkuPreview */
function ajaxSkuPreview(skuUrl, skuTitle, skuImageUrl, skuPrice, divPreview)
{
    var storeName = $('blog_id').getSelected()[0].get('html');
    var skuCategory = $('sku_category').getSelected()[0].get('html');
    var topicText = $('sku_text').value;

    skuUrl = $(skuUrl).value;
    skuTitle =  $(skuTitle).value;
    skuImageUrl = $(skuImageUrl).value;
    skuPrice = $(skuPrice).value;

    $(divPreview).getParent('div').setStyle('display','block');

    JsHttpRequest.query(
        'POST '+DIR_WEB_ROOT+'/include/ajax/skuPreview.php',
        { storeName: storeName,
            skuUrl: skuUrl,
            skuTitle: skuTitle,
            skuImageUrl: skuImageUrl,
            skuPrice: skuPrice,
            skuCategory: skuCategory,
            topicText: topicText, security_ls_key: LIVESTREET_SECURITY_KEY, save: true },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
            }

            if (result.bStateError)
            {
                msgErrorBox.alert('Error','Please try again later');
            }
            else
            {
                if ($(divPreview))
                {
                    var html = '<div class="topic">' +
                    '<h1 style="border-bottom:0px;" class="title">' + result.sSkuTitle + '</h1>' +
                    '<div class="content">' +
                        '<img class="product_image" src="' + result.sSkuImageUrl + '"/>' +
                            '<div class="price_go2_same">' +
                                '<span>Цена: ' + result.iSkuPrice + '</span>' +
                                '<ul class="go2_same">' +
                                    '<li><a href="#">Перейти в магазин</a></li>' +
                                '</ul>' +
                            '</div><br/>' + result.sTopicText +
                      '</div>' +
                    '</div>';

                    $(divPreview).set('html',html);
                }
            }
        },
        true
    );
}

/* exported checkAllTalk */
function checkAllTalk(checkbox)
{
    $$('.form_talks_checkbox').each(function(chk)
    {
        if (checkbox.checked)
        {
            chk.checked=true;
        }
        else
        {
            chk.checked=false;
        }
    });
}

/* exported checkAllReport */
function checkAllReport(checkbox)
{
    $$('.form_reports_checkbox').each(function(chk)
    {
        if (checkbox.checked)
        {
            chk.checked=true;
        }
        else
        {
            chk.checked=false;
        }
    });
}

/* exported checkAllPlugins */
function checkAllPlugins(checkbox)
{
    $$('.form_plugins_checkbox').each(function(chk)
    {
        if (checkbox.checked)
        {
            chk.checked=true;
        }
        else
        {
            chk.checked=false;
        }
    });
}

/* exported showMultiImgUploadForm */
function showMultiImgUploadForm(sToLoad)
{
    if (!winFormMultiImgUpload)
    {
        winFormMultiImgUpload=new StickyWin.Modal({content: $('window_multi_load_img'), closeClassName: 'close-block', useIframeShim: false,
            modalOptions: {modalStyle:{'z-index':900}} });

        initMultiUpload(sToLoad);
    }
    else
    {
        /* Очищаем */
        clearMultiImgUploadForm();
    }

    winFormMultiImgUpload.show();
    winFormMultiImgUpload.pin(true);
    return false;
}

function hideMultiImgUploadForm()
{
    clearMultiImgUploadForm();
    winFormMultiImgUpload.hide();
}

function clearMultiImgUploadForm()
{
    if (!oMultiUpload)
        return false;

    oMultiUpload.clearQueue();

    oMultiUploadData.totalSize = 0;
    oMultiUploadData.uploadedSizePartial = 0;
    oMultiUploadData.uploadedSizeFull = 0;

    updateMultiImgUploadForm();
}

function updateMultiImgUploadForm()
{
    /*
     * Позиция прогресс бара вычисляется как-то странно
     * -400px - полностью пустой
     * -150px - полностью полный
     */
    var progress = (oMultiUploadData.totalSize == 0) ? 0 : Math.ceil((oMultiUploadData.uploadedSizeFull + oMultiUploadData.uploadedSizePartial)/ oMultiUploadData.totalSize * 100);
    var progressPos = -400 + Math.ceil(250 *  progress/100);

    $('multi-overall-title').set('html','Всего для загрузки (' + oMultiUploadData.totalSize +' KB)');
    $('multi-overall-progress').setStyle('background-position-x',progressPos + 'px');
    $('multi-overall-progress-title').set('html', progress + '%');
}


/* Init fancy upload */
function initMultiUpload(sToLoad)
{
    /*
     * Документация находится по адресу
     * https://www.lpology.com/code/ajaxuploader/docs.php
     *
     * Внимание!!
     * Мы используем модифированную версию, для корректной работы
     * нам нужно file.id в callback
     *
     * во всех callback передается fileObj, а не отдельные параметры
     * как было в исходной либе
     */
    oMultiUploadData.totalSize = 0;
    oMultiUploadData.uploadedSizePartial = 0;
    oMultiUploadData.uploadedSizeFull = 0;

    oMultiUpload = new ss.SimpleUpload({
        button: 'multi-browse-button',
        url: $('form_multi_load_img').action,
        //debug: true,
        name: 'img_file',          /* Под каким полем отправлять файл на сервер */

        multiple: true,        /* Set to true to enable multiple, concurrent file uploads */
        multipleSelect: true,  /* Set to true to enable multiple file selection. */
        maxUploads: 1,         /* Max number of simultaneous uploads */

        /*
         * Эти функции отрабатывают только при отправке файла
         * поэтому при добавлении файла, проверяем ограничения сами
         */
        //maxSize: ConverterOptions.fileSizeLimit,
        allowedExtensions: ['jpg','jpeg','gif','png'],
        accept: '.jpg,.jpeg,.gif,.png',

        queue: true,
        multipart: true,
        autoSubmit: false,
        responseType: 'json',

        /* При добавлении файлов */
        onChange: function(fileObj)
        {
            oMultiUploadData.totalSize += fileObj.size;
            updateMultiImgUploadForm();
        },
        onAllDone: function()
        {
            hideMultiImgUploadForm();
        },
        onProgress: function(progress,fileObj)
        {
            /* Тут приходит только процент загрузки текущего файла */
            oMultiUploadData.uploadedSizePartial = Math.ceil(progress * fileObj.size / 100);
            updateMultiImgUploadForm();
        },
        onDone: function(fileObj, status, textStatus, response)
        {

            oMultiUploadData.uploadedSizePartial = 0;
            oMultiUploadData.uploadedSizeFull += fileObj.size;

            if (response.js.bStateError)
            {
                msgErrorBox.alert(response.js.sMsgTitle,response.js.sMsg);
            }
            else
            {
                $('multi-upload-holder').show();

                /* Мы получили файл, вставляем его */
                var img = new Element('img', {'width': '100', 'height' : '60', 'src' : response.js.sFilePath}).inject($('multi-upload-images-container'), 'bottom');
                img.addEvent('click', function()
                {
                    lsPanel.putText(sToLoad,response.js.sText);
                });
            }

            /* Если еще есть файлы, то продолжаем загрузку */
            if (oMultiUpload.getQueueSize() > 0 )
                oMultiUpload.submit();

        },
        onError: function(fileObj, errorType, status, statusText, response)
        {

            msgErrorBox.alert('Error', 'Ошибка при загрузке файла.' + "\n" + statusText);

            oMultiUploadData.uploadedSizePartial = 0;
            oMultiUploadData.uploadedSizeFull += fileObj.size;

            /* Если еще есть файлы, то продолжаем загрузку */
            if (oMultiUpload.getQueueSize() > 0 )
                oMultiUpload.submit();
        }
    });

    updateMultiImgUploadForm();
}


/* exported showImgUploadForm */
function showImgUploadForm()
{
    if (!winFormImgUpload)
    {
        winFormImgUpload = new StickyWin.Modal(
            {
                content: $('window_load_img'),
                closeClassName: 'close-block',
                useIframeShim: false,
                modalOptions: {modalStyle:{'z-index':900}}
            });
    }

    winFormImgUpload.show();
    winFormImgUpload.pin(true);
    $$('input[name=img_file]').set('value', '');
    $$('input[name=img_url]').set('value', 'http://');
    return false;
}

function hideImgUploadForm()
{
    winFormImgUpload.hide();
}


/* exported ajaxUploadImg */
function ajaxUploadImg(value,sToLoad)
{
    var req = new JsHttpRequest();
    var sImgText = '';

    req.onreadystatechange = function()
    {
        if (req.readyState == 4)
        {
            if (req.responseJS.bStateError)
            {
                msgErrorBox.alert(req.responseJS.sMsgTitle,req.responseJS.sMsg);
            }
            else
            {
                if (sLoadOutputFormat == 'plain')
                    sImgText = req.responseJS.sFilePath;
                else
                    sImgText = req.responseJS.sText;

                if (sToLoadOverride)
                    lsPanel.putText(sToLoadOverride,sImgText);
                else
                    lsPanel.putText(sToLoad,sImgText);

                hideImgUploadForm();
            }

            /* Очищаем переменную, те если заливаем в не стандартное место,
            * то нужно устанавливать эту переменную перед каждым вызовом */
            sToLoadOverride = null;
            sLoadOutputFormat = 'html'; /* значение по умолчанию */
        }
    };

    req.open(null, DIR_WEB_ROOT+'/include/ajax/uploadImg.php', true);
    req.send( { value: value, security_ls_key: LIVESTREET_SECURITY_KEY } );
}

/* exported checkCategory */
function checkCategory(source,prefix)
{
    var mainCategory = $(prefix + '_category').getSelected();
    var subCategory = $(prefix + '_sub_category').getSelected();

    /* открывает или закрывает субкатегорию в зависимости от значения основной */
    if (source == 'main')
    {
        if (mainCategory && (mainCategory.get('value') >0))
            $(prefix + '_sub_category_holder').show();
        else
            $(prefix + '_sub_category_holder').hide();
    }

    /* Проверяет, чтобы не была выбрана основная и суб категории одновременно */
    if (mainCategory && subCategory)
    {
        var mainCategoryId = parseInt(mainCategory.get('value'));
        var subCategoryId = parseInt(subCategory.get('value'));

        var aMainCategoryPid = mainCategory.get('data-pid').toString();
        aMainCategoryPid.split(',');

        var aSubCategoryPid = subCategory.get('data-pid').toString();
        aSubCategoryPid.split(',');

        /* Выбрана как основная, так и дополнительная категория */
        if ( (mainCategoryId > 0) && (subCategoryId > 0) )
        {
            var showError = false;

            /* Одна из категорий имеет родителем другую  */
            if (!showError && aSubCategoryPid.indexOf(mainCategoryId) != -1)
                showError = true;

            if (!showError && aMainCategoryPid.indexOf(subCategoryId) != -1)
                showError = true;

            if (showError)
            {
                msgErrorBox.alert('Внимание','Пожалуйста не выбирайте основную и дополнительную категории из одного раздела каталога.');
            }
        }
    }
}

Slimbox.scanPage = function()
{
    var collection = [];
    var downloadKey = LIVESTREET_DOWNLOAD_KEY.replace(/;/g,'&');

    $$("div.topic img").each(function(el)
    {
        var imagesUrl = '(http.{0,1}://[a-z\.]{1,8}\.mysku-st\.ru/uploads/(images|pictures)/)';
        var regExp = new RegExp(imagesUrl,"g");

        var alink = '';
        var src = '';

        if ( el.get('rel') == 'lbox')
        {
            /* Prepare link to full size image */
            src = el.get('src');
            if (src.test(regExp))
            {
                /* Wrap each image with link */
                alink = new Element('a', {'class': 'lbox', href: src,'data-fullsize':src.replace(regExp,'$1original/') + '?' + downloadKey});
                alink.wraps(el);
                collection.push(alink);
            }
        }
    });

    $$(collection).slimbox(
        {
            overlayFadeDuration:0,
            resizeDuration:0,
            counterText: "Изображение {x} из {y}"
        },
        function(el)
        {
            /* Mapper function */
            return [ $(el).get('data-fullsize') || el.href, el.title ];
        },
        null);
};

/**
 *  Переключение между полной и мобильной версиями
 */
/* exported changeDisplayMode */
function changeDisplayMode(theme)
{
    /* Устанавливаем куку */
    Cookie.write('site_display_mode', theme, {
        duration: 365
    });

    /* Перегружаемся */
    location.reload();

    return false;
}


/* exported blacklistToggle */
function blacklistToggle(iUserId)
{
    JsHttpRequest.query(
        'POST '+ aRouter.profile + '/blacklist/toggle',
        {
            'security_ls_key': LIVESTREET_SECURITY_KEY,
            'user_id': iUserId
        },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
                return false;
            }

            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                $('blacklist_button').set('html',result.sText);
                msgNoticeBox.alert(result.sMsgTitle,result.sMsg);
            }
        },
        true
    );

    return false;
}

/* exported blacklistToggleButton */
function blacklistToggleButton(iUserId, obj)
{
    obj=$(obj);
    var iValue = obj.getParent().hasClass('active')?0:1;
    JsHttpRequest.query(
        'POST '+ aRouter.profile + '/blacklist/toggle',
        {
            'security_ls_key': LIVESTREET_SECURITY_KEY,
            'user_id': iUserId
        },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
                return false;
            }

            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                if (!iValue)
                {
                    obj.getParent().removeClass('active');
                }
                else
                {
                    obj.getParent().addClass('active');
                }
                msgNoticeBox.alert(result.sMsgTitle,result.sMsg);
            }
        },
        true
    );
    return false;
}

/**
 * Открывает или закрывает редактор на весь экран
 */
/* exported fullscreenToggle */
function fullscreenToggle()
{
    if ( $('body').hasClass('fullscreen'))
    {
        $('text-editor').removeClass('fullscreen');
        $('body').removeClass('fullscreen');
    }
    else
    {
        $('text-editor').addClass('fullscreen');
        $('body').addClass('fullscreen');
    }

    return false;
}

/**
 * Загрузка содержимого
 */
function onBodyLoad()
{
    prettyPrint();
}

/**
 * Создание табов
 */
/* exported createTabs */
function createTabs(headers,panels)
{
    headers.each(function(tab, index)
    {
        tab.addEvents(
            {
                click: function(event)
                {
                    event.stop();

                    headers.removeClass('active');
                    headers[index].addClass('active');

                    panels.removeClass('active');
                    panels[index].addClass('active');
                }
            });
    });
}


if (!/android|iphone|ipod/i.test(navigator.userAgent))
{
    window.addEvent("domready", Slimbox.scanPage);
}

/* Убираем из адреснойстроки не нужные хештеги */
window.addEvent("load", function()
{
    var histAPI = !!(window.history && history.pushState);

    if (histAPI && (document.location.hash == "#mcut" || document.location.hash == "#comments"))
    {
        history.replaceState({}, document.title, document.location.pathname + document.location.search);
    }
});

;
var winFormLogin=false;

function showLoginForm()
{
    if (!winFormLogin)
    {
        winFormLogin=new StickyWin.Modal({content: $('login-form'), closeClassName: 'close-block', useIframeShim: false});
    }

    winFormLogin.show();
    winFormLogin.pin(true);
    return false;
}

function hideLoginForm()
{
    winFormLogin.hide();
}

;
var lsPanelClass = new Class({

    initialize: function()
    {

    },

    putText: function(obj,text)
    {
        obj=$(obj);
        var scrollLeft=obj.scrollLeft;
        var scrollTop=obj.scrollTop;

        if (Browser.Engine.trident && document.selection)
        {
            obj.focus();
            var sel=document.selection.createRange();
            sel.text=text;
        }
        else
        {
            obj.insertAtCursor(text,false);
        }

        obj.scrollLeft=scrollLeft;
        obj.scrollTop=scrollTop;

        /* 
         * Запускаем обработчик onchange
         * В первую очередь это нужно для полей куда можно загрузить изображение
         */
        if ('UIEvent' in window)
        {
            var event = new UIEvent('change', {
                'view': window,
                'bubbles': true,
                'cancelable': true
            });

            obj.dispatchEvent(event);
        }
    },

    putTag: function(obj,tag)
    {
        this.putText(obj,'<'+tag+'/>');
    },

    putTextAround: function(obj,textStart,textEnd)
    {
        obj=$(obj);
        var scrollLeft=obj.scrollLeft;
        var scrollTop=obj.scrollTop;

        if (Browser.Engine.trident && document.selection)
        {
            obj.focus();
            var sel=document.selection.createRange();
            sel.text = textStart+sel.text+textEnd;
        }
        else
        {
            obj.insertAroundCursor({
                before: textStart,
                defaultMiddle: '',
                after: textEnd
            });
        }

        obj.scrollLeft=scrollLeft;
        obj.scrollTop=scrollTop;
    },

    putTagAround: function(obj,tagStart,tagEnd)
    {
        if (!tagEnd)
        {
            tagEnd=tagStart;
        }
        this.putTextAround(obj,'<'+tagStart+'>','</'+tagEnd+'>');
    },

    putTagUrl: function(obj,sPromt)
    {
        obj=$(obj);
        var url = prompt(sPromt,'http://');
        if (url)
        {
            var selText=obj.getSelectedText();
            if (selText.trim() == '')
            {
                selText = 'ссылка';
            }
            
            this.putText(obj,'<a href="'+url+'">'+selText+'</a>');
        }
    },

    putQuote: function(obj)
    {
        obj=$(obj);
        var selText=this.getSelectedText();

        if (selText && selText != "")
        {
            this.putText(obj,'<blockquote>'+selText+'</blockquote>');
        }
        else
        {
            this.putTagAround(obj,'blockquote');
        }
    },

    getSelectedText: function()
    {
        if (Browser.Engine.trident) return document.selection.createRange().text;
        //if (window.khtml) return window.getSelection();
        return document.getSelection();
    },

    putList: function(obj,select)
    {
        obj=$(obj);
        var typeList = select.value;
        var selText=obj.getSelectedText();

        if (selText)
        {
            selText = selText.replace('/\r/g', '');
            selText = selText != '' ? selText : ' ';
            selText = selText.replace(new RegExp('^(.+)', 'gm'), '\t<li>$1</li>');
            this.putText(obj,'<'+typeList+'>\n'+selText+'\n</'+typeList+'>');
        }
        else
        {
            this.putTextAround(obj,'<'+typeList+'>\n\t<li>','</li>\n</'+typeList+'>');
        }

        select.selectedIndex=0;
    }
});

/* exported lsPanel */
var lsPanel;

window.addEvent('domready', function()
{
    lsPanel = new lsPanelClass();
});
;
/* global lsBlockStream */
/* global ajaxTextPreview */
var lsCmtTreeClass = new Class({

    Implements: Options,

    options: {
        img: {
            path:         'images/icons/',
            openName:     'open.gif',
            closeName:    'close.gif'
        },
        classes: {
            visible:     'lsCmtTree_visible',
            hidden:      'lsCmtTree_hidden',
            openImg:     'lsCmtTree_open',
            closeImg:    'lsCmtTree_close'
        }
    },

    typeComment: {
        topic: {
            url_add: aRouter.blog+'/ajaxaddcomment',
            url_response: DIR_WEB_ROOT+'/include/ajax/commentResponse.php'
        },
        profile: {
            url_add: aRouter.profile+'/ajaxaddcomment',
            url_response: DIR_WEB_ROOT+'/include/ajax/commentResponseProfile.php'
        },
        talk: {
            url_add: aRouter.talk+'/ajaxaddcomment',
            url_response: aRouter.talk+'/ajaxresponsecomment'
        }
    },

    /* 
     * Конвертирует форму в массив JSON 
     * Используем для  IE11 так как встроенный метод JsHttpRequest где-то глючит 
     * 
     */    
    toJSON: function(form)
    {
        var json = {};
        $(form).getElements('input, select, textarea', true).each(function(el)
        {
            if (!el.name || el.disabled || el.type == 'submit' || el.type == 'reset' || el.type == 'file') return;
            var value = (el.tagName.toLowerCase() == 'select') ? Element.getSelected(el).map(function(opt)
            {
                return opt.value;
            }) : ((el.type == 'radio' || el.type == 'checkbox') && !el.checked) ? null : el.value;
            Array.from(value).each(function(val)
            {
                if (typeof val != 'undefined')
                {
                    json[el.name] = val;
                }
            });
        });
        return json;
    },

    initialize: function(options)
    {
        this.setOptions(options);
        this.make();
        this.aCommentNew=[];
        this.iCurrentShowFormComment=0;
        this.iCommentIdLastView=null;
        this.countNewComment=0;
        this.docScroller = new Fx.Scroll(document.getDocument());
        this.hideCommentForm(this.iCurrentShowFormComment);
    },

    make: function()
    {
        var self = this;

        var aImgFolding=$$('img.folding');

        aImgFolding.each(function(img)
        {
            var divComment = img.getParent('div').getParent('div').getParent('div').getChildren('div.comment-children')[0];
            if (divComment && divComment.getChildren('div.comment')[0])
            {
                self.makeImg(img);
            }
            else
            {
                img.setStyle('display','none');
            }
        });
    },

    makeImg: function(img)
    {
        var self = this;

        img.setStyle('cursor', 'pointer');
        img.setStyle('display','inline');
        img.addClass(this.options.classes.closeImg);
        img.removeEvents('click');
        img.addEvent('click',function()
        {
            self.toggleNode(img);
        });
    },

    toggleNode: function(img)
    {
        var b = img.hasClass(this.options.classes.closeImg);
        if (b)
        {
            this.collapseNode(img);
        }
        else
        {
            this.expandNode(img);
        }
    },

    expandNode: function(img)
    {
        var self = this;
        img.setProperties({'src': this.options.img.path + this.options.img.closeName});
        img.removeClass(this.options.classes.openImg);
        img.addClass(this.options.classes.closeImg);
        var divComment = img.getParent('div').getParent('div').getParent('div').getChildren('div.comment-children')[0];

        divComment.removeClass(self.options.classes.hidden);
        divComment.addClass(self.options.classes.visible);
    },

    collapseNode: function(img)
    {
        var self = this;
        img.setProperties({'src': this.options.img.path + this.options.img.openName});
        img.removeClass(this.options.classes.closeImg);
        img.addClass(this.options.classes.openImg);
        var divComment = img.getParent('div').getParent('div').getParent('div').getChildren('div.comment-children')[0];
        divComment.removeClass(self.options.classes.visible);
        divComment.addClass(self.options.classes.hidden);
    },

    expandNodeAll: function()
    {
        var self = this;
        var aImgFolding=$$('img.'+this.options.classes.openImg);
        aImgFolding.each(function(img)
        {
            self.expandNode(img);
        });
    },

    collapseNodeAll: function()
    {
        var self = this;
        var aImgFolding=$$('img.'+this.options.classes.closeImg);
        aImgFolding.each(function(img)
        {
            self.collapseNode(img);
        });
    },

    injectComment: function(idCommentParent,idComment,sHtml)
    {
        var divChildren;
        var newComment = new Element('div',{'class':'comment', 'id': 'comment_id_'+idComment});
        newComment.set('html',sHtml);

        if (idCommentParent)
        {
            this.expandNodeAll();
            divChildren = $('comment-children-'+idCommentParent);
            divChildren.appendChild(newComment);
        }
        else
        {
            divChildren = $('comment-children-0');
            newComment.inject(divChildren,'before');
        }
    },

    responseNewComment: function(idTarget,typeTarget,objImg,selfIdComment,bNotFlushNew)
    {
        var self = this;

        if (!bNotFlushNew)
        {
            var aDivComments=$$('.main_side');
            aDivComments.each(function(item)
            {
                var divContent=item;
                if (divContent)
                {
                    divContent.removeClass('new');
                    divContent.removeClass('view');
                }
            });
        }

        var idCommentLast = this.idCommentLast;

        objImg=$(objImg);

        if (objImg)
        {
            objImg.removeClass('update-comments');
            objImg.addClass('loading-comments');            
        }

        (function()
        {
            JsHttpRequest.query(
                'POST '+self.typeComment[typeTarget].url_response,
                { idCommentLast: idCommentLast, idTarget: idTarget, typeTarget: typeTarget, security_ls_key: LIVESTREET_SECURITY_KEY },
                function(result)
                {

                    if (objImg)
                    {
                        objImg.removeClass('loading-comments');            
                        objImg.addClass('update-comments');
                    }

                    if (!result)
                    {
                        msgErrorBox.alert('Error','Please try again later');
                    }

                    if (result.bStateError)
                    {
                        msgErrorBox.alert(result.sMsgTitle,result.sMsg);
                    }
                    else
                    {
                        var aCmt=result.aComments;
                        var iCountOld=0;

                        if (bNotFlushNew)
                        {
                            iCountOld=self.countNewComment;
                        }
                        else
                        {
                            self.aCommentNew=[];
                        }

                        if (selfIdComment)
                        {
                            self.setCountNewComment(aCmt.length-1+iCountOld);
                            self.hideCommentForm(self.iCurrentShowFormComment);
                        }
                        else
                        {
                            self.setCountNewComment(aCmt.length+iCountOld);
                        }

                        aCmt.each(function(item)
                        {
                            if (!(selfIdComment && selfIdComment==item.id))
                            {
                                self.aCommentNew.extend([item.id]);
                            }
                            self.injectComment(item.idParent,item.id,item.html);
                        });

                        if (selfIdComment && $('comment_id_'+selfIdComment))
                        {
                            self.scrollToComment(selfIdComment);
                        }

                        if (aCmt.length>0 && result.iMaxIdComment)
                        {
                            self.setIdCommentLast(result.iMaxIdComment);
                            var countComments=$('count-comments');
                            countComments.set('text',parseInt(countComments.get('text'))+aCmt.length);

                            if ($('js-block-comment-loader') && (typeof lsBlockLoader == 'object'))
                            {
                                lsBlockLoader.toggle($('js-block-comment-loader'),'comment_stream');
                            }
                        }
                    }
                },
                true
            );
        }).delay(1000);
    },

    setIdCommentLast: function(id)
    {
        this.idCommentLast=id;
    },

    setCountNewComment: function(count)
    {
        this.countNewComment=count;
        var divCountNew=$('new-comments');

        if (!divCountNew)
            return;

        if (this.countNewComment>0)
        {
            divCountNew.set('text',this.countNewComment);
            divCountNew.setStyle('display','block');
        }
        else
        {
            this.countNewComment=0;
            divCountNew.set('text',0);
            divCountNew.setStyle('display','none');
        }
    },

    goNextComment: function()
    {
        if (this.aCommentNew[0])
        {
            if ($('comment_id_'+this.aCommentNew[0]))
            {
                this.scrollToComment(this.aCommentNew[0]);
            }
            this.aCommentNew.erase(this.aCommentNew[0]);
        }
        this.setCountNewComment(this.countNewComment-1);
    },

    scrollToComment: function(idComment)
    {
        this.docScroller.setOptions({
            duration:500,
            offset: {
                'x': 0,
                'y': 0
            }
        });
        var cmt=$('comment_content_id_'+idComment);
        var deltaY=cmt.getDimensions().height/2-window.getSize().y/2;
        if (deltaY>0)
        {
            deltaY=0;
        }
        this.docScroller.start(0,cmt.getPosition().y+deltaY);
        if (this.iCommentIdLastView)
        {
            $('comment_content_id_'+this.iCommentIdLastView).removeClass('view');
        }
        $('comment_content_id_'+idComment).addClass('view');
        this.iCommentIdLastView=idComment;
    },

    addComment: function(formObj,targetId,targetType)
    {
        var self=this;
        var ajaxParams = {};

        formObj=$(formObj);

        /* 
         * Встроенный в JsHttpRequest обработки форм дает сбой в IE11, 
         * поэтому выбиваем все данные из формы и передаем их в JsHttpRequest
         */
        if (formObj.tagName == 'FORM')
            ajaxParams = this.toJSON(formObj);
        else
            ajaxParams['params'] = formObj;

        ajaxParams['security_ls_key'] = LIVESTREET_SECURITY_KEY;

        JsHttpRequest.query(
            'POST '+self.typeComment[targetType].url_add,
            ajaxParams,
            function(result)
            {
                if (!result)
                {
                    self.enableFormComment();
                    msgErrorBox.alert('Error','Please try again later');
                    return;
                }

                if (result.bStateError)
                {
                    self.enableFormComment();
                    msgErrorBox.alert(result.sMsgTitle,result.sMsg);
                }
                else
                {
                    self.responseNewComment(targetId,targetType,$('update-comments'),result.sCommentId,true);
                }
            },
            true
        );

        $('form_comment_text').addClass('loader');
        $('form_comment_text').setProperty('readonly',true);
    },

    enableFormComment: function()
    {
        $('form_comment_text').removeClass('loader');
        $('form_comment_text').setProperty('readonly',false);
    },

    addCommentScroll: function(commentId)
    {
        this.aCommentNew.extend([commentId]);
        this.setCountNewComment(this.countNewComment+1);
    },

    toggleComment: function(obj,commentId)
    {
        var divContent=$('comment_content_id_'+commentId);
        if (!divContent)
        {
            return false;
        }

        JsHttpRequest.query(
            'POST '+DIR_WEB_ROOT+'/include/ajax/commentToggle.php',
            { idComment: commentId, security_ls_key: LIVESTREET_SECURITY_KEY },
            function(result)
            {
                if (!result)
                {
                    msgErrorBox.alert('Error','Please try again later');
                }

                if (result.bStateError)
                {
                    msgErrorBox.alert(result.sMsgTitle,result.sMsg);
                }
                else
                {
                    msgNoticeBox.alert(result.sMsgTitle,result.sMsg);
                    divContent.removeClass('old').removeClass('self').removeClass('new').removeClass('del');
                    obj.removeClass('delete').removeClass('repair');

                    if (result.bState)
                    {
                        divContent.addClass('del');
                        obj.addClass('repair');
                    }
                    else
                    {
                        obj.addClass('delete');
                    }
                    obj.set('text',result.sTextToggle);
                }
            },
            true
        );
    },

    approveComment: function(obj,commentId)
    {
        var divContent=$('comment_content_id_'+commentId);
        if (!divContent)
        {
            return false;
        }

        JsHttpRequest.query(
            'POST '+DIR_WEB_ROOT+'/include/ajax/commentApprove.php',
            { idComment: commentId, security_ls_key: LIVESTREET_SECURITY_KEY },
            function(result)
            {
                if (!result)
                {
                    msgErrorBox.alert('Error','Please try again later');
                }

                if (result.bStateError)
                {
                    msgErrorBox.alert(result.sMsgTitle,result.sMsg);
                }
                else
                {
                    msgNoticeBox.alert(result.sMsgTitle,result.sMsg);
                    obj.hide();
                    divContent.removeClass('pending');
                }
            },
            true
        );
    },

    toggleCommentForm: function(idComment,idPerson)
    {

        if (!$('reply_'+this.iCurrentShowFormComment) || !$('reply_'+idComment))
        {
            return;
        }

        /*  Если мы добавляем комментарий, то используем форму по умолчанию, чтобы вставить результат картинки */
        sToLoadOverride = null;

        var divCurrentForm=$('reply_'+this.iCurrentShowFormComment);
        var divNextForm=$('reply_'+idComment);

        /* Add moderator answer support */
        $('form_moderator_id').setProperty('value',idPerson);

        if (idPerson > 0)
        {
            divNextForm.setStyle('border-left','2px solid #e00500');
            divNextForm.setStyle('margin-left','55px');
            divNextForm.setStyle('margin-right','28px');
            divNextForm.setStyle('padding-left','5px');
        }
        else
        {
            divNextForm.setStyle('border-left','0px solid #FFFFFF');
            divNextForm.setStyle('margin-left','55px');
            divNextForm.setStyle('margin-right','28px');
            divNextForm.setStyle('padding-left','5px');
        }


        var slideCurrentForm = new Fx.Slide(divCurrentForm,{resetHeight : true});
        var slideNextForm = new Fx.Slide(divNextForm,{resetHeight : true});

        $('comment_preview_'+this.iCurrentShowFormComment).set('html','').setStyle('display','none');
        if (this.iCurrentShowFormComment==idComment)
        {
            slideCurrentForm.toggle();
            slideCurrentForm.addEvent('complete', function()
            {
                $('form_comment_text').focus();
            });
            return;
        }

        slideCurrentForm.slideOut();
        divNextForm.set('html',divCurrentForm.get('html'));
        divCurrentForm.set('html','');
        divNextForm.setStyle('display','block');
        slideNextForm.hide();

        slideNextForm.slideIn();

        $('form_comment_text').setProperty('value','');
        $('form_comment_reply').setProperty('value',idComment);
        this.iCurrentShowFormComment=idComment;
        slideNextForm.addEvent('complete', function()
        {
            $('form_comment_text').focus();
        });
    },

    hideCommentForm: function(idComment)
    {
        if ($('reply_'+idComment))
        {
            this.enableFormComment();
            $('comment_preview_'+this.iCurrentShowFormComment).set('html','').setStyle('display','none');
            var slideForm = new Fx.Slide('reply_'+idComment);
            slideForm.hide();
        }
    },

    preview: function()
    {
        ajaxTextPreview('form_comment_text',false,'comment_preview_'+this.iCurrentShowFormComment);
    },

    goToParentComment: function(obj)
    {
        var idCmt = obj.href.substr(obj.href.indexOf('#')+8);
        var objCmtParent=$('comment_id_'+idCmt);
        var objCmt=obj.getParent('div.comment');
        objCmtParent.getElement('.goto-comment-child').removeClass('hidden');
        objCmtParent.getElement('.goto-comment-child a').href = '#comment' + objCmt.id.substr(11);
        this.docScroller.setOptions({
            offset: {'y': 0}
        });
        this.docScroller.toElement(objCmtParent);
        return false;
    },

    goToChildComment: function(obj)
    {
        var idCmt = obj.href.substr(obj.href.indexOf('#')+8);
        var objCmtChild=$('comment_id_'+idCmt);
        var objCmt=obj.getParent('div.comment');
        objCmt.getElement('.goto-comment-child').addClass('hidden');
        this.docScroller.setOptions({
            offset: {'y': 0}
        });
        this.docScroller.toElement(objCmtChild);
        return false;
    }
});


var lsCmtTree;

window.addEvent('domready', function()
{
    lsCmtTree = new lsCmtTreeClass({
        img: {
            path: DIR_STATIC_SKIN+'/images/icons/'
        },
        classes: {
            openImg: 'fopen',
            closeImg: 'folding'
        }
    });
        
    if ($('comments'))
    {
        var lastCommentId = $('comments').getProperty('data-max-comment-id');        
        if (lastCommentId)
        {
            lsCmtTree.setIdCommentLast(lastCommentId);
        }
    }    
});

window.addEvent('keyup', function(e)
{
    if(e.control && e.key == 'enter')
    {
        $('form_comment').getElement('input[name=submit_comment]').click();
        return false;
    }
});
;
var lsSelectVendorClass = new Class({

    Implements: Options,

    options: {
        outputFunction: null,
        autocomplete: {},
        autoadjust: [],
        outputId: null,
        buttonId: null
    },

    modelsJson : {},
    currentProducer: '',
    objQuickSearch : null,

    /* 
     * По умолчаю содержимое заменяется
     * но с нажатым ctrl может просто добавляться
     */
    updateOutput: false,

    initialize: function(options)
    {
        var self = this;
        this.setOptions(options);

        /*
         * Заполняем данными формы aProducerJson - это внешний массив
         * со списком доступных производителей
         */
        aProducerJson.forEach(function (item, index)
        {
            var sLetter = self.getFirstLetter(item);
            var letterSelector = 'brand_letter_' + sLetter;

            if( $(letterSelector) )
            {
                if( !$(item) )
                {
                    self.loadBrand(item, letterSelector);
                }
            }
            else
            {
                self.addLetter(item, letterSelector, index);
                self.loadBrand(item, letterSelector);
            }
        });

        $('js-add-brand').addEvent('click',function(e)
        {
            e.preventDefault();
            self.addBrand(self);
        });

        $('js-add-model').addEvent('click',function(e)
        {
            e.preventDefault();
            self.addModel(self);
        });

        var producerSlider = new Fx.Slide('js-add-brand-form', { duration: 2}).hide();
        $('js-add-brand-button').addEvent('click', function ()
        {
            producerSlider.toggle();
        });

        var modelSlider = new Fx.Slide('js-add-model-form', { duration: 2}).hide();
        $('js-add-model-button').addEvent('click', function ()
        {
            modelSlider.toggle();
        });

        $('js-back-to-brand-button').addEvent('click', function ()
        {
            $('select-model-wrap').addClass('hidden');
            $('select-list-wrap-vendor').removeClass('hidden');
        });

        $(this.options.buttonId).addEvent('click', function(event)
        {
            $('select-list-wrap-vendor').removeClass('hidden');
            self.updateOutput = event.alt || event.meta;
            return false;
        });

        $('select-list-wrap-vendor-close').addEvent('click', function()
        {
            $('select-list-wrap-vendor').addClass('hidden');
            return false;
        });

        $$('.letter-selector').addEvent('click', function()
        {
            $$('.letter-selector').removeClass('active');
            $(this).addClass('active');
            return false;
        });

        $('select-model-wrap-close').addEvent('click', function ()
        {
            $('select-model-wrap').addClass('hidden');
            return false;
        });

        /*
         * Изменения размера при вводе, проходимся по всем полям и добавляем событие
         */
        self.options.autoadjust.forEach(function(item)
        {
            $(item).addEvent('change',function()
            {
                self.inputSizeAdjust();
            });

            $(item).addEvent('keyup',function()
            {
                self.inputSizeAdjust();
            });
        });

        this.inputSizeAdjust();

        /*
         * Автокомплитеры
         */
        this.initAutocomplete();
    },

    /**
     * Инициализация автокомлитеров
     */
    initAutocomplete: function()
    {
        var self = this;

        /* 
         * Расширяем функционал Autocompleter вводя новый режим
         * дополнение идет не данным, которые запрашиваются с сервера
         * а по локальному массиву
         */
        Autocompleter.LocalArray = new Class({

            Extends: Autocompleter,

            options: {
                dataArray: []
            },

            query: function()
            {
                var result = this.options.dataArray.filter(this.compareFunction, this.queryValue.toLowerCase() ).slice(0,40);
                this.update(result);
            },

            compareFunction: function(element)
            {
                return element.toLowerCase().indexOf(this) >= 0 ;
            }

        });

        /*
         * Расширяем функционал Autocompleter вводя новый режим
         * запрашиваем данные с сервера в особом формате
         */
        Autocompleter.CustomJSON = new Class({

            Extends: Autocompleter.Request,

            initialize: function(el, url, options)
            {
                this.parent(el, options);
                this.request = new Request.JSON($merge({
                    'url': url,
                    'link': 'cancel'
                }, this.options.ajaxOptions)).addEvent('onComplete', this.queryResponse.bind(this));
            },

            /**
             * Вызывается при обработке ответа
             * @param response
             */
            queryResponse: function(response)
            {
                this.parent();
                this.update(response.items);
            },

            /**
             * Вызывается при обработке ответа, далее вызывает injectChoice для каждого элемента
             * @param tokens
             */
            update: function(tokens)
            {
                this.choices.empty();
                this.cached = tokens;

                var type = tokens && $type(tokens);
                if (!type || (type == 'array' && !tokens.length) || (type == 'hash' && !tokens.getLength()))
                {
                    (this.options.emptyChoices || this.hideChoices).call(this);
                }
                else
                {
                    if (this.options.maxChoices < tokens.length && !this.options.overflow)
                        tokens.length = this.options.maxChoices;

                    tokens.each(this.injectChoice, this);
                    this.showChoices();
                }
            },

            /**
             * Обработка добавления отдельного элемента списка
             */
            injectChoice: function(token)
            {
                var choice = new Element('li', {'html': this.markQueryValue(token.text)});

                /* У каждого элемента может быть два поля 
                 * text - то, что отображается в подсказке
                 * output - то, что подставится в поисковое поле 
                 * 
                 * если output отсутствует, то подставляем текст (проверка в фунции setSelection)
                 */
                choice.inputValue = token.text;
                choice.outputValue = ('output' in token) ?  token.output : '';

                /*
                 * Также может быть несколько дополнительных полей
                 */
                choice.modelValue = ('model' in token) ?  token.model : '';
                choice.brandValue = ('brand' in token) ?  token.brand : '';
                choice.descriptionValue = ('description' in token) ?  token.description : '';

                this.addChoiceEvents(choice).inject(this.choices);
            },

            /**
             * Вызывается при выборе одного из элементов (UP & DOWN)
             * @param finish - если это финальный выбор (нажали Enter)
             */
            setSelection: function(finish)
            {
                var input = this.selected.inputValue, value = input;

                var start = this.queryValue.length, end = input.length;
                if (input.substr(0, start).toLowerCase() != this.queryValue.toLowerCase()) start = 0;

                if (this.options.multiple)
                {
                    /* Происходт опереление в каком месте мы вписывали наш текст */
                    var split = this.options.separatorSplit;
                    value = this.element.value;
                    start += this.queryIndex;
                    end += this.queryIndex;
                    var old = value.substr(this.queryIndex).split(split, 1)[0];

                    /* Объединение строго текста и нашего нового текста 
                     * у нас есть нескольк вариантов
                     * 
                     * 1) Если указан раздельный маппинг - то раскидываем значение
                     * 2) Если есть значение outputValue у элемента, то вставляем его
                     */
                    if (finish && this.options.separateOutput)
                    {
                        /* Модель */
                        if (this.options.separateModel)
                        {
                            if (this.options.separateModel == 'self')
                            {
                                value = value.substr(0, this.queryIndex) + this.selected.modelValue + value.substr(this.queryIndex + old.length);
                            }
                            else
                            {
                                this.updateExternalElement(this.options.separateModel,this.selected.modelValue);
                            }
                        }

                        /* Производитель */
                        if (this.options.separateBrand)
                        {
                            if (this.options.separateBrand == 'self')
                            {
                                value = value.substr(0, this.queryIndex) + this.selected.brandValue + value.substr(this.queryIndex + old.length);
                            }
                            else
                            {
                                this.updateExternalElement(this.options.separateBrand,this.selected.brandValue);
                            }
                        }

                        /* Описание */
                        if (this.options.separateDescription)
                        {
                            if (this.options.separateDescription == 'self')
                            {
                                value = value.substr(0, this.queryIndex) + this.selected.descriptionValue + value.substr(this.queryIndex + old.length);
                            }
                            else
                            {
                                this.updateExternalElement(this.options.separateDescription,this.selected.descriptionValue);
                            }
                        }
                    }
                    else
                    {
                        var selectedValue;

                        if (finish)
                        {
                            /* Делаем подмену только если это финальный выбор */ 
                            selectedValue= this.selected.outputValue ? this.selected.outputValue : input;
                        }
                        else
                        {
                            selectedValue = input;
                        }

                        value = value.substr(0, this.queryIndex) + selectedValue + value.substr(this.queryIndex + old.length);
                    }

                    if (finish)
                    {
                        var tokens = value.split(this.options.separatorSplit).filter(function(entry)
                        {
                            return this.test(entry);
                        }, /[^\s,]+/);
                        if (!this.options.allowDupes) tokens = [].combine(tokens);
                        var sep = this.options.separator;
                        value = tokens.join(sep) + sep;
                        end = value.length;
                    }
                }

                this.observer.setValue(value);
                this.opted = value;

                if (finish || this.selectMode == 'pick') start = end;

                this.element.selectRange(start, end);
                this.fireEvent('onSelection', [this.element, this.selected, value, input]);
            },

            /**
             * когда нужно обновить содержимое внешнего элемента
             */            
            updateExternalElement: function(id,value)
            {
                var el = $(id);

                if (!el)
                    return false;

                var output = el.get('value');

                if (output)
                    output += ',';

                if (value.indexOf(',') != -1)
                {
                    output = output + "'" + value + "'";
                }
                else
                {
                    output = output + value;
                }

                el.set('value', output);
                return true;
            }

        });

        /*
         * Автокомплитер для описания (группы) модели
         */
        new Autocompleter.Request.JSON(
            $('js-new-model-autocomplete'),
            aRouter.catalog + '/search/description/autocomplete',
            {
                'indicatorClass': 'autocompleter-loading',
                'minLength': 1,
                'selectMode': false,
                'postData': { security_ls_key: LIVESTREET_SECURITY_KEY },
                'multiple': false
            }
        );

        /*
         * Автокомплитер для названия производителя
         */
        new Autocompleter.LocalArray(
            $('js-new-brand-autocomplete'),
            {
                'indicatorClass': 'autocompleter-loading',
                'minLength': 2,
                'selectMode': false,
                'dataArray' : aProducerJson,
                'multiple': false
            }
        );

        /*
          * Быстрый поиск по имени производителя (строка вверху) 
          */
        $('js-quick-search-autocomplete').addEvent('keypress',function(e)
        {
            if (e.key == 'enter' && !self.objQuickSearch.visible)
            {
                if (aProducerJson.indexOf(this.value) > -1)
                {
                    /* Ugly hack to work around ClickProducer function */
                    self.producerClick(new Element('a', { id: this.value }) );
                }

                return false;
            }

            return true;
        });

        this.objQuickSearch = new Autocompleter.LocalArray(
            $('js-quick-search-autocomplete'),
            {
                'indicatorClass': 'autocompleter-loading',
                'minLength': 2,
                'selectMode': false,
                'dataArray' : aProducerJson,
                'multiple': false
            }
        );

        /*
         * Автокомплитер, если мы вводим название тега ручками
         */
        var defaultOptions = {
            'indicatorClass': 'autocompleter-loading', // class added to the input during request
            'minLength': 2, // We need at least 2 character
            'selectMode': 'pick', // Instant completion
            'multiple': true, // Tag support, by default comma separated
            'filterSubset': true,
            'onSelection': function()
            {
                self.inputSizeAdjust();
            }
        };

        for (item in this.options.autocomplete)
        {
            if (!this.options.autocomplete.hasOwnProperty(item))
                continue;

            var autocompleteField = $(item);
            var autocompleteUrl = this.options.autocomplete[item]['url'];
            var autocompleteOptions = this.options.autocomplete[item]['options'];

            /* Объединяем настройки по умолчанию с переданными настройками */
            for (key in defaultOptions)
            {
                if (!(key in autocompleteOptions))
                {
                    autocompleteOptions[key] = defaultOptions[key];
                }
            }

            new Autocompleter.CustomJSON(autocompleteField, autocompleteUrl, autocompleteOptions);
        }
    },

    /**
     * Изменение высоты элемента для ввода тегов в зависимости от количества тегов
     */
    inputSizeAdjust: function()
    {
        this.options.autoadjust.forEach(function(item)
        {
            var input = $(item);

            input.style.height = "1px";
            input.style.height = (5+input.scrollHeight)+"px";
        });
    },

    /**
     * Можем выводить результат в произвольном формате
     */
    setOutputFunction: function(outputFunction)
    {
        this.options.outputFunction = outputFunction;
    },

    /**
     * Обработка события когда пользователь
     * хочет добавить нового производителя
     */
    addBrand: function(self)
    {
        var form = $('js-add-brand-form');
        var value = form.getElement('input').getProperty('value').trim();

        if (value == '')
        {
            alert('Введите название производителя');
        }
        else
        {
            var params = { 'producer_name': value, 'security_ls_key': LIVESTREET_SECURITY_KEY };
            JsHttpRequest.query(
                'POST '+ aRouter.catalog + '/admin/producer/ajaxadd',
                params,
                function(result)
                {
                    if (!result)
                    {
                        msgErrorBox.alert('Error','Please try again later');
                        return;
                    }

                    if (result.bStateError)
                    {
                        msgErrorBox.alert(result.sMsgTitle,result.sMsg);
                    }
                    else
                    {
                        var liElem = new Element('li');
                        var aElem = new Element('a', { 'class': 'store-name-selector', 'href' : '#', text : value, id: value});

                        aElem.addEvent('click', function()
                        {
                            return self.producerClick(this);
                        });

                        aElem.inject(liElem);
                        liElem.inject($('brand-last-added'));

                        form.getElement('input').set('value', '');
                    }
                },
                true
            );
        }
    },

    /**
     * Добавление нового названия товара
     */
    addModel: function(self)
    {
        var form = $('js-add-model-form');
        var modelName = form.getElement('input.js-new-model-name').get('value').trim();
        var modelGroup = form.getElement('input.js-new-model-group').get('value').trim();

        if( modelName == '' || modelGroup=='' )
        {
            alert('Заполните все поля');
        }
        else
        {
            var params = { 'model_name': modelName, 'model_description_short': modelGroup, 'producer':self.currentProducer, 'security_ls_key': LIVESTREET_SECURITY_KEY };
            JsHttpRequest.query(
                'POST '+ aRouter.catalog + '/admin/model/ajaxadd',
                params,
                function(result)
                {
                    if (!result)
                    {
                        msgErrorBox.alert('Error','Please try again later');
                        return;
                    }

                    if (result.bStateError)
                    {
                        msgErrorBox.alert(result.sMsgTitle,result.sMsg);
                    }
                    else
                    {
                        self.modelsJson[self.currentProducer][self.modelsJson[self.currentProducer].length] = {"model":modelName, "tag":modelGroup};

                        var liElem = new Element('li');
                        var aElem = new Element('a', {
                            'class': 'store-name-selector modelOne',
                            href : '#',
                            events: {
                                click: function()
                                {
                                    self.modelClick(modelName,modelGroup);
                                    return false;
                                }
                            },
                            text : modelName,
                            id: self.currentProducer,
                            title : modelGroup });

                        /* Ugly hack around bad clickProducer design */
                        self.producerClick(aElem);

                        aElem.inject(liElem);
                        liElem.inject($('model-last-added'));

                        form.getElements('input[type="text"]').set('value', '');
                    }
                },
                true);
        }
    },

    /**
     * Пользователь кликнул по названию производителя
     * @param element
     */
    producerClick: function(element)
    {
        var self = this;
        element = $(element);

        $$('.store-name-selector').getParent().removeClass('current');
        $('select-list-wrap-vendor').addClass('hidden');

        if ( element.getParent() )
        {
            element.getParent().addClass('current');
        }

        this.currentProducer = element.get('id');

        var modelList = [];

        if (!this.modelsJson.hasOwnProperty(this.currentProducer))
        {
            /* 
             * Если у нас во внутреннем кеше еще нет данных о моделях
             * этого производителя, то делаем ajax запрос 
             * и по завершении запроса снова вызываем эту функцию
             */
            var params = { 'producer': self.currentProducer, 'security_ls_key': LIVESTREET_SECURITY_KEY };

            JsHttpRequest.query(
                'POST '+ aRouter.catalog + '/admin/model/ajaxget',
                params,
                function(result)
                {
                    if (!result)
                    {
                        msgErrorBox.alert('Error','Please try again later');
                        return;
                    }

                    if (result.bStateError)
                    {
                        msgErrorBox.alert(result.sMsgTitle,result.sMsg);
                    }
                    else
                    {
                        self.modelsJson[self.currentProducer] = result.data;
                        return self.producerClick(element);
                    }
                },
                true);

            return false;
        }
        else
        {
            modelList = this.modelsJson[this.currentProducer];
        }

        /*
         * Теперь modelList содержита данные о моделях этого производителя
         * в формате
         * {
         *  'model'  - Имя модели
         *  'tag' - К какой группе модель относится (например часы)
         * }
         */
        this.loadModels(modelList);

        //Формируем пагинацию
        $$('#paginator li').dispose();
        var modelListArray =  $$('#model-list-content .model-list');
        if (modelListArray.length > 1)
        {
            this.brandFormPagination(modelListArray);
        }

        //Делаем активной первую страницу
        $$('#model-list-content .model-list')[0].addClass('active');

        $('select-model-wrap').removeClass('hidden');

        $('brand-in-title').set('html',this.currentProducer);

        return false;
    },

    /**
     * вызывается когда пользователь кликнул
     * по названию модели
     */
    modelClick: function(modelName, modelGroup)
    {
        $('select-model-wrap').addClass('hidden');

        switch (this.options.outputFunction)
        {
            case 'separateOutput':
                this.separateOutputFunction(this.options.outputId,this.updateOutput,this.currentProducer,modelName,modelGroup);
                break;

            default:
                this.defaultOutputFunction(this.options.outputId,this.updateOutput,this.currentProducer,modelName,modelGroup);
        }

        return false;
    },

    defaultOutputFunction: function(outputId,updateOutput,producer,modelName, modelGroup)
    {
        var output = '';

        if (updateOutput)
        {
            output = $(outputId).get('value') +',';
        }

        output = output + producer + "," + producer + ' ' + modelName + ",";

        /* If we faced with comma then wrap it */
        if (modelGroup.indexOf(',') != -1)
            output = output + "'" + modelGroup + "'";
        else
            output = output + modelGroup;

        $(outputId).set('value', output);
    },

    /**
     * Выводит данные в три различные поля
     * @param outputId (три поля в порядке "модель", "бренд", "Категория")
     * @param updateOutput
     * @param producer
     * @param modelName
     * @param modelGroup
     */
    separateOutputFunction: function(outputId,updateOutput,producer,modelName,modelGroup)
    {
        var data = [producer + ' ' + modelName,producer,modelGroup];

        for (var i=0; i < data.length; i++)
        {
            var output = $(outputId[i]).get('value');

            if (output)
                output += ',';

            if (data[i].indexOf(',') != -1)
            {
                output = output + "'" + data[i] + "'";
            }
            else
            {
                output = output + data[i];
            }

            $(outputId[i]).set('value', output);
        }
    },

    loadBrand: function (brand, letterSelector)
    {
        var self = this;
        var liElem = new Element('li');
        var aElem = new Element('a', {
            'class' : 'store-name-selector',
            href : '#',
            text : brand ,
            id : brand});

        aElem.addEvent('click', function()
        {
            return self.producerClick(this);
        });

        aElem.inject(liElem);
        liElem.inject($(letterSelector).getNext());
    },

    /**
     * Первая буква производителя, в зависимости от нее
     * распределяем производителей по разным вкладкам
     *
     * @param brandName
     * @returns {string}
     */
    getFirstLetter: function(brandName)
    {
        var sLetter = brandName.charAt(0);
        sLetter = sLetter.toUpperCase();

        /**
         * Если это не английская буква от отправляем их о общую группу
         */
        if (!/^[A-Z]+$/.test(sLetter))
        {
            sLetter = 'А-Я';
        }

        return sLetter;
    },

    addLetter: function (jsonItem, letterSelector, count)
    {
        var liElem;

        var sLetter = this.getFirstLetter(jsonItem);
        var sLetterWidthClass = 'letter-width-' + sLetter.length;

        if( count == 0 )
        {
            liElem = new Element('li', { 'class' : 'letter-selector active ' + sLetterWidthClass });
        }
        else
        {
            liElem = new Element('li', { 'class' : 'letter-selector ' + sLetterWidthClass});
        }

        var divTitleElem = new Element('div', { 'class' : 'title', 'id' : letterSelector, text : sLetter });
        divTitleElem.inject(liElem);

        var ulElem = new Element('ul', { 'class' : 'tab-content scrolled' });
        ulElem.inject(liElem);
        liElem.inject($('js-brand-load-area'));
    },

    /**
     * Формирует страницу на которой перечислены модели и категории
     * конктретного производилея
     * 
     * @param modelList
     */
    loadModels: function (modelList)
    {
        var self = this;

        /* 
         * Сколько элементов выводить на 
         * каждой странице
         */    
        var maxElemPerPage = 20;
        var curElemPerPage = 0;

        /* Удаляем все старые данные */
        $$('#model-list-content .pager-wrap ul').dispose();

        /* Куда будет вставляться код для новой страницы */
        var newPageDest = $$('#model-list-content .pager-wrap')[0];

        /* 
         * Если у производителя много товаров, то нужна пагинация
         * функция добавления новой страницы
         */
        var addNewPage = function (dest)
        {
            var ulElem = new Element('ul', { 'class' : 'model-list' } );
            ulElem.inject( $(dest) );
        };

        /*
         * Вставляем модель на страницу 
         */
        var addNewModel = function (model, dest)
        {
            var modelA = new Element('a', {
                'class' : 'store-name-selector modelOne',
                href : '#',
                events: {
                    click: function()
                    {
                        self.modelClick(model.model,model.tag);
                        return false;
                    }
                },
                text: model.model}
            );

            var modelLi = new Element('li');

            modelA.inject(modelLi);
            modelLi.inject(dest);
        };

        /*
         * Товары объединяются в группы
         * например Часы, Ручки и т.д
         */
        var addNewGroup = function (groupName, dest)
        {
            var spanElem = new Element('span', { 'class' : 'brand_item_descr', text : groupName } );
            var liElem = new Element('li', { 'class' : 'tag' } );
            spanElem.inject(liElem);
            liElem.inject(dest);
        };

        /*
         * Добавляем модели в группу
         */
        var addModelsInGroup = function (modelList,groupName)
        {
            /*
             * Нам нужны только модели, которые есть в указанной группе
             */
            var models = modelList.filter(function (model)
            {
                return model.tag == groupName;
            });

            models.forEach(function (model)
            {
                if ( curElemPerPage >= maxElemPerPage )
                {
                    addNewPage(newPageDest);
                    addNewModel(model, $$('.model-list').getLast());
                    curElemPerPage = 0;
                }
                else
                {
                    addNewModel(model, $$('.model-list').getLast());
                    curElemPerPage++;
                }
            });
        };

        /*
         * Начинаем заполнять даннымм
         */
        var groupList = [];

        /*
         * собираем список уникальных групп
         * Добавляем сначала групп, а потом 
         * все модели из этой группы
         */
        modelList.forEach(function (model)
        {
            groupList.include(model.tag);
        });

        addNewPage(newPageDest);

        groupList.forEach(function (groupName)
        {
            if( curElemPerPage >= maxElemPerPage )
            {
                addNewPage(newPageDest);
                addNewGroup(groupName, $$('.model-list').getLast());
                curElemPerPage = 0;
            }
            else
            {
                addNewGroup(groupName, $$('.model-list').getLast());
                curElemPerPage++;
            }

            addModelsInGroup(modelList, groupName);
        });
    },


    brandFormPagination: function(modelListArray)
    {
        $$('#paginator li').dispose();

        var prevA = new Element('a', { 'href':'#', 'onclick':'return false;', 'id':'prev', 'class':'a-link', text: '←'} );
        var prevLi = new Element('li', { 'class':'last' } );
        prevA.inject(prevLi);
        prevLi.inject($('paginator'));

        var firstPageA = new Element('a', { 'href':'#', 'onclick':'return false;', 'class':"a-link a-number-link", text:'1', 'target':'page_1' } );
        var firstPage = new Element('li', { 'class' : 'active'} );
        firstPageA.inject(firstPage);
        Array.each(modelListArray, function (item, count)
        {
            item.setAttribute('id', 'page_' + (count+1) );
            if(count == 0)
            {
                firstPage.inject($('paginator'));
            }
            else
            {
                var currentA = new Element('a', { 'href':'#', 'onclick':'return false;', 'class':"a-link a-number-link", 'target':'page_'+(count+1), text:count+1 } );
                var currentLi = new Element('li');
                currentA.inject(currentLi);
                currentLi.inject($('paginator'));
            }
        });

        var nextA = new Element('a', { 'href':'#', 'onclick':'return false;', 'id':'next', 'class':'a-link', text: '→'} );
        var nextLi = new Element('li', { 'class':'last' } );
        nextA.inject(nextLi);
        nextLi.inject($('paginator'));

        $$('#paginator a.a-number-link').addEvent('click', function ()
        {
            $$('#paginator li').removeClass('active');
            this.closest('li').addClass('active');

            var target = this.getAttribute('target');
            $$('.model-list').removeClass('active');
            $(target).addClass('active');
        });

        var setPrevNext = function(prevOrNext)
        {
            var activePageBtn = $$('#paginator li.active')[0];
            var nextSiblingLi;

            if( prevOrNext == 'next' )
            {
                nextSiblingLi = activePageBtn.getNext();
            }
            else
            {
                nextSiblingLi = activePageBtn.getPrevious();
            }

            var nextSiblingA = nextSiblingLi.getElement('a');
            if( nextSiblingA.get('class') == 'a-link a-number-link' )
            {
                nextSiblingA.click();
            }
        };

        $$('#paginator a#next').addEvent('click', function ()
        {
            setPrevNext('next');
        });

        $$('#paginator a#prev').addEvent('click', function ()
        {
            setPrevNext('prev');
        });
    }
});
;
function ajaxPollVote(iPollId, bAbstain)
{
    if (!USER_CURRENT)
    {
        return showLoginForm();
    }

    var iAnswerId = [];

    if (!bAbstain)
    {
        iAnswerId = $$('input[name=poll_answer_'+iPollId+']:checked').map(function(e)
        {
            return e.value;
        });
    }

    JsHttpRequest.query(
        aRouter['poll']+'/vote',
        { idPoll: iPollId, idAnswer: iAnswerId, abstain:bAbstain, security_ls_key: LIVESTREET_SECURITY_KEY },
        function(aResult)
        {
            if (!aResult)
            {
                msgErrorBox.alert('Error','Please try again later');
            }

            if (aResult.bStateError)
            {
                msgErrorBox.alert(aResult.sMsgTitle,aResult.sMsg);
            }
            else
            {
                msgNoticeBox.alert(aResult.sMsgTitle,aResult.sMsg);

                if ($('js-poll-container-id-'+iPollId))
                {
                    $('js-poll-container-id-'+iPollId).set('html',aResult.sText);
                }
            }
        },
        true
    );
};
window.addEvent('domready', function()
{
    /* Тут хранятся все спойлеры, чтобы мы могли их развенуть одним кликом */
    var sliders = new Array();

    /*
     * Каждый спойлер состоит из двух частей
     * заголовка и тела спойлера, проходим всем
     * элементам и однозначно связываем заголовок
     * спойлера с его телом через ID
     */
    var spoilers = $$('div.spoiler div');
    var id = 0;

    spoilers.each(function(element)
    {
        if (element['className'] == 'spoiler-title')
        {
            id = Math.floor((Math.random() * 10000000) + 1);
            element.setProperty('id', 'st'+id); /* Spoiler Title */
            element.setProperty('title', 'Удерживайте клавишу Alt при клике, чтобы открыть все спойлеры.');
            element.set('html','<span>'+element.innerHTML+'</span>');
   }

        if (element['className'] == 'spoiler-body')
        {
            element.setProperty('id', 'sb'+id); /* Spoiler Body */
        }
    });

    /*
     * На все заголовки вещаем функцию обработки клика
     * а на основные блоки спойлера вешаем слайдер
     */
    var titles = $$('body div.spoiler-title');

    titles.each(function(element)
    {
        var id_ = element['id'];
        var id = id_.slice(2, 10);

        element.addEvent('click', function(event)
        {
            if (event.alt || event.meta) // Alt key is pressed
            {
                $$('.spoiler-body').show();
            }
            else
            {
                $('sb'+id).toggle();
            }
        });
    });
});

;
/* global lsCmtTreeClass */
lsCmtTreeClass.prototype.edit = {};

lsCmtTreeClass.prototype.startEdit = function(button, cmtId)
{
    if(this.edit.text)
    {
        this.cancelEdit();
    }

    this.edit.text = $(button).getParent('div.comment').getElement('div.text');

    this.edit.text_source = $('cmt_src_'+cmtId);

    this.edit.oldHtml = this.edit.text.get('html');
    this.edit.buttons = $(button).getParent('div').getElements('a.cmtedit-button');
    this.edit.buttons[0].hide();
    this.edit.buttons[1].show();
    this.edit.buttons[2].show();

    var area = $$('#cmtedit_form textarea')[0];
    var newHtml = $('cmtedit_form').get('html');

    this.edit.text.set('html',newHtml);
    this.edit.text.getElement('textarea').value = this.edit.text_source ? this.edit.text_source.value : this.edit.text.get('html');

    var newId = area.id + ((new Date()).getTime().toString().substring(10) * Math.round(Math.random()*1000));
    this.edit.text.getElement('textarea').id = newId;

    /* Устанавливаем куда будет вставлятся текст после загрузки картинки */
    sToLoadOverride = newId;
};

lsCmtTreeClass.prototype.endEdit = function(button, cmtId)
{
    var text = this.edit.text.getElement('textarea').value;
    var self = this;
    new Request.JSON({
        url: DIR_WEB_ROOT+'/ajax/comment/edit',
        noCache: true,
        data: {idComment:cmtId,comment_text:text,security_ls_key:LIVESTREET_SECURITY_KEY},
        onSuccess: function(result)
        {
            if(!result)
            {
                msgErrorBox.alert('Error','Please try again later');
                return self.cancelEdit();
            }
            else if(result && result.bState)
            {
                self.edit.text.set('html', result.newText);
                if(self.edit.text_source)
                {
                    self.edit.text_source.value = result.newTextSource;
                }
                if(result.editInfo)
                {
                    var edit_info = self.edit.text.getNext('div.text-more');
                    if(!edit_info)
                    {
                        edit_info = new Element('div');
                        edit_info.addClass('text-more');
                        edit_info.addClass('edit-info');
                        edit_info.inject(self.edit.text,'after');
                    }
                    edit_info.set('html',result.editInfo);
                }
                self.edit.buttons[0].show();
                self.edit.buttons[1].hide();
                self.edit.buttons[2].hide();
            }
            else if(result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
                return self.cancelEdit();
            }
        },
        onFailure: function()
        {
            msgErrorBox.alert('Error','Please try again later');
            return self.cancelEdit();
        }
    }).send();
};

lsCmtTreeClass.prototype.cancelEdit = function()
{
    if(this.edit.text && this.edit.buttons)
    {
        this.edit.text.set('html', this.edit.oldHtml);
        this.edit.buttons[0].show();
        this.edit.buttons[1].hide();
        this.edit.buttons[2].hide();
    }
};
;
/* exported OpenAddRecommendationForm */
function OpenAddRecommendationForm(iTopicId,sTopicName)
{
    if(iTopicId > 0)
    {
        $('recommend_for_topic_id').setProperty('value',iTopicId);
        $('recommend_for_topic_name').set('html',sTopicName);
        $('recommend_dst_topic_url').set('value','');
        $('recommendWindow').show();
    }

    return false;
}

/* exported AddRecommendation */
function AddRecommendation()
{
    JsHttpRequest.query(
        aRouter.recommend +'/add',
        {'recommend_topic_id': $('recommend_for_topic_id').getProperty('value'),
            'recommend_dst_topic_url': $('recommend_dst_topic_url').getProperty('value'),
            'security_ls_key': LIVESTREET_SECURITY_KEY},
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
                return;
            }

            if (!result.bStateError)
            {
                msgNoticeBox.alert('Сохранено','Ссылка успешно добавлена.');
                CloseRecommendForm('recommendWindow');
            }
            else
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }

        },
        true
    );
}

/* exported BlackListRecommendation */
function BlackListRecommendation(iRecommendLineNumber,iTopicId,$iDstTopicId)
{
    JsHttpRequest.query(
        aRouter.recommend + '/admin/blacklist/add',
        {
            'topic_id': iTopicId,
            'recommend_dst_topic_id': $iDstTopicId,
            'security_ls_key': LIVESTREET_SECURITY_KEY
        },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
                return;
            }

            if (!result.bStateError)
            {
                msgNoticeBox.alert("Внимание", "Рекомендация занесена в черный список");
                $('recommend_link_id_' + iRecommendLineNumber).hide();
            }
            else
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }

        },
        true
    );
}

/* exported CloseRecommendForm */
function CloseRecommendForm(sFormId)
{
    $(sFormId).hide();
}

/* exported LoadMoreRecommendation */
function LoadMoreRecommendation(iTopicId)
{
    if ($('loadMoreMain').getElementsByClassName('str-wrapper')[0])
    {
        $('loadMoreMain').slide('toggle');
    }
    else
    {
        var strWrap = new Element('div', { 'class':'str-wrapper'});
        strWrap.inject($('loadMoreMain'));
        loadRecommend(strWrap, iTopicId);
    }

    return false;

}

/* exported loadRecommend */
function loadRecommend(parentElem, iTopicId)
{
    var addString = function (jsonItem, addDest, bAllowEdit)
    {
        var string = new Element('div', { 'class' : 'string'});
        string.set('html',
            "<table ><tr><td class='rate'><span>"
                + (jsonItem.rating==0?'':'+') + jsonItem.rating+"</span></td><td class='inner'>"
                + "<div class='title'><a href='"+jsonItem.url+"' target='_blank'>"
                + jsonItem.title + "</a></div>"
                + "<div class='indicators'>"
                + "<span class='view-count'>"+jsonItem.viewCount+"</span>"
                + "<span class='comment-count'>"+jsonItem.commentsCount+"</span>"
                + "</div></td></tr></table>"
                +  (bAllowEdit?"<span class='cross' onclick='addToBlackList("+jsonItem.topic_id+")'>x</span>":"")
        );
        string.inject(addDest);
    };

    JsHttpRequest.query(
        aRouter.recommend + '/get',
        {
            'topic_id': iTopicId,
            'security_ls_key': LIVESTREET_SECURITY_KEY
        },
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
            }

            if (!result.bStateError)
            {
                var Data = result.data;

                Data.forEach(function (item)
                {
                    addString(item, parentElem, result.bAllowEdit);
                });

                $('loadMoreMain').slide('toggle');

            }
            else
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }

        },
        true
    );

}

/* Fix css in some cases */
window.addEvent('domready', function ()
{
    if ($$('#similarOverviews .string .inner').length)
    {
        $$('#similarOverviews .string .inner')[0].set('style', 'border-top: 1px solid #ededed');
    }

    if ($$('#otherOverviews .string .inner').length)
    {
        $$('#otherOverviews .string .inner')[0].set('style', 'border-top: 1px solid #ededed');
    }

    /* Tab header selection */
    $$('.overview-wrap .tab-button').addEvent('click', function (e)
    {
        e.preventDefault();
        var tabSelector =  this.get('tab-target');
        $$('.overview-wrap .tab-button').removeClass('activeTab');
        this.addClass('activeTab');
        $$('.tab-item').removeClass('active');
        $(tabSelector).addClass('active');
    });

    if ($('loadMoreMain'))
    {
        $('loadMoreMain').set('slide', {duration: 200});
        $('loadMoreMain').slide('hide');
    }
});

;
/**
 * Основой класс который отвечает за отправку данных на сервер
 * и получение данных с сервера
 * 
 * @param textArea
 * @param userOptions
 * @returns
 */
function textHandlerClass (textArea, userOptions)
{
    this.options = {
        topicId : 0,
        topicType: 'undefined',

        userId : 0,
        curUserId : 0,

        autoSpeller : true,
        autoSaver: false,

        /* Селекторы элементоы */
        textAreaSelector: textArea,
        startButtonSelector: '.speller-start-button',
        toggleButtonSelector: 'speller-toggle-button',
        resultAreaSelector: 'speller-result-area',
        tabEditor: 'el-tab-editor',
        tabSpeller: 'el-tab-speller',
        spellerBadge: 'speller-badge',

        /* Таймеры обновления */
        checkInitInterval: 2000, /* первое обновление идет через две секунды */
        recheckInterval: 60000, /* Дальше через 60 секунд */

        /* Адрес на стороне сервера */
        processUrl: aRouter.texthandler + '/process',
        reportUrl: aRouter.texthandler + '/reportWord',

        /* Список пришедших ошибок с сервера */
        detectedIssues: []

    };

    /* merge  userOptions and default options */   
    for (var key in userOptions)
        this.options[key] = userOptions[key];

    /* В некоторых ситуациях нам не нужно запускать автоматическую проверку */
    this.allowAutoRefresh = ( (this.options.topicId == 0) || (this.options.userId == this.options.curUserId));

    this.curState = 'PREINIT';

    this.timer = {
        id: null,
        execTime: 0
    };

    /* В настоящее время выполняется запрос */
    this.isRunning = false;

    /* У нас есть результат проверки */
    this.hasFirstRun = false;

    /* Чтобы не показывать постоянно, что есть ошибки, мы показываем эту ошибку (если есть)
     * исключительно до первого отрытия вкладки спеллера
     */
    this.showErrorCounter = true;

    /* чтобы не отправлять на обработку текст который мы уже проверяли */
    this.textLashHash = 0;

    /* меню открыто или закрыто */
    this.spellerMenuOpen = false;

    this.$startButton = null;
    this.$toggleButton = null;
    this.$textArea = null;
    this.$resultArea = null;
    this.$spellerMenu = null;
    this.$tabEditor = null;
    this.$tabSpeller = null;
    this.$spellerBadge = null;
}


textHandlerClass.prototype = {

    constructor: textHandlerClass,

    /** 
     * Инициализация
     */
    init: function()
    {
        var self = this;

        /* Определяем элементы управления
         * 
         * Кнопок startButton может быть несколько
         *
         */
        if (this.$startButton = $$(this.options.startButtonSelector))
            this.$startButton.addEvent('click',function()
            {
                self.startButtonClick(); return true;
            });

        if (this.$toggleButton = $(this.options.toggleButtonSelector))
            this.$toggleButton.addEvent('click',function()
            {
                self.toggleAutoCheck(); return true;
            });

        this.$textArea = $(this.options.textAreaSelector);
        this.$resultArea = $(this.options.resultAreaSelector);

        /* Инициализруем div в котором будут отображаться ошибки при клике */
        $('body').appendHTML('<div class="speller-issue-menu" id="speller-issue-menu"></div>');
        this.$spellerMenu = $('speller-issue-menu');
        document.addEvent('mousedown', function(e)
        {
            if( self.spellerMenuOpen && self.outsideClick(e, self.$spellerMenu)) self.spellerMenuClose();
        });

        /*
         * Работа с вкладками
         */    
        this.$tabEditor = $(this.options.tabEditor);
        this.$tabSpeller = $(this.options.tabSpeller);
        this.$spellerBadge = $(this.options.spellerBadge);

        this.$tabEditor.addEvent('click',function()
        {
            self.showTab('editor',{}); self.unfreezeSpeller(); return true;
        });
        this.$tabSpeller.addEvent('click',function()
        {
            self.showTab('speller',{}); self.freezeSpeller(); return true;
        });

        /* 
         * Запускаем таймер
         */    
        this.curState = 'READY';
        this.scheduleRun(this.options.checkInitInterval,{ ignoreFreeze: true});
    },

    /** ----------------------/ Работа с UI /---------------------
     * 
     * Вызывается при нажании на кнопку старта 
     */
    startButtonClick: function()
    {
        this.showTab('speller');
        this.scheduleRun(0,{ ignoreFreeze: true, ignoreChecks: true});
        return false;
    },

    /**
     * Переключение вкладок
     */
    showTab: function(tabName)
    {
        switch (tabName)
        {
            case 'speller':
                this.$tabEditor.removeClass('active');
                this.$tabSpeller.addClass('active');

                $$('.el-tab-editor').hide();
                $$('.el-tab-speller').show();

                this.showErrorCounter = false;
                this.$spellerBadge.hide();

                break;

            default:
                this.$tabSpeller.removeClass('active');
                this.$tabEditor.addClass('active');

                $$('.el-tab-speller').hide();
                $$('.el-tab-editor').show();
                break;
        }
    },

    /** 
     * При включении/отключении автопроверки
     * как только
     */
    toggleAutoCheck: function()
    {
        this.options.autoSpeller = !this.$toggleButton.checked;

        /* Если у нас нет результата и включили автопроверку, то выполняем ее немедленно */
        if (this.allowAutoRefresh && this.options.autoSpeller && !this.hasFirstRun)
        {
            this.scheduleRun(0,{ ignoreFreeze: true });
        }
        return false;
    },

    /** 
     * Замораживет автообновление, пока вкладка спеллера активна 
     */
    freezeSpeller: function()
    {
        this.curState = 'FREEZE';

        /* Если у нас нет результата и включили автопроверку, то выполняем ее немедленно */
        if (this.allowAutoRefresh && this.options.autoSpeller && !this.hasFirstRun)
        {
            this.scheduleRun(0,{ ignoreFreeze: true });
        }
    },

    /** 
     * восстанавливает автообновление, когда вкладка закрыта 
     */
    unfreezeSpeller: function()
    {
        this.curState = 'READY';
    },

    /** ----------------------/ Таймеры и работа с сетью /---------------------
     * 
     * Функция которая управляет запуском всех тестов
     * 
     * 
     * Функция или вызывет функцию проверки текста (которая потом установит таймер)
     * или сама установит таймер для следуюго вызыва самой себя
     */
    scheduleRun: function(interval,options)
    {
        var date = new Date();
        var now = date.getTime();

        clearTimeout(this.timer.id);

        /* требуется выполнение обработки */
        if (interval == 0)
        {
            this.processText(options);
        }
        else
        {
            /* Если требуется выполнить быстрее чем установленный таймер */
            if ( (this.timer.execTime == 0) || (now + interval < this.timer.execTime))
            {
                this.setTimer(interval,options);
            }
            else
            {
                this.setTimer(this.options.recheckInterval,options);
            }
        }
    },

    setTimer: function(interval,options)
    {
        var date = new Date();
        var now = date.getTime();
        var self = this;

        this.timer.execTime = now + interval;
        this.timer.id = setTimeout(function()
        {
            self.scheduleRun(0,options);
        }, interval);
    },

    /**
     * Функция которая посылает текст на обработку
     * в общем случае срабатывет раз в recheckInterval, 
     * так как нам нужно текст и проверять и сохранять
     * 
     * options.ignoreFreeze  - Запускать даже если открыта панель спеллера
     * options.ignoreChecks  - Обязательно проверить текст, несмотря ни на что
     */
    processText: function(options)
    {
        var self = this;

        /* Если в настоящее время идет обработка, то молча выходим */
        if (this.isRunning == true)
        {
            return;
        }

        this.isRunning = true;
        var ignoreFreeze = (('ignoreFreeze' in options) && (options.ignoreFreeze == true));
        var ignoreChecks = (('ignoreChecks' in options) && (options.ignoreChecks == true));

        if ( (this.curState == 'FREEZE') && (ignoreFreeze == false))
        {
            this.setTimer(this.options.recheckInterval,{});
            this.isRunning = false;
            return false;
        }

        var textHash = this.getHash();
        if ( (textHash == this.textLashHash) && (ignoreChecks == false))
        {
            this.setTimer(this.options.recheckInterval,{});
            this.isRunning = false;
            return false;
        }

        if ((this.allowAutoRefresh == false) && (ignoreChecks == false))
        {
            this.setTimer(this.options.recheckInterval,{});
            this.isRunning = false;
            return false;
        }

        /* 
         * Теперь мы можем отправить текст на сервер для проверки 
         * 
         * Отправляем в трех случаях
         * 1) У нас включен autoSpeller
         * 2) У нас включен autoSaver
         * 3) мы запросили ручную проверку (ignoreChecks == true)
         * 
         * Иначе просто устаналиваем проверку текста через this.options.recheckInterval мсек
         */
        if ( (ignoreChecks == true) || this.options.autoSpeller || this.options.autoSaver)
        {
            this.textLashHash = textHash;
            this.hasFirstRun = true;

            /* Показываем, что мы делаем запрос */
            this.$resultArea.removeClass('nodata').removeClass('noerror').addClass('loader').set('text','');

            JsHttpRequest.query(
                'POST '+this.options.processUrl,
                {
                    topicId : this.options.topicId,
                    topicType: this.options.topicType,

                    userId : this.options.userId,
                    curUserId : this.options.curUserId,

                    useSpeller : this.options.autoSpeller || (ignoreChecks == true),
                    useSaver: this.options.autoSaver,

                    security_ls_key: LIVESTREET_SECURITY_KEY,

                    text: this.$textArea.get('value')
                },
                function(result, errors)
                {
                    /* Вызываем наш callback, именно там будет вся логика */    
                    return self.processTextCallback(result, errors);
                },
                true
            );
            return false;
        }
        else
        {
            this.setTimer(this.options.recheckInterval,{});
            this.isRunning = false;
            return false;
        }
    },

    /**
     * Передача текст на сервер и обработка ответа
     * данная функция должны вызываться исключительно из функции processText
     */
    processTextCallback: function(result, errors)
    {
        this.$resultArea.removeClass('loader');
        this.$spellerBadge.hide();

        if (!result || result.bStateError)
        {
            this.$resultArea.addClass('nodata');
            this.setTimer(this.options.recheckInterval,{});
            this.isRunning = false;
            return;
        }

        /* Нет ошибок */
        if (result.matches.length == 0 )
        {
            this.$resultArea.addClass('noerror');
            this.setTimer(this.options.recheckInterval,{});
            this.isRunning = false;
            return;
        }

        /* Тут идет уже обработка данных с ошибками */
        this.parseResult(result.matches);
        this.renderIssues();

        this.setTimer(this.options.recheckInterval,{});
        this.isRunning = false;
    },


    /** ----------------------/ Обработка результатов /---------------------
     * 
     * Обрабатывает Json который пришел с сервера
     */
    parseResult: function(matches)
    {
        this.detectedIssues = [];

        var length = matches.length;
        var startText,issueText,endText;

        var text = this.$textArea.get('value');

        for (var key = 0; key < length; key++)
        {
            var match = matches[key];
            var issueData = {};

            issueData["description"] = this.wordWrap(match.message, 50, "<br/>");
            issueData["resolved"]    = false;
            issueData["ignored"]     = false;
            issueData["suggestions"] = match.replacements;
            issueData["offset"]      = parseInt(match.offset);
            issueData["errlength"]   = parseInt(match.length);
            issueData["categoryid"]  = match.rule.category.id;
            issueData["ruleid"]      = match.rule.id;
            issueData["subid"]       = match.rule.subId;
            issueData["issueType"]   = match.rule.issueType;

            /* Нам нужно из поля контекст нужно вытащить какое именно слово является ошибочным 
             * TODO: делать parseInt только один раз
             * 
             * startText - текст перед ошибкой
             * issueText - слово с ошибокой
             * endText - текст после ошибки
             */
            startText = match.context.text.substr(0,parseInt(match.context.offset));
            issueText = match.context.text.substr(parseInt(match.context.offset),parseInt(match.context.length));
            endText   = match.context.text.substr(parseInt(match.context.offset) + parseInt(match.context.length),match.context.text.length - parseInt(match.context.length) - parseInt(match.context.offset));

            /* 
             * Также, чтобы нам делать поиск и замену в тексте, нам нужно получить окружающий текст
             * берем 20 символов в каждую сторону
             * 
             * searchText - текст с ошибкой который мы будем использовать при замене
             */
            issueData["context"]     = {
                searchText: text.substr(Math.max(1,parseInt(match.offset)-20),40 + parseInt(match.length)),

                startText: startText,
                issueText: issueText,
                endText: endText
            };

            issueData["cssName"]     = "";


            if (match.rule.id.indexOf("SPELLER_RULE") >= 0 || match.rule.id.indexOf("MORFOLOGIK_RULE") == 0 || match.rule.id == "HUNSPELL_NO_SUGGEST_RULE" || match.rule.id == "HUNSPELL_RULE")
            {
                issueData["cssName"] = "hidden-spell-error";
            }
            else if (match.rule.issueType === 'style' || match.rule.issueType === 'locale-violation' || match.rule.issueType === 'register')
            {
                issueData["cssName"] = "hidden-suggestion";
            }
            else
            {
                issueData["cssName"] = "hidden-grammar-error";
            }

            this.detectedIssues.push(issueData);
        }
    },

    /**
     * Размещает текст ошибок
     */
    renderIssues: function()
    {
        var self = this;

        var html = "";
        var length = this.detectedIssues.length;

        var issueCount = 0;

        for (var key = 0; key < length; key++)
        {
            var issueData = this.detectedIssues[key];
            var issueContext = issueData.context;

            if (issueData.ignored == true)
                continue;

            issueCount++;

            html += '<div class="speller-issue" id="speller-issue-' + key + '">';
            html += this.toHtmlEntities(issueContext.startText);
            html += '<span data-category="' + issueData.categoryid + '" data-rule="' + issueData.ruleid + '" data-issue-id="' + key + '"class="' + ( issueData.resolved ? "" : issueData.cssName ) +'">';
            html += this.toHtmlEntities(issueContext.issueText) + '</span>' + this.toHtmlEntities(issueContext.endText);
            html += '</div>';
        }

        this.$resultArea.set('html',html);

        /* Обработчик клика по ошибке */
        $$('div.speller-issue span').addEvent('click',function()
        {
            return self.spellerMenuShow(this);
        });

        if (this.showErrorCounter == true)
        {
            this.$spellerBadge.set('html',issueCount);
            this.$spellerBadge.show('inline-block');
        }
    },

    /** ----------------------/ UI для работы с ошибками /---------------------
     * 
     * Показывает меню для заданной ошибки
     */    
    spellerMenuShow: function(el)
    {
        this.spellerMenuClose();

        var self = this;
        var issueId = $(el).get('data-issue-id');

        /* Ошибки с таким номером у нас нет */
        if (issueId > this.detectedIssues.length)
        {
            return;
        }

        var issueData = this.detectedIssues[issueId];
        if (issueData.resolved == true)
        {
            return;
        }

        var menuHtml = this.renderMenu(issueId,issueData);
        this.$spellerMenu.set('html',menuHtml);
        this.$spellerMenu.position({
            relativeTo: $(el),
            position: 'bottomLeft',
            offset: {
                x: 0,
                y: 0
            }
        });

        /* Обработчик */
        $$('div.speller-issue-menu .speller-issue-menu-item').addEvent('click',function()
        {
            self.spellerMenuItemClick(this); self.spellerMenuClose();
        });

        this.spellerMenuOpen = true;
        this.$spellerMenu.show();
    },

    /**
     * Закрывает меню
     */
    spellerMenuClose: function()
    {
        this.spellerMenuOpen = false;
        this.$spellerMenu.hide();
    },

    /**
     * Обработка клика по пункту в меню
     */
    spellerMenuItemClick: function(el)
    {
        var action =  $(el).get('data-action');
        var issueId = $(el).get('data-issue-id');
        var text, pos;

        /* Ошибки с таким номером у нас нет */
        if (issueId > this.detectedIssues.length)
        {
            return;
        }

        var issueData = this.detectedIssues[issueId];
        if (issueData.resolved == true)
        {
            return;
        }

        /* Выбираем что именно нужно сделать */
        switch (action)
        {
            case 'go':
                /* Перейти к ошибке в тексте */
                text = this.$textArea.get('value');
                pos = text.indexOf(issueData.context.searchText);

                if (pos == -1)
                {
                    msgErrorBox.alert('Ошибка','Строка с ошибкой в тексте не найдена. Попробуйте проверить текст повторно.');
                }
                else
                {
                    this.showTab('editor');
                    this.unfreezeSpeller();

                    this.$textArea.setCaretPosition(Math.max(0,pos-100));
                    this.$textArea.selectRange(pos,pos + issueData.context.searchText.length);
                    this.$textArea.focus();
                }
                break;

            case 'replace':
                /* Заменить текст с ошибкой */

                text = this.$textArea.get('value');
                pos = text.indexOf(issueData.context.searchText);

                if (pos == -1)
                {
                    msgErrorBox.alert('Ошибка','Строка с ошибкой в тексте не найдена. Попробуйте проверить текст повторно.');
                }
                else
                {
                    var replaceId = $(el).get('data-sugg-id');
                    var replaceText = issueData.context.searchText.replace(""+issueData.context.issueText,issueData['suggestions'][replaceId]['value']);

                    text = text.replace(""+issueData.context.searchText,replaceText);
                    this.$textArea.set('value',text);

                    this.detectedIssues[issueId].resolved = true;
                    $$('#speller-issue-' + issueId +' span').removeClass(issueData.cssName);
                }
                break;

            case 'discuss':
                /* Открываем окно ссылкой на форум */
                var forumUrl = 'http://shoptips.ru/bb/topic/4236-%D0%BE%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B8-%D0%BE%D1%80%D1%84%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%B8/page__view__getnewpost';
                window.open(forumUrl, '_blank');
                this.spellerMenuClose();

                break;

            case 'report_word':
                /* Предложить слово для словаря */
                JsHttpRequest.query(
                    'POST '+this.options.reportUrl,
                    {
                        topicId : this.options.topicId,
                        topicType: this.options.topicType,

                        userId : this.options.userId,
                        curUserId : this.options.curUserId,

                        issue : issueData.context.issueText,
                        context: issueData.context.startText +  issueData.context.issueText + issueData.context.endText,

                        security_ls_key: LIVESTREET_SECURITY_KEY
                    },
                    function(result)
                    {
                        msgNoticeBox.alert('Информация','Спасибо, мы проверим и добавим предложенное слово в словарь.');
                    },
                    true
                );

                this.spellerMenuClose();
                break;

            default:
                /* none */
        }


    },

    /** ----------------------/ Служебные функции /---------------------
     * 
     * Возвращает хеш от текста 
     */
    getHash: function()
    {
        var text = this.$textArea.get('value');
        var hash = 0;
        var symbol = "";

        if (text.length == 0) return hash;
        for (var i = 0; i < text.length; i++)
        {
            symbol = text.charCodeAt(i);
            hash = ((hash<<5)-hash)+symbol;
            hash = hash & hash; // Convert to 32bit integer
        }

        return hash;
    },

    /**
     * Разбивает текст на фразы заданной длины
     */
    wordWrap: function(str, width, brk, cut)
    {
        brk = brk || '\n';
        width = width || 75;
        cut = cut || false;
        if (!str)
        {
            return str;
        }
        var regex = '.{1,' +width+ '}(\\s|$)' + (cut ? '|.{' +width+ '}|.+$' : '|\\S+?(\\s|$)');
        return str.match( new RegExp(regex, 'g') ).join( brk );
    },

    /**
     * Convert a string to HTML entities
     */
    toHtmlEntities: function(text)
    {
        return text.replace(/./gm, function(s)
        {
            return "&#" + s.charCodeAt(0) + ";";
        });
    },

    /**
     * Create string from HTML entities
     */
    fromHtmlEntities: function(text)
    {
        return (text+"").replace(/&#\d+;/gm,function(s)
        {
            return String.fromCharCode(s.match(/\d+/gm)[0]);
        });
    },

    /**
     * Из описания ошибки создает меню с возможными вариантами исправления
     */
    renderMenu: function(issueId,issueData)
    {
        /*
         * Создаем список элементов
         * для каждого элемента указываем
         * css class
         * содержимое
         * и реакцию на onClick
         */

        /* Создаем html код */
        var html = '<table cellspacing="0" cellpadding="0" border="0" id="speller-issue-menu-tbl" class="speller-issue-menu-tbl">';

        /* Добавляем заголовок */
        html += '<tr><td class="speller-issue-menu-title">' + issueData['description'] + '</td></tr>';

        /* Добавляем подсказки (если они есть) */
        var needSepatator = false;
        for (var i = 0; i < issueData.suggestions.length; i++)
        {
            if (i >= 5)
            {
                break;
            }

            needSepatator = true;
            html += '<tr><td class="speller-issue-menu-item" data-issue-id="'+issueId+'" data-action="replace" data-sugg-id="' + i +'">' + issueData['suggestions'][i]['value'] + '</td></tr>';
        }

        if (needSepatator)
        {
            html += '<tr><td class="speller-issue-menu-sep"></td></tr>';
        }

        html += '<tr><td class="speller-issue-menu-item" data-issue-id="'+issueId+'" data-action="go">Перейти к ошибке</td></tr>';

        var isSpellingRule = issueData.ruleid.indexOf("MORFOLOGIK_RULE") != -1
                            || issueData.ruleid.indexOf("SPELLER_RULE") != -1
                            || issueData.ruleid.indexOf("HUNSPELL_NO_SUGGEST_RULE") != -1
                            || issueData.ruleid.indexOf("HUNSPELL_RULE") != -1;

        /* Если это опечатка */
        if (isSpellingRule)
        {
            //html += '<tr><td class="speller-issue-menu-item" data-issue-id="'+issueId+'" data-action="ignore_word">Игнорировать эту ошибку</td></tr>';
            html += '<tr><td class="speller-issue-menu-item" data-issue-id="'+issueId+'" data-action="report_word">Предложить слово для словаря</td></tr>';
        }
        else
        {
            //html += '<tr><td class="speller-issue-menu-item" data-issue-id="'+issueId+'" data-action="ignore_word">Пропустить этот вид ошибок</td></tr>';
        }

        /* Обсудить работу */
        html += '<tr><td class="speller-issue-menu-sep"></td></tr>';
        html += '<tr><td class="speller-issue-menu-item" data-issue-id="'+issueId+'" data-action="discuss">Обсудить работу спеллчекера</td></tr>';

        html += '</table>';

        return html;
    },

    /* Проверяет, что мышка находится за пределами елемента */
    outsideClick: function(event, element)
    {
        var mousePos = this.getMousePos(event);
        var elementData = element.getCoordinates();
        return (mousePos.x > elementData.left && mousePos.x < (elementData.left + elementData.width)) &&
               (mousePos.y > elementData.top  && mousePos.y < (elementData.top + elementData.height)) ? false : true;
    },

    getMousePos: function(event)
    {
        if(document.all)
        {
            return { 'x': window.event.clientX + window.getScrollLeft(),
                'y': window.event.clientY + window.getScrollTop() };
        }
        else
        {
            return { 'x': event.page['x'],
                'y': event.page['y'] };
        }
    }

};
;
/* exported OpenAddComplainForm */
function OpenAddComplainForm(iTopicId,sTopicName)
{
    if(iTopicId > 0)
    {
        $('complain_topic_id').setProperty('value',iTopicId);
        $('complain_topic_name').set('html',sTopicName);
        $('complain_text').setProperty('value','');
        $('complainWindow').show();
    }

    return false;
}

/* exported CloseComplainForm */
function CloseComplainForm(sFormId)
{
    $(sFormId).hide();
}

/* exported AddComplain */
function AddComplain()
{
    var aParams = {
        'security_ls_key': LIVESTREET_SECURITY_KEY,
        'complain_topic_id': $('complain_topic_id').getProperty('value'),
        'complain_text': $('complain_text').getProperty('value')
    };

    JsHttpRequest.query(
        'POST '+ aRouter.complain + '/add',
        aParams,
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
                return;
            }

            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                msgNoticeBox.alert('Сохранено','Жалоба успешно добавлена.');
                CloseComplainForm('complainWindow');
            }
        },
        true
    );
}

/* exported OpenAddCommentComplainForm */
function OpenAddCommentComplainForm(iCommentId)
{
    $('complain_comment_id').setProperty('value',iCommentId);
    $('comment_complain_text').setProperty('value','');
    $('commentComplainWindow').show();

    return false;
}

/* exported AddCommentComplain */
function AddCommentComplain()
{
    var aValues = $$('input[name=complain_cause]:checked').map(function(e)
    {
        return e.value;
    });

    var aParams = {
        'comment_id': $('complain_comment_id').getProperty('value'),
        'security_ls_key': LIVESTREET_SECURITY_KEY,
        'complain_cause': aValues[0],
        'comment_complain_text': $('comment_complain_text').getProperty('value')
    };

    JsHttpRequest.query(
        'POST '+ aRouter.complain + '/comment_add',
        aParams,
        function(result)
        {
            if (!result)
            {
                msgErrorBox.alert('Error','Please try again later');
                return;
            }

            if (result.bStateError)
            {
                msgErrorBox.alert(result.sMsgTitle,result.sMsg);
            }
            else
            {
                msgNoticeBox.alert('Сохранено','Жалоба успешно добавлена.');
                CloseComplainForm('commentComplainWindow');
            }
        },
        true
    );
};
/**
 * Иногда приходится использовать JS код, которые вставлен на страницу
 * через <script>, так как срипты , мы его обрачиваем в кастомную функцию 
 * которую нужно вызвать когда документ загрузится
 */
window.addEvent('domready', function() {
    
    window['msfqueue'] =  window['msfqueue'] || [];
    window['msfqueue'].forEach(function (fn, index) {
        fn();
      });    
    
});


  ;
